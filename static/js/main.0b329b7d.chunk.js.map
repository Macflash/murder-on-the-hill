{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["MoveCoord","c","direction","x","y","Tile","info","initialDoors","rotation","doors","this","Set","neededDoors","neededWalls","canPlace","forEach","has","r","t","rotate","floor","hasCoord","coord","rotatedDoors","door","add","allDirections","index","indexOf","length","Rotate","GridTile","props","tile","style","position","height","tileSize","width","top","window","innerHeight","centerY","left","innerWidth","centerX","display","justifyContent","alignItems","color","backgroundColor","name","map","d","hasDoor","opened","hasNeighbor","getWallPosition","bottom","right","undefined","GridWall","row","filler","flex","flexDirection","overflow","cursor","onClick","fillCoord","RenderApp","FourWay","TeeWay","Straight","LTurn","RTurn","DeadEnd","AllWay","copy","TwoWay","TileLibrary","FirstFloor","grid","Map","getTile","get","hasTile","setTile","alert","set","fillTile","getCoord","neighbor","Opposite","console","log","matchingTiles","filter","newTile","Math","random","Array","from","leftPressed","upPressed","rightPressed","downPressed","document","addEventListener","e","key","animate","requestAnimationFrame","App","React","useState","setState","rerender","useCallback","useEffect","className","zIndex","padding","id","tiles","p","i","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.0b329b7d.chunk.js","sourcesContent":["import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { dir } from 'console';\nimport { Dir } from 'fs';\n\ntype Direction = \"TOP\" | \"LEFT\" | \"RIGHT\" | \"BOTTOM\";\n\nfunction AllDirections(): Direction[] {\n  return [\"TOP\", \"RIGHT\", \"BOTTOM\", \"LEFT\"];\n}\n\nfunction Opposite(direction: Direction): Direction {\n  switch (direction) {\n    case \"TOP\":\n      return \"BOTTOM\";\n    case \"BOTTOM\":\n      return \"TOP\";\n    case \"RIGHT\":\n      return \"LEFT\";\n    case \"LEFT\":\n      return \"RIGHT\";\n  }\n}\n\nfunction Rotate(direction: Direction, rotation: number) {\n  const allDirections = AllDirections();\n  const index = allDirections.indexOf(direction);\n  return allDirections[(index + rotation) % allDirections.length];\n}\n\ninterface Coord {\n  x: number,\n  y: number\n};\n\nfunction MoveCoord(c: Coord, direction: Direction): Coord {\n  const { x, y } = c;\n  // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\n  switch (direction) {\n    case \"TOP\":\n      return { x, y: y - 1 };\n    case \"BOTTOM\":\n      return { x, y: y + 1 };\n    case \"RIGHT\":\n      return { x: x + 1, y };\n    case \"LEFT\":\n      return { x: x - 1, y };\n  }\n}\n\ntype JunctionSet = Set<Direction>;\ntype Junctions = boolean[];\ntype JMap = Map<number, Tile>;\n\ninterface TileInfo {\n  name: string;\n\n  doors: Direction[],\n}\n\nclass Tile {\n  // Rotations RIGHT in 90 increments. 0-3;\n  //public rotation = 0; // TODO\n  public x = 0;\n  public y = 0;\n  private initialDoors: Set<Direction>;\n  private rotation = 0;\n\n  constructor(public readonly info: TileInfo) {\n    const { doors } = info;\n    this.initialDoors = new Set<Direction>(doors);\n  }\n\n  get coord(): Coord {\n    return { x: this.x, y: this.y };\n  }\n\n  get doors(): Set<Direction> {\n    const rotatedDoors = new Set<Direction>();\n    this.initialDoors.forEach(door => { rotatedDoors.add(Rotate(door, this.rotation)) });\n    return rotatedDoors;\n  }\n\n  /** Return valid rotations for the tile to be placed in a spot with the given constraints. */\n  // TODO: Handle ROTATION PROBABLY!\n  canPlace(neededDoors: Set<Direction>, neededWalls: Set<Direction>): boolean {\n    // TODO: Wait what about WALLS where we SHOULDNT have doors!\n    // ensure all needed doors are there\n    let canPlace = true;\n    neededDoors.forEach(direction => {\n      if (!this.doors.has(direction)) {\n        canPlace = false;\n      }\n    });\n\n    // ensure all needed walls have no doors!\n    neededWalls.forEach(direction => {\n      if (this.doors.has(direction)) {\n        canPlace = false;\n      }\n    });\n\n    return canPlace;\n  }\n\n  copy(r?: number) {\n    const t = new Tile(this.info);\n    if (r) {\n      t.rotate(r);\n    }\n    else {\n      t.rotate(this.rotation);\n    }\n    return t;\n  }\n\n  rotate(r: number) {\n    this.rotation = r % 4;\n    return this;\n  }\n\n  hasNeighbor(floor: Floor, direction: Direction): boolean {\n    // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\n    return floor.hasCoord(MoveCoord(this.coord, direction));\n  }\n}\n\n\nexport const GridTile: React.FC<{ tile: Tile, floor: Floor }> = props => {\n  const { tile, floor } = props;\n\n  // todo draw stuff for each EDGE!\n  return <div\n    style={{\n      position: \"absolute\",\n      height: tileSize,\n      width: tileSize,\n      top: tile.y! * tileSize + .5 * (window.innerHeight - tileSize) - centerY,\n      left: tile.x! * tileSize + .5 * (window.innerWidth - tileSize) - centerX,\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      color: \"white\",\n      //border: '5px solid black',\n      backgroundColor: \"#663333\",\n    }}>\n    {tile.info.name}\n    {AllDirections().map(d => <GridWall tile={tile} floor={floor} direction={d} hasDoor={tile.doors.has(d)} opened={tile.hasNeighbor(floor, d)} />)}\n  </div>;\n}\n\nconst wallSize = 10;\nconst doorSize = 48;\n\nfunction getWallPosition(direction: Direction) {\n  let top: string | number = 0;\n  let bottom: string | number = 0;\n  let left: string | number = 0;\n  let right: string | number = 0;\n\n  let width: number | undefined = wallSize;\n  let height: number | undefined = wallSize;\n\n  switch (direction) {\n    case \"TOP\":\n      bottom = \"auto\";\n      width = undefined;\n      break;\n    case \"BOTTOM\":\n      top = \"auto\";\n      width = undefined;\n      break;\n    case \"RIGHT\":\n      left = \"auto\";\n      height = undefined;\n      break;\n    case \"LEFT\":\n      right = \"auto\";\n      height = undefined;\n      break;\n  }\n\n  return { top, bottom, left, right, width, height };\n}\n\nexport const GridWall: React.FC<{ tile: Tile, floor: Floor, direction: Direction, hasDoor: boolean, opened: boolean }> = props => {\n  const { direction, opened, hasDoor, tile, floor } = props;\n  const row = direction == \"TOP\" || direction == \"BOTTOM\";\n  const filler = <div style={{ flex: \"auto\", backgroundColor: \"black\", height: row ? \"100%\" : undefined, width: row ? undefined : \"100%\" }}></div>;\n\n  return <div\n    style={{\n      ...getWallPosition(direction),\n      position: \"absolute\",\n      display: \"flex\",\n      flexDirection: row ? \"row\" : \"column\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      //backgroundColor: \"black\",\n      overflow: \"hidden\",\n    }}>\n    {filler}\n    {hasDoor ?\n      <div\n        style={{ cursor: opened ? undefined : \"pointer\", height: doorSize, width: doorSize, backgroundColor: opened ? \"\" : \"grey\" }}\n        onClick={opened ? undefined : () => {\n          // TODO: add a NEW tile that like.. matches the constraints!\n          // for now... FOURWAY!  \n\n          floor.fillCoord(MoveCoord(tile.coord, direction));\n          //floor.setCoord(FourWay.create(), Offset(tile.coord, direction));\n          RenderApp();\n        }}\n      >\n      </div>\n      : null}\n    {filler}\n  </div>;\n}\n\nconst FourWay = new Tile({ name: \"Fourway\", doors: [\"TOP\", \"LEFT\", \"RIGHT\", \"BOTTOM\"] });\nconst TeeWay = new Tile({ name: \"TeeWay\", doors: [\"TOP\", \"LEFT\", \"RIGHT\"] });\nconst Straight = new Tile({ name: \"Straight\", doors: [\"TOP\", \"BOTTOM\"] });\nconst LTurn = new Tile({ name: \"LTurn\", doors: [\"TOP\", \"RIGHT\"] });\nconst RTurn = new Tile({ name: \"RTurn\", doors: [\"TOP\", \"LEFT\"] });\nconst DeadEnd = new Tile({ name: \"DeadEnd\", doors: [\"TOP\"] });\n\n\nfunction AllWay(tile: Tile): Tile[] {\n  return [tile, tile.copy(1), tile.copy(2), tile.copy(3)];\n}\n\nfunction TwoWay(tile: Tile): Tile[] {\n  return [tile, tile.copy(1)];\n}\n\nconst TileLibrary = [\n  ...TwoWay(FourWay),\n  ...TwoWay(Straight),\n  ...AllWay(TeeWay),\n  ...AllWay(LTurn),\n  ...AllWay(RTurn),\n  ...AllWay(DeadEnd),\n];\n\n\nclass Floor {\n  constructor(public readonly name: string) { }\n\n  private grid = new Map<string, Tile>();\n\n  private index(x: number, y: number) { return `${x}, ${y}`; }\n\n  getCoord(c: Coord): Tile | undefined { return this.getTile(c.x, c.y); }\n  getTile(x: number, y: number): Tile | undefined { return this.grid.get(this.index(x, y)); }\n\n  hasCoord(c: Coord): boolean { return this.hasTile(c.x, c.y); }\n  hasTile(x: number, y: number): boolean { return this.grid.has(this.index(x, y)); }\n\n  setCoord(tile: Tile, c: Coord) { this.setTile(tile, c.x, c.y); }\n  setTile(tile: Tile, x: number, y: number) {\n    if (this.hasTile(x, y)) {\n      alert(\"Already had a tile there!\");\n      throw \"already had a tile!\";\n    }\n\n    tile.x = x;\n    tile.y = y;\n    this.grid.set(this.index(x, y), tile);\n  }\n\n  get tiles(): Tile[] {\n    return Array.from(this.grid, ([key, tile]) => tile);\n  }\n\n  // return all POSSIBLE playing places\n  getValidSpotsForTiles() {\n    // this is maybe not the best approach. Cool ,but not needed right now...\n  }\n\n  fillCoord(c: Coord) { this.fillTile(c.x, c.y); }\n  fillTile(x: number, y: number) {\n    // fill a gap with a VALID tile. Woops do we need rotation soon?\n    // 1. get all tiles bordering this.\n    const neighbors = AllDirections().map(d => this.getCoord(MoveCoord({ x, y }, d)));\n    const neededDoors = new Set<Direction>();\n    const neededWalls = new Set<Direction>();\n\n    AllDirections().forEach(direction => {\n      const neighbor = this.getCoord(MoveCoord({ x, y }, direction));\n      if (neighbor) {\n        if (neighbor.doors.has(Opposite(direction))) {\n          neededDoors.add(direction);\n        }\n        else {\n          neededWalls.add(direction);\n        }\n      }\n    });\n\n    console.log(\"fill tile needs these doors:\", neededDoors, \"and these walls:\", neededWalls);\n\n    // now find available tiles\n    const matchingTiles = TileLibrary.filter(tile => tile.canPlace(neededDoors, neededWalls));\n    console.log(\"These tiles could fit here!\", matchingTiles);\n    // pick a random tile!\n\n    if (!matchingTiles) { throw \"wow we should really fix that!\"; }\n\n    const newTile = matchingTiles[Math.floor(Math.random() * matchingTiles.length)].copy();\n    console.log(\"adding new tile!\", newTile);\n    this.setTile(newTile, x, y);\n  }\n}\n\nconst FirstFloor = new Floor(\"Main Floor\");\nFirstFloor.setTile(FourWay.copy(), 0, 0);\n\nconst tileSize = 200;\nlet centerX = 0;\nlet centerY = 0;\n\nvar RenderApp = () => { };\n\nfunction App() {\n  const [, setState] = React.useState(0);\n  const rerender = React.useCallback(() => {\n    setState(Math.random());\n  }, [setState]);\n\n  React.useEffect(() => { RenderApp = rerender; }, [rerender]);\n  return (\n    <div className=\"App\" style={{ overflow: \"hidden\" }}>\n      <div style={{ zIndex: 100, bottom: 0, padding: 20, position: \"absolute\", left: 0, right: 0 }}>\n        <button onClick={() => { centerY -= 100; rerender(); }}>UP!</button>\n        <button onClick={() => { centerY += 100; rerender(); }}>DOWN!</button>\n        <button onClick={() => { centerX -= 100; rerender(); }}>LEFT!</button>\n        <button onClick={() => { centerX += 100; rerender(); }}>RIGHT!</button>\n        <button onClick={() => { centerX = 0; centerY = 0; rerender(); }}>CENTER!</button>\n      </div>\n      <div style={{ position: \"absolute\", zIndex: 50, height: 25, width: 10, backgroundColor: \"red\", left: \"calc(50% - 10px)\", right: \"calc(50% + 10px)\", top: \"calc(50% - 25px)\", bottom: \"calc(50% + 25px)\", padding: 5 }}></div>\n      <div id=\"gamefloor\">\n        {FirstFloor.tiles.map((p, i) => <GridTile floor={FirstFloor} tile={p} key={i} />)}\n      </div>\n    </div>\n  );\n}\n\nlet leftPressed = false;\nlet upPressed = false;\nlet rightPressed = false;\nlet downPressed = false;\n\ndocument.addEventListener('keydown', e => {\n  console.log(e.key);\n  if (e.key == \"a\" || e.key == \"ArrowLeft\") {\n    leftPressed = true;\n    rightPressed = false;\n  }\n  if (e.key == \"d\" || e.key == \"ArrowRight\") {\n    rightPressed = true;\n    leftPressed = false;\n  }\n  if (e.key == \"w\" || e.key == \"ArrowUp\") {\n    upPressed = true;\n    downPressed = false;\n  }\n  if (e.key == \"s\" || e.key == \"ArrowDown\") {\n    downPressed = true;\n    upPressed = false;\n  }\n});\n\ndocument.addEventListener('keyup', e => {\n  console.log(e.key);\n  if (e.key == \"a\" || e.key == \"ArrowLeft\") {\n    leftPressed = false;\n  }\n  if (e.key == \"d\" || e.key == \"ArrowRight\") {\n    rightPressed = false;\n  }\n  if (e.key == \"w\" || e.key == \"ArrowUp\") {\n    upPressed = false;\n  }\n  if (e.key == \"s\" || e.key == \"ArrowDown\") {\n    downPressed = false;\n  }\n});\n\nconst moveSpeed =2;\n\nfunction animate(){\n  if (leftPressed) {\n    centerX -= moveSpeed;\n  }\n  if (rightPressed) {\n    centerX += moveSpeed;\n  }\n  if (upPressed) {\n    centerY -= moveSpeed;\n  }\n  if (downPressed) {\n    centerY += moveSpeed;\n  }\n  RenderApp();\n  requestAnimationFrame(()=>animate());\n}\n\nanimate();\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}