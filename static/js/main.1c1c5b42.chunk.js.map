{"version":3,"sources":["images/players/kid_green.png","tiles/Coord.ts","tiles/Items.tsx","tiles/Collision.ts","tiles/Size.ts","GridTile.tsx","tiles/Direction.ts","tiles/Tile.ts","tiles/Rooms.ts","tiles/Floor.ts","tiles/SightLines.ts","Player.tsx","tiles/Interaction.tsx","tiles/Inventory.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","MoveCoord","c","direction","x","y","Add","a","b","PickUpItem","name","canDoOnGround","canDoInInventory","action","player","item","hidden","Error","inventory","push","DropItem","position","splice","indexOf","DisplayItemInfo","alert","description","items","GetItems","filter","GridItem","props","tileOffset","hW","width","hH","height","title","style","zIndex","backgroundColor","image","undefined","color","top","centerY","window","innerHeight","left","centerX","innerWidth","src","transform","imageTransform","curesedKnife","mass","velocity","playerInteractions","watch","purse","Math","random","CopyItem","GetTileCoord","floor","GetRoomCoord","tileCoord","CollideWithWalls","createOnDoor","hT","hD","doorSize","hDX","hDY","roomX","roomY","leftWall","wallSize","rightWall","topWall","bottomWall","tile","getCoord","hasDoor","hasDoorAndOpenIfNeeded_New","abs","doors","has","HasDoor","coord","newCoord","hasCoord","fillCoord","CreateRoomIfNeeded","GetItemsInInteractionDistance","i","sqrt","pow","screenSize","max","tileViewDist","ceil","addEventListener","console","log","GridTile","overlayMode","cameraCoord","display","justifyContent","alignItems","info","map","d","opened","hasNeighbor","getWallPosition","size","bottom","right","GridWall","row","filler","flex","flexDirection","overflow","cursor","onClick","RenderApp","Tile","initialDoors","rotation","this","Set","neededDoors","neededWalls","canPlace","forEach","r","t","rotate","rotatedDoors","door","add","allDirections","index","length","Rotate","FourWay","TeeWay","Straight","LTurn","RTurn","DeadEnd","AllWay","copy","TwoWay","TileLibrary","Index","FirstFloor","grid","Map","getTile","get","hasTile","setTile","tileCenter","set","fillTile","neighbor","Opposite","matchingTiles","newTile","Array","from","fog","ctx","rayStep","rayLength","angleSize","PI","shootRay","start","stepVector","ray","toScreenSpot","UpdateFog","document","getElementById","getContext","clearRect","rayPoints","points","angle","cos","sin","shootRaysInCircle","fillStyle","strokeStyle","beginPath","playerCoord","moveTo","point","p","lineTo","stroke","fill","kid_green","fear","health","intelligence","speed","spirit","strength","GridPlayer","interactables","toScreenPositionStyle","spot","MenuStyle","border","padding","InteractionButtons","inInventory","onGround","interaction","Interactions","textAlign","Inventory","maxWidth","maxHeight","showMap","canvasStyle","leftPressed","upPressed","rightPressed","downPressed","mPressed","e","key","animate","players","ApplyFriction","roomItems","requestAnimationFrame","App","React","useState","setState","rerender","useCallback","useEffect","className","id","opacity","mixBlendMode","tiles","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.1c1c5b42.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","import { Direction } from './Direction';\r\n\r\nexport interface Coord {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport function MoveCoord(c: Coord, direction: Direction): Coord {\r\n  const { x, y } = c;\r\n  // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return { x, y: y - 1 };\r\n    case \"BOTTOM\":\r\n      return { x, y: y + 1 };\r\n    case \"RIGHT\":\r\n      return { x: x + 1, y };\r\n    case \"LEFT\":\r\n      return { x: x - 1, y };\r\n  }\r\n}\r\n\r\nexport function MidPoint(a: Coord, b: Coord) {\r\n  return {\r\n    x: (a.x + b.x) / 2,\r\n    y: (a.y + b.y) / 2,\r\n  };\r\n}\r\n\r\n\r\nexport function Copy(a: Coord) {\r\n  return {\r\n    x: (a.x),\r\n    y: (a.y),\r\n  };\r\n}\r\n\r\nexport function Add(a: Coord, b: Coord) {\r\n  return {\r\n    x: (a.x + b.x),\r\n    y: (a.y + b.y),\r\n  };\r\n}\r\n\r\nexport function Multiply(a: Coord, b: number) {\r\n  return {\r\n    x: (a.x * b),\r\n    y: (a.y * b),\r\n  };\r\n}\r\n\r\n// Distances ordered by their stupidness\r\nexport function Distance(a: Coord, b: Coord) {\r\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\r\n}\r\n\r\nexport function HammingDistance(a: Coord, b: Coord) {\r\n  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n}\r\n\r\nexport function EitherDirectionDistance(a: Coord, b: Coord) {\r\n  return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\r\n}","import * as React from 'react';\r\nimport { centerY, centerX } from '../App';\r\nimport { Coord, Copy } from \"./Coord\";\r\n\r\nexport interface Item {\r\n    position: Coord;\r\n    height: number;\r\n    width: number;\r\n\r\n    name?: string;\r\n    description?: string;\r\n    color?: string; // TODO this should be an image or graphic or canvas dude!\r\n\r\n    mass: number;\r\n    velocity: Coord;\r\n    image?: string;\r\n    imageTransform?: string;\r\n\r\n    hidden?: boolean;\r\n\r\n    playerInteractions?: PlayerItemInteraction[];\r\n}\r\n\r\n// TODO: actually do this stuff and like track some basic stats\r\nexport interface Player extends Item {\r\n    /**\r\n     * Items you are carrying.\r\n     * IDK do we need some kind of ACTIVE vs CARRIED distinction for some items,\r\n     * like you can't have 4 weapons at the same time\r\n     */\r\n    inventory: Item[];\r\n    health: number;\r\n    fear: number;\r\n    strength: number; // force when moving, affects carry strength\r\n    speed: number;\r\n    intelligence: number;\r\n    spirit: number; // like religion, spiritual strength. e/g/ won't be scared from weird shit dude.\r\n}\r\n\r\ninterface PlayerItemInteraction {\r\n    name: string,\r\n    canDoOnGround: boolean,\r\n    canDoInInventory: boolean,\r\n    action: PlayerItemInteraction_Action,\r\n}\r\n\r\nconst PickUpItem: PlayerItemInteraction = {\r\n    name: \"Pick up\",\r\n    canDoOnGround: true,\r\n    canDoInInventory: false,\r\n    action: (player, item) => {\r\n        if (item.hidden) {\r\n            throw new Error(\"Cant pick up a hidden item!!!\");\r\n        }\r\n        player.inventory.push(item);\r\n        item.hidden = true;\r\n    }\r\n}\r\n\r\nconst DropItem: PlayerItemInteraction = {\r\n    name: \"Drop\",\r\n    canDoOnGround: false,\r\n    canDoInInventory: true,\r\n    action: (player, item) => {\r\n        if (!item.hidden) {\r\n            throw new Error(\"Cant drop up a visible item!!!\");\r\n        }\r\n\r\n        item.position = Copy(player.position);\r\n        player.inventory.splice(player.inventory.indexOf(item), 1);\r\n        item.hidden = false;\r\n    }\r\n}\r\n\r\nconst DisplayItemInfo: PlayerItemInteraction = {\r\n    name: \"Info\",\r\n    canDoOnGround: true,\r\n    canDoInInventory: true,\r\n    action: (player, item) => {\r\n        alert(item.description);\r\n    }\r\n}\r\n\r\nconst CantDropItem: PlayerItemInteraction = {\r\n    name: \"Try to drop\",\r\n    canDoOnGround: false,\r\n    canDoInInventory: true,\r\n    action: (player, item) => {\r\n        alert(\"You can't put it down, it's as if it was part of you now.\");\r\n    }\r\n}\r\n\r\n\r\ntype PlayerItemInteraction_Action = (player: Player, item: Item) => void;\r\n\r\nexport function ToBoundingBox(item: Item) {\r\n    return {\r\n        x: item.position.x - item.width * .5,\r\n        y: item.position.y - item.height * .5,\r\n        height: item.height,\r\n        width: item.width,\r\n    };\r\n}\r\n\r\n/* Check two items for collision! */\r\nexport function RectangleCollision(a: Item, b: Item) {\r\n    const rect1 = ToBoundingBox(a);\r\n    const rect2 = ToBoundingBox(b);\r\n    return rect1.x < rect2.x + rect2.width &&\r\n        rect1.x + rect1.width > rect2.x &&\r\n        rect1.y < rect2.y + rect2.height &&\r\n        rect1.y + rect1.height > rect2.y;\r\n}\r\n\r\nvar items: Item[] = [];\r\n\r\n// yo if we stored these BY room it would be pretty cool.\r\nexport function AddItem(item: Item) {\r\n    items.push(item);\r\n}\r\n\r\nexport function GetItems() {\r\n    return items.filter(item => !item.hidden);\r\n}\r\n\r\nexport const itemZindex = 50;\r\n\r\n\r\nexport function GridItem(props: { item: Item, zIndex?: number, tileOffset?: Coord }) {\r\n    const { item, tileOffset } = props;\r\n    const hW = item.width * .5;\r\n    const hH = item.height * .5;\r\n\r\n    return <div\r\n        title={item.name}\r\n        style={{\r\n            position: \"absolute\",\r\n            zIndex: props.zIndex || itemZindex,\r\n            height: item.height,\r\n            width: item.width,\r\n            backgroundColor: item.image ? undefined : item.color || \"grey\",\r\n            top: item.position.y - centerY + (.5 * window.innerHeight) - hH - (tileOffset?.y ||0),\r\n            left: item.position.x - centerX + (.5 * window.innerWidth) - hW - (tileOffset?.x ||0),\r\n        }}>\r\n        {item.image ? <img src={item.image} style={{ transform: item.imageTransform }} /> : null}\r\n    </div>;\r\n}\r\n\r\nexport const curesedKnife: Item = {\r\n    position: { x: 0, y: 30 },\r\n    height: 5,\r\n    width: 20,\r\n    color: \"red\",\r\n    name: \"Wicked Knife\",\r\n    mass: 5,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A sickening looking knife. You can't tell if that is blood or rust on the blade. Yet you feel oddly... compelled to pick it up.\",\r\n    playerInteractions: [PickUpItem, DisplayItemInfo, CantDropItem],\r\n};\r\n\r\nexport const watch: Item = {\r\n    position: { x: 150, y: 180 },\r\n    height: 15,\r\n    width: 20,\r\n    color: \"green\",\r\n    name: \"Purse\",\r\n    mass: 4,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A fancy purse. It looks old, who could have left it here?\",\r\n    playerInteractions: [PickUpItem, DisplayItemInfo, DropItem],\r\n};\r\n\r\nexport const box: Item = {\r\n    position: {x: 0, y: 40 },\r\n    height: 20,\r\n    width: 20,\r\n    color: \"brown\",\r\n    name: \"Box\",\r\n    mass: 15,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A closed cardboard box. It feels heavy. What could be inside?\",\r\n    playerInteractions: [PickUpItem,DisplayItemInfo, DropItem],\r\n};\r\n\r\n\r\nexport const purse: Item = {\r\n    position: {x: (Math.random() - .5) * 300, y: 150 },\r\n    height: 10,\r\n    width: 10,\r\n    color: \"gold\",\r\n    name: \"Watch\",\r\n    mass: .5,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A small, worn pocketwatch. It looks like it is made of gold, but the time is stuck at midnight. What could happen if you wind it?\",\r\n    playerInteractions: [PickUpItem, DisplayItemInfo, DropItem],\r\n};\r\n\r\nexport const table: Item = {\r\n    position: { x: -165, y: -150 },\r\n    height: 70,\r\n    width: 40,\r\n    color: \"tan\",\r\n    name: \"Table\",\r\n    mass: 70,\r\n    velocity: { x: 0, y: 0 },\r\n};\r\n\r\nexport function CopyItem(item: Item){\r\n    return {\r\n        ...item,\r\n        position: { ...item.position},\r\n        velocity: { ...item.velocity},\r\n    }\r\n}\r\n// */","\r\n// ok how can we do... intersections and interactions?\r\n// #1 only can hit things in your room (or very rarely a neighboring room that is close by..)\r\n\r\nimport { doorSize, wallSize } from \"../GridTile\";\r\nimport { Coord, Distance, MidPoint, MoveCoord } from \"./Coord\";\r\nimport { Direction } from \"./Direction\";\r\nimport { Floor } from \"./Floor\";\r\nimport { GetItems, Item, RectangleCollision } from \"./Items\";\r\nimport { tileSize } from \"./Size\";\r\nimport { Tile } from \"./Tile\";\r\n\r\n/** The TILE the item is in. */\r\nexport function GetTileCoord(c: Coord): Coord {\r\n    const hT = .5 * tileSize;\r\n    const x = Math.floor((c.x + hT) / tileSize);\r\n    const y = Math.floor((c.y + hT) / tileSize);\r\n    return { x, y };\r\n}\r\n\r\n/** The relative place in the current TILE the item is in. */\r\nexport function GetRoomCoord(item: Item, tileCoord: Coord): Coord {\r\n    const x = item.position.x - (tileCoord.x * tileSize);\r\n    const y = item.position.y - (tileCoord.y * tileSize);\r\n    return { x, y };\r\n}\r\n\r\nconst doorEdgeSize = 3;\r\n\r\nexport function GetWallCorners() {\r\n    // ray trace to all of these basically?\r\n}\r\n\r\nexport function HasRoomOrCreate(floor: Floor | undefined, tile: Tile | undefined, coord: Coord, direction: Direction, create: boolean) {\r\n    const hasDoor = tile && tile.doors.has(direction);\r\n\r\n    if (!hasDoor) { return false; }\r\n\r\n    const newCoord = MoveCoord(coord, direction);\r\n    if (!floor?.hasCoord(newCoord)) {\r\n        if (create) {\r\n            floor?.fillCoord(newCoord);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function HasDoor(tile: Tile | undefined, direction: Direction) {\r\n    return tile && tile.doors.has(direction);\r\n}\r\n\r\nexport function CreateRoomIfNeeded(floor: Floor | undefined, coord: Coord, direction: Direction) {\r\n    const newCoord = MoveCoord(coord, direction);\r\n    if (!floor?.hasCoord(newCoord)) {\r\n        floor?.fillCoord(newCoord);\r\n    }\r\n}\r\n\r\nconst openDoorExtraSize = 10;\r\n\r\nexport function CollideWithWalls(item: Item, floor?: Floor, createOnDoor = false): boolean {\r\n    const hT = .5 * tileSize;\r\n    const hW = .5 * item.width;\r\n    const hH = .5 * item.height;\r\n    const hD = .5 * doorSize;\r\n\r\n    const hDX = hD - hW;\r\n    const hDY = hD - hH;\r\n\r\n    // which TILE is it in?\r\n\r\n    const tileCoord = GetTileCoord(item.position);\r\n    const { x: roomX, y: roomY } = GetRoomCoord(item, tileCoord);\r\n\r\n    const leftWall = hW + wallSize - hT;\r\n    const rightWall = -1 * leftWall;\r\n    const topWall = hH + wallSize - hT;\r\n    const bottomWall = -1 * topWall;\r\n\r\n    const tile = floor?.getCoord(tileCoord);\r\n\r\n    // If you are inside the wall boundary\r\n    if (roomX <= leftWall) {\r\n        // AND you are outside of the door area (or there is no door):\r\n        // Push you back to the edge of the wall.\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"LEFT\", tile, roomY, hDY, hH, createOnDoor, floor);\r\n        if (Math.abs(roomY) > hDY || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomY > 0) {\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.x += leftWall - roomX;\r\n            item.velocity.x = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomX >= rightWall) {\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"RIGHT\", tile, roomY, hDY, hH, createOnDoor, floor);\r\n        if (Math.abs(roomY) > hDY || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomY > 0) {\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.x += rightWall - roomX;\r\n            item.velocity.x = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY <= topWall) {\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"TOP\", tile, roomX, hDX, hW, createOnDoor, floor);\r\n        if (Math.abs(roomX) > hDX || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomX > 0) {\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.y += topWall - roomY;\r\n            item.velocity.y = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY >= bottomWall) {\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"BOTTOM\", tile, roomX, hDX, hW, createOnDoor, floor);\r\n        if (Math.abs(roomX) > hDX || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomX > 0) {\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.y += bottomWall - roomY;\r\n            item.velocity.y = 0;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction hasDoorAndOpenIfNeeded_New(direction: Direction, tile: Tile | undefined, roomY: number, hDY: number, hH: number, createOnDoor: boolean, floor: Floor | undefined) {\r\n    const hasDoor = HasDoor(tile, direction);\r\n    if (Math.abs(roomY) <= (hDY + hH + 5) && hasDoor && createOnDoor) {\r\n        CreateRoomIfNeeded(floor, tile!, direction);\r\n    }\r\n    return hasDoor;\r\n}\r\n\r\nexport function ApplyFriction(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach(item => {\r\n        if (item.velocity) {\r\n            if (item.velocity.x) {\r\n                item.velocity.x *= .9;\r\n                if (Math.abs(item.velocity.x) < .1) { item.velocity.x = 0; }\r\n            }\r\n            if (item.velocity.y) {\r\n                item.velocity.y *= .9;\r\n                if (Math.abs(item.velocity.y) < .1) { item.velocity.y = 0; }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function InelasticCollision(a: Item, b: Item) {\r\n    // final velocity\r\n    const x = (a.mass * a.velocity.x + b.mass * b.velocity.x) / (a.mass + b.mass);\r\n    const y = (a.mass * a.velocity.y + b.mass * b.velocity.y) / (a.mass + b.mass);\r\n\r\n    // step back their velocities a bit??\r\n\r\n    const fudge = .2;\r\n    a.position.x -= a.velocity.x * fudge;\r\n    a.position.y -= a.velocity.y * fudge;\r\n    b.position.x -= b.velocity.x * fudge;\r\n    b.position.y -= b.velocity.y * fudge;\r\n\r\n    // and we want to PUSH them out so they are not colliding.\r\n    // How can we do that? Ideally we would like factor in the faces, but for laziness\r\n    // we could just push opposite the direction?\r\n    a.velocity.x = x;\r\n    a.velocity.y = y;\r\n    b.velocity.x = x;\r\n    b.velocity.y = y;\r\n}\r\n\r\nexport const InteractionRange = 5;\r\nexport function GetItemsInInteractionDistance(player: Item, items: Item[]) {\r\n    return items.filter((item, i) => {\r\n        if (Distance(player.position, item.position) < InteractionRange + .25 * (item.width + item.height + player.width + player.height)) {\r\n            // how do we want to handle multiple items?\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    });\r\n}\r\n\r\nexport function CollideItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach((item, i) => {\r\n        if (i < items.length - 1) {\r\n            for (let j = i + 1; j < items.length; j++) {\r\n                if (RectangleCollision(item, items[j])) {\r\n                    //console.log(\"COLLISION!\", item.name, items[j].name);\r\n                    // TODO: update velocity and stuff??\r\n                    InelasticCollision(item, items[j]);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function MoveItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach((item, i) => {\r\n        if (item.velocity.x) {\r\n            item.position.x += item.velocity.x;\r\n        }\r\n        if (item.velocity.y) {\r\n            item.position.y += item.velocity.y;\r\n        }\r\n    });\r\n}","export const tileSize = 400;\r\n","import React from 'react';\r\nimport { Add, EitherDirectionDistance, HammingDistance, MoveCoord, Multiply } from './tiles/Coord';\r\nimport { Direction, AllDirections } from './tiles/Direction';\r\nimport { Tile } from './tiles/Tile';\r\nimport { centerY, centerX, RenderApp } from './App';\r\nimport { Floor } from \"./tiles/Floor\";\r\nimport { GetTileCoord } from './tiles/Collision';\r\nimport { tileSize } from './tiles/Size';\r\nimport { GridItem, itemZindex } from './tiles/Items';\r\n\r\nexport const wallSize = 12;\r\nexport const doorSize = 100;\r\n\r\n// probably only update this on resize\r\nvar screenSize = Math.max(window.innerWidth, window.innerHeight);\r\nexport var tileViewDist = Math.ceil(screenSize / (2 * tileSize));\r\n\r\nwindow.addEventListener('resize', ()=>{\r\n  screenSize = Math.max(window.innerWidth, window.innerHeight);\r\n  tileViewDist = Math.ceil(screenSize / (2 * tileSize));\r\n  console.log(\"Updated view dist\", tileViewDist);\r\n});\r\n\r\nconsole.log(\"Initial view dist\", tileViewDist);\r\n\r\nexport const GridTile: React.FC<{ tile: Tile; floor: Floor; overlayMode: boolean}> = props => {\r\n  const { tile, floor, overlayMode } = props;\r\n\r\n  // check screen space if we should render it!\r\n  const tileCoord = { x: tile.x, y: tile.y };\r\n  const cameraCoord = GetTileCoord({ x: centerX, y: centerY });\r\n  if (EitherDirectionDistance(tileCoord, cameraCoord) > tileViewDist) {\r\n    return null;\r\n  }\r\n\r\n\r\n  return <><div\r\n    style={{\r\n      zIndex: overlayMode ? 10 : 4,\r\n      position: \"absolute\",\r\n      height: tileSize,\r\n      width: tileSize,\r\n      top: tile.y! * tileSize + .5 * (window.innerHeight - tileSize) - centerY,\r\n      left: tile.x! * tileSize + .5 * (window.innerWidth - tileSize) - centerX,\r\n      display: \"flex\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      color: \"white\",\r\n      //border: '5px solid black',\r\n      backgroundColor:  overlayMode ? undefined : \"#663333\",\r\n    }}>\r\n    {tile.info.name}\r\n    {AllDirections().map(d => <GridWall\r\n      overlayMode={overlayMode}\r\n      tile={tile}\r\n      floor={floor}\r\n      direction={d}\r\n      hasDoor={tile.doors.has(d)}\r\n      opened={tile.hasNeighbor(floor, d)}\r\n    />)}\r\n  </div>\r\n  {tile.info.items?.filter(item => !item.hidden).map(item => <GridItem \r\n  item={item} \r\n  // this was bad and you should feel bad: tileOffset={tileCenter}\r\n   />)}\r\n  </>;\r\n}\r\n\r\nfunction getWallPosition(direction: Direction, size: number) {\r\n  let top: string | number = 0;\r\n  let bottom: string | number = 0;\r\n  let left: string | number = 0;\r\n  let right: string | number = 0;\r\n\r\n  let width: number | undefined = size;\r\n  let height: number | undefined = size;\r\n\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      bottom = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"BOTTOM\":\r\n      top = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"RIGHT\":\r\n      left = \"auto\";\r\n      height = undefined;\r\n      break;\r\n    case \"LEFT\":\r\n      right = \"auto\";\r\n      height = undefined;\r\n      break;\r\n  }\r\n\r\n  return { top, bottom, left, right, width, height };\r\n}\r\n\r\nexport const GridWall: React.FC<{ overlayMode: boolean, tile: Tile; floor: Floor; direction: Direction; hasDoor: boolean; opened: boolean; }> = props => {\r\n  const { direction, opened, hasDoor, tile, floor, overlayMode } = props;\r\n  const row = direction === \"TOP\" || direction === \"BOTTOM\";\r\n  const filler = <div style={{ \r\n    flex: \"auto\",\r\n     backgroundColor: \"#322\",\r\n      height: row ? \"100%\" : undefined, width: row ? undefined : \"100%\" }}></div>;\r\n\r\n  return <div\r\n    style={{\r\n      ...getWallPosition(direction, overlayMode ? 3 : wallSize),\r\n      position: \"absolute\",\r\n      display: \"flex\",\r\n      flexDirection: row ? \"row\" : \"column\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      overflow: \"hidden\",\r\n    }}>\r\n    {filler}\r\n    {hasDoor ?\r\n      <div\r\n        style={{ \r\n          cursor: opened ? undefined : \"pointer\",\r\n           height: doorSize, \r\n           width: doorSize,\r\n            backgroundColor: opened ? \"\" : \"grey\" }}\r\n        onClick={opened ? undefined : () => {\r\n          floor.fillCoord(MoveCoord(tile.coord, direction));\r\n          RenderApp();\r\n        }}\r\n      >\r\n      </div>\r\n      : null}\r\n    {filler}\r\n  </div>;\r\n};\r\n","export type Direction = \"TOP\" | \"LEFT\" | \"RIGHT\" | \"BOTTOM\";\r\n\r\nexport function AllDirections(): Direction[] {\r\n  return [\"TOP\", \"RIGHT\", \"BOTTOM\", \"LEFT\"];\r\n}\r\n\r\nexport function Opposite(direction: Direction): Direction {\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return \"BOTTOM\";\r\n    case \"BOTTOM\":\r\n      return \"TOP\";\r\n    case \"RIGHT\":\r\n      return \"LEFT\";\r\n    case \"LEFT\":\r\n      return \"RIGHT\";\r\n  }\r\n}\r\n\r\nexport function Rotate(direction: Direction, rotation: number) {\r\n  const allDirections = AllDirections();\r\n  const index = allDirections.indexOf(direction);\r\n  return allDirections[(index + rotation) % allDirections.length];\r\n}\r\n","import { Coord, MoveCoord } from './Coord';\r\nimport { Direction, Rotate } from './Direction';\r\nimport { Floor } from './Floor';\r\nimport { Item, CopyItem } from './Items';\r\n\r\ninterface TileInfo {\r\n  name: string;\r\n\r\n  doors: Direction[];\r\n\r\n  items?: Item[]; // These positions are in relative roomX, roomY.\r\n}\r\n\r\nexport class Tile {\r\n  // Rotations RIGHT in 90 increments. 0-3;\r\n  //public rotation = 0; // TODO\r\n  public x = 0;\r\n  public y = 0;\r\n  private initialDoors: Set<Direction>;\r\n  private rotation = 0;\r\n\r\n  constructor(public readonly info: TileInfo) {\r\n    const { doors } = info;\r\n    this.initialDoors = new Set<Direction>(doors);\r\n  }\r\n\r\n  get coord(): Coord {\r\n    return { x: this.x, y: this.y };\r\n  }\r\n\r\n  get doors(): Set<Direction> {\r\n    const rotatedDoors = new Set<Direction>();\r\n    this.initialDoors.forEach(door => { rotatedDoors.add(Rotate(door, this.rotation)); });\r\n    return rotatedDoors;\r\n  }\r\n\r\n  /** Return valid rotations for the tile to be placed in a spot with the given constraints. */\r\n  // TODO: Handle ROTATION PROBABLY!\r\n  canPlace(neededDoors: Set<Direction>, neededWalls: Set<Direction>): boolean {\r\n    // TODO: Wait what about WALLS where we SHOULDNT have doors!\r\n    // ensure all needed doors are there\r\n    let canPlace = true;\r\n    neededDoors.forEach(direction => {\r\n      if (!this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    // ensure all needed walls have no doors!\r\n    neededWalls.forEach(direction => {\r\n      if (this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    return canPlace;\r\n  }\r\n\r\n  copy(r?: number) {\r\n    const t = new Tile({\r\n      ...this.info, \r\n      items: this.info.items?.map(item => CopyItem(item)),\r\n    });\r\n    if (r) {\r\n      t.rotate(r);\r\n    }\r\n    else {\r\n      t.rotate(this.rotation);\r\n    }\r\n    return t;\r\n  }\r\n\r\n  rotate(r: number) {\r\n    this.rotation = r % 4;\r\n    return this;\r\n  }\r\n\r\n  hasNeighbor(floor: Floor, direction: Direction): boolean {\r\n    // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n    return floor.hasCoord(MoveCoord(this.coord, direction));\r\n  }\r\n}\r\n","import { purse, watch,table, CopyItem, curesedKnife } from './Items';\r\nimport { Tile } from './Tile';\r\n\r\nexport const FourWay = new Tile({ name: \"Fourway\", doors: [\"TOP\", \"LEFT\", \"RIGHT\", \"BOTTOM\"] });\r\nFourWay.info.items = [CopyItem(table)];\r\nconst TeeWay = new Tile({ name: \"TeeWay\", doors: [\"TOP\", \"LEFT\", \"RIGHT\"] });\r\nconst Straight = new Tile({ name: \"Straight\", doors: [\"TOP\", \"BOTTOM\"] });\r\n\r\nStraight.info.items = [CopyItem(purse)];\r\n\r\nconst LTurn = new Tile({ name: \"LTurn\", doors: [\"TOP\", \"RIGHT\"] });\r\nconst RTurn = new Tile({ name: \"RTurn\", doors: [\"TOP\", \"LEFT\"] });\r\nRTurn.info.items = [CopyItem(curesedKnife)]; // THIS IS NOT HOW WE SHOULD DO IT. do this when FILLING THE TILE.\r\n\r\nconst DeadEnd = new Tile({ name: \"DeadEnd\", doors: [\"TOP\"] });\r\nDeadEnd.info.items = [CopyItem(watch)]; // THIS IS NOT HOW WE SHOULD DO IT. do this when FILLING THE TILE.\r\n\r\nfunction AllWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1), tile.copy(2), tile.copy(3)];\r\n}\r\n\r\nfunction TwoWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1)];\r\n}\r\n\r\nexport const TileLibrary = [\r\n  ...TwoWay(FourWay),\r\n  ...TwoWay(Straight),\r\n  ...AllWay(TeeWay),\r\n  ...AllWay(LTurn),\r\n  ...AllWay(RTurn),\r\n  ...AllWay(DeadEnd),\r\n];\r\n","import { Add, Coord, MoveCoord, Multiply } from './Coord';\r\nimport { Direction, AllDirections, Opposite } from './Direction';\r\nimport { Tile } from './Tile';\r\nimport { TileLibrary, FourWay } from './Rooms';\r\nimport { tileSize } from './Size';\r\n\r\nexport function IndexCoord(c: Coord) { return Index(c.x, c.y); }\r\nexport function Index(x: number, y: number) { return `${x}, ${y}`; }\r\n\r\nexport class Floor {\r\n  constructor(public readonly name: string) { }\r\n\r\n  private grid = new Map<string, Tile>();\r\n\r\n  getCoord(c: Coord): Tile | undefined { return this.getTile(c.x, c.y); }\r\n  getTile(x: number, y: number): Tile | undefined { return this.grid.get(Index(x, y)); }\r\n\r\n  hasCoord(c: Coord): boolean { return this.hasTile(c.x, c.y); }\r\n  hasTile(x: number, y: number): boolean { return this.grid.has(Index(x, y)); }\r\n\r\n  setCoord(tile: Tile, c: Coord) { this.setTile(tile, c.x, c.y); }\r\n  setTile(tile: Tile, x: number, y: number) {\r\n    if (this.hasTile(x, y)) {\r\n      alert(\"Already had a tile there!\");\r\n      throw \"already had a tile!\";\r\n    }\r\n\r\n    tile.x = x;\r\n    tile.y = y;\r\n    \r\n    const tileCenter = Multiply(Add(tile.coord, { x: 0, y: 0 }), tileSize);\r\n    console.log(\"tile center!\", tileCenter);\r\n    tile.info.items?.forEach(item =>{\r\n    console.log(\"item \" + item.name, item.position);\r\n    item.position = Add(item.position, tileCenter);\r\n    console.log(\"new position \" + item.name, item.position);\r\n    });\r\n\r\n    this.grid.set(Index(x, y), tile);\r\n  }\r\n\r\n  get tiles(): Tile[] {\r\n    return Array.from(this.grid, ([key, tile]) => tile);\r\n  }\r\n\r\n  // return all POSSIBLE playing places\r\n  getValidSpotsForTiles() {\r\n    // this is maybe not the best approach. Cool ,but not needed right now...\r\n  }\r\n\r\n  fillCoord(c: Coord) { this.fillTile(c.x, c.y); }\r\n  fillTile(x: number, y: number) {\r\n    // 1. get all tiles bordering this.\r\n    const neighbors = AllDirections().map(d => this.getCoord(MoveCoord({ x, y }, d)));\r\n    const neededDoors = new Set<Direction>();\r\n    const neededWalls = new Set<Direction>();\r\n\r\n    AllDirections().forEach(direction => {\r\n      const neighbor = this.getCoord(MoveCoord({ x, y }, direction));\r\n      if (neighbor) {\r\n        if (neighbor.doors.has(Opposite(direction))) {\r\n          neededDoors.add(direction);\r\n        }\r\n        else {\r\n          neededWalls.add(direction);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Find possible tiles\r\n    // TODO: Factor in floor (basement, attic, etc) and stuff.\r\n    const matchingTiles = TileLibrary.filter(tile => tile.canPlace(neededDoors, neededWalls));\r\n\r\n    // TODO: we should never CLOSE off the entire floor, E.G. you should always be able to have at least 1 open door on each floor.\r\n\r\n    // Pick a random tile from the possible ones.\r\n    if (!matchingTiles) { throw new Error(\"No valid tile can go there! Wow we should really fix that!\"); }\r\n\r\n    const newTile = matchingTiles[Math.floor(Math.random() * matchingTiles.length)].copy();\r\n\r\n    // PICK items that apear\r\n\r\n    // things can have like SHELVES/etc you need to search\r\n    // things can be on the ground\r\n    // rooms have affinities for certain items, but never GUARANTEED\r\n    // E>G> Knife often found in Kitchens.\r\n    \r\n    this.setTile(newTile, x, y);\r\n  }\r\n}\r\n\r\nexport const FirstFloor = new Floor(\"Main Floor\");\r\nFirstFloor.setTile(FourWay.copy(), 0, 0);\r\n","// anything beyond this we don't need to render.\r\n\r\nimport { centerX, centerY } from \"../App\";\r\nimport { doorSize, tileViewDist, wallSize } from \"../GridTile\";\r\nimport { GetTileCoord, GetRoomCoord, CollideWithWalls } from \"./Collision\";\r\nimport { Coord, MoveCoord } from \"./Coord\";\r\nimport { Direction } from \"./Direction\";\r\nimport { Floor } from \"./Floor\";\r\nimport { Item } from \"./Items\";\r\nimport { tileSize } from \"./Size\";\r\n\r\n// As long as we factor in their size as well...\r\nexport const sightDistance = 400;\r\n\r\nvar fog: HTMLCanvasElement;\r\nvar ctx: CanvasRenderingContext2D;\r\nwindow.addEventListener('resize', () => {\r\n    fog.width = window.innerWidth;\r\n    fog.height = window.innerHeight;\r\n    //UpdateFog();\r\n});\r\n\r\n/** Returns where this hits a wall! */\r\nconst rayStep = wallSize;\r\nvar rayLength = 10 + tileViewDist * tileSize / rayStep; //was like 75 or 100;\r\nconsole.log(\"ray length\", rayLength);\r\nwindow.addEventListener('resize', () => {\r\n    rayLength = 10 + tileViewDist * tileSize / rayStep;\r\n    console.log(\"ray length\", rayLength);\r\n});\r\n// 20 is ok, 60 is good, \r\nconst angleSize = Math.PI / 100;\r\n\r\n// dude you could probably just CALCULATE (DO the math bro! it's faster) the next time the ray would = .5 tilesize  % tilesize\r\nexport function shootRay(start: Coord, stepVector: Coord, floor: Floor): Coord {\r\n    // assume vector is the RIGHT length\r\n    let length = 0;\r\n    let ray = { x: start.x, y: start.y };\r\n    while (!CollideWithWalls({ position: ray, height: 1, width: 1, velocity: { x: 0, y: 0 } } as Item, floor)\r\n        && length < rayLength) {\r\n        ray.x += stepVector.x;\r\n        ray.y += stepVector.y;\r\n        length++;\r\n    }\r\n\r\n    return ray;\r\n}\r\n// PI/10 is clunky, PI/20 is pretty dang smooth.\r\nexport function shootRaysInCircle(start: Coord, floor: Floor) {\r\n    const points: Coord[] = [];\r\n    let angle = 0;\r\n    while (angle < Math.PI * 2) {\r\n        points.push(shootRay(start, {\r\n            x: Math.cos(angle) * rayStep,\r\n            y: Math.sin(angle) * rayStep,\r\n        }, floor));\r\n        angle += angleSize;\r\n    }\r\n    return points;\r\n}\r\n\r\nexport function toScreenSpot(c: Coord): Coord {\r\n    return {\r\n        x: c.x - centerX + (.5 * window.innerWidth),\r\n        y: c.y - centerY + (.5 * window.innerHeight),\r\n    }\r\n}\r\n\r\nexport function UpdateFog(player: Item, floor: Floor) {\r\n\r\n    if (!ctx) {\r\n        fog = document.getElementById(\"fog\") as HTMLCanvasElement;\r\n        if (!fog) { return; }\r\n        fog.width = window.innerWidth;\r\n        fog.height = window.innerHeight;\r\n\r\n        ctx = fog.getContext(\"2d\")!;\r\n        if (!ctx) { return; }\r\n    }\r\n\r\n    //fog.style.opacity = \".5\";\r\n    ctx.clearRect(0, 0, fog.width, fog.height);\r\n\r\n    const rayPoints = shootRaysInCircle(player.position, floor);\r\n\r\n    ctx.fillStyle = \"lightyellow\";\r\n    ctx.strokeStyle = \"1px lightyellow\";\r\n    ctx.beginPath();\r\n    const playerCoord = toScreenSpot(player.position);\r\n    ctx.moveTo(playerCoord.x, playerCoord.y);\r\n    rayPoints.forEach(point => {\r\n        const p = toScreenSpot(point);\r\n        ctx.lineTo(p.x, p.y);\r\n    });\r\n    const p = toScreenSpot(rayPoints[0]);\r\n    ctx.lineTo(p.x, p.y);\r\n    ctx.stroke();\r\n    ctx.fill();\r\n\r\n    // draw LINES to the wall edge. E.G.\r\n    // we need the player spot and the WALL corners.\r\n\r\n}\r\n\r\nfunction sourceInTest() {\r\n    // TEST ONLY\r\n\r\n    /*\r\n    This would be  the HTML to add in the app:\r\n     <canvas id=\"canvas_map\"\r\n              width={window.innerWidth}\r\n              height={window.innerHeight}\r\n              style={canvasStyle} />\r\n              <canvas id=\"canvas_sightlines\"\r\n                 width={window.innerWidth}\r\n                 height={window.innerHeight}\r\n                 style={canvasStyle} />\r\n                 <canvas id=\"canvas_result\"\r\n                    width={window.innerWidth}\r\n                    height={window.innerHeight}\r\n                    style={canvasStyle} />\r\n    */\r\n    const sightCv = document.getElementById(\"canvas_sightlines\") as HTMLCanvasElement;\r\n    const mapCv = document.getElementById(\"canvas_map\") as HTMLCanvasElement;\r\n    const resultCv = document.getElementById(\"canvas_result\") as HTMLCanvasElement;\r\n\r\n    if (!sightCv) { return; }\r\n\r\n    const sight_ctx = sightCv.getContext(\"2d\")!;\r\n    const map_ctx = mapCv.getContext(\"2d\")!;\r\n    const result_ctx = resultCv.getContext(\"2d\")!;\r\n\r\n    // draw a \"map tile\"\r\n    map_ctx.fillStyle = \"grey\";\r\n    map_ctx.fillRect(window.innerWidth / 2 - 200, window.innerHeight / 2 - 200, 400, 400);\r\n    map_ctx.fillStyle = \"#442222\";\r\n    map_ctx.fillRect(window.innerWidth / 2 - 150, window.innerHeight / 2 - 150, 300, 300);\r\n\r\n    // draw the \"sight line\"\r\n\r\n    sight_ctx.fillStyle = \"yellow\";\r\n    sight_ctx.strokeStyle = \"1px solid yellow\";\r\n    sight_ctx.beginPath();\r\n    sight_ctx.moveTo(window.innerWidth / 2, window.innerHeight / 2);\r\n    sight_ctx.lineTo(200, 200);\r\n    sight_ctx.fill();\r\n    sight_ctx.lineTo(200, 400);\r\n    sight_ctx.fill();\r\n    sight_ctx.lineTo(window.innerWidth / 2, window.innerHeight / 2);\r\n    sight_ctx.arc(window.innerWidth / 2, window.innerHeight / 2, 100, 0, Math.PI * 2)\r\n    sight_ctx.fill();\r\n    sight_ctx.stroke();\r\n    //sight_ctx.fillRect(window.innerWidth / 2-100, window.innerHeight / 2-100, 200,200);\r\n\r\n    // create the result\r\n    result_ctx.drawImage(sightCv, 0, 0);\r\n    result_ctx.globalCompositeOperation = \"source-in\";\r\n    result_ctx.drawImage(mapCv, 0, 0);\r\n\r\n    // hide the other canvases\r\n\r\n    sightCv.style.display = \"none\";\r\n    mapCv.style.display = \"none\";\r\n\r\n\r\n    // END TEST\r\n}","import React from 'react';\r\nimport { GridItem, Item, Player } from \"./tiles/Items\";\r\nimport kid_green from \"./images/players/kid_green.png\";\r\n\r\nexport const player: Player = {\r\n  // item stuff\r\n  position: { x: 0, y: 0 },\r\n  height: 50,\r\n  width: 25,\r\n  color: \"red\",\r\n  name: \"You\",\r\n  velocity: { x: 0, y: 0 },\r\n  mass: 140,\r\n  image: kid_green,\r\n  \r\n  //player stuff\r\n  fear: 0,\r\n  health: 100,\r\n  intelligence: 5,\r\n  speed: 2,\r\n  inventory: [],\r\n  spirit: 2,\r\n  strength: 5,\r\n  \r\n};\r\n\r\nexport const playerZindex = 51;\r\n\r\nexport function GridPlayer() {\r\n  return <GridItem item={player} zIndex={playerZindex} />\r\n}\r\n","import * as React from 'react';\r\nimport { Coord } from './Coord';\r\nimport { GridItem, Item, Player } from \"./Items\";\r\nimport { toScreenSpot } from './SightLines';\r\n\r\nvar interactables: Item[] = [];\r\n\r\nexport function SetInteractables(items: Item[]) {\r\n    interactables = items;\r\n}\r\n\r\nexport function Add(a: Coord, b: Coord) {\r\n    return {\r\n        x: a.x + b.x,\r\n        y: a.y + b.y,\r\n    };\r\n}\r\n\r\nexport function toScreenPositionStyle(c: Coord): React.CSSProperties {\r\n    const spot = toScreenSpot(c);\r\n    return {\r\n        top: spot.y,\r\n        left: spot.x,\r\n        position: \"absolute\",\r\n    }\r\n}\r\n\r\nexport const MenuStyle: React.CSSProperties = {\r\n    position: \"absolute\",\r\n    border: \"2px solid white\",\r\n    backgroundColor: \"#442211\",\r\n    padding: 5,\r\n    color: \"white\",\r\n}\r\n\r\nexport function InteractionButtons({ item, player, inInventory = false, onGround = false }:\r\n    { item: Item, player: Player, inInventory?: boolean, onGround?: boolean }) {\r\n    return <>\r\n        <div>{item.name}</div>\r\n        {item.playerInteractions\r\n            ?.filter(interaction =>\r\n                (interaction.canDoInInventory || !inInventory)\r\n                && (interaction.canDoOnGround || !onGround))\r\n            ?.map(interaction =>\r\n                <button\r\n                    style={{ cursor: \"pointer\" }}\r\n                    onClick={() => interaction.action(player, item)}>\r\n                    {interaction.name}\r\n                </button>)}\r\n    </>;\r\n}\r\n\r\n// want it like.. by the player?\r\nexport function Interactions(props: { player: Player }) {\r\n    const { player } = props;\r\n    if (interactables.length <= 0) { return null; }\r\n\r\n\r\n    return <>\r\n        {interactables.map(item =>\r\n            <div style={{\r\n                ...MenuStyle,\r\n                zIndex: 100,\r\n                ...toScreenPositionStyle(Add(\r\n                    item.position,\r\n                    { x: .5 * item.width + 5, y: .5 * item.height + 5 }\r\n                )),\r\n                textAlign: \"center\",\r\n                display: \"flex\",\r\n                flexDirection: \"column\",\r\n            }}>\r\n                <InteractionButtons item={item} player={player} onGround={true} />\r\n            </div>\r\n        )}\r\n    </>\r\n}","import * as React from 'react';\r\nimport { InteractionButtons, MenuStyle } from './Interaction';\r\nimport { Player } from \"./Items\";\r\n\r\n// want it like.. by the player?\r\nexport function Inventory(props: { player: Player }) {\r\n    const { player } = props;\r\n    const inventory = player.inventory;\r\n\r\n    if (inventory.length <= 0) { return null; }\r\n    return <div style={{\r\n        ...MenuStyle,\r\n        zIndex: 75,\r\n        bottom: 20,\r\n        left: 20,\r\n\r\n    }}>\r\n        <div style={{\r\n            display: \"flex\",\r\n            flexDirection: \"row\",\r\n            alignItems: \"stretch\",\r\n        }}>\r\n            {inventory.map(item =>\r\n                <div style={{\r\n                    padding: 10,\r\n                    textAlign: \"center\",\r\n                    display: \"flex\",\r\n                    flexDirection: \"column\",\r\n                    alignItems: \"center\",\r\n                    justifyContent: \"flex-end\",\r\n                }}>\r\n                    {item.image\r\n                        ? <img\r\n                            src={item.image}\r\n                            style={{\r\n                                cursor: \"pointer\",\r\n                                maxWidth: 50,\r\n                                maxHeight: 50\r\n                            }}\r\n                        />\r\n                        : <div style={{\r\n                            cursor: \"pointer\",\r\n                            backgroundColor: item.color,\r\n                            width: item.width,\r\n                            height: item.height\r\n                        }}></div>}\r\n\r\n                    <div style={{ display: \"flex\", flexDirection: \"column\" }}>\r\n                        <InteractionButtons item={item} player={player} inInventory={true} />\r\n                    </div>\r\n                </div>\r\n            )}\r\n        </div>\r\n    </div>\r\n}","import React from 'react';\nimport './App.css';\nimport { GridTile } from './GridTile';\nimport { ApplyFriction, CollideItems, CollideWithWalls, GetItemsInInteractionDistance, GetTileCoord, MoveItems } from './tiles/Collision';\nimport { FirstFloor, Index } from './tiles/Floor';\nimport { sightDistance, UpdateFog } from './tiles/SightLines';\nimport { GridPlayer, player } from './Player';\nimport { GetItems, GridItem, Item } from './tiles/Items';\nimport { Interactions, SetInteractables } from './tiles/Interaction';\nimport { Inventory } from './tiles/Inventory';\n\nexport let centerX = 0;\nexport let centerY = 0;\n\nexport var RenderApp = () => { };\n\nvar showMap = false;\nvar showFog = true; // turn off for now.. Sightlines would be cool, but circle looks dumb.\nconst canvasStyle: React.CSSProperties = {\n  position: \"absolute\",\n  zIndex: 5,\n  width: \"100%\",\n  height: \"100%\",\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n};\n\nfunction App() {\n  const [, setState] = React.useState(0);\n  const rerender = React.useCallback(() => {\n    setState(Math.random());\n  }, [setState]);\n\n  React.useEffect(() => { RenderApp = rerender; }, [rerender]);\n\n  return (\n    <div className=\"App\" style={{ overflow: \"hidden\" }}>\n      {showMap ?\n        <div style={{ zIndex: 100, bottom: 0, padding: 20, position: \"absolute\", left: 0, right: 0 }}>\n          <div style={{ color: \"white\" }}>Map</div>\n          <button onClick={() => { centerY -= 100; rerender(); }}>UP!</button>\n          <button onClick={() => { centerY += 100; rerender(); }}>DOWN!</button>\n          <button onClick={() => { centerX -= 100; rerender(); }}>LEFT!</button>\n          <button onClick={() => { centerX += 100; rerender(); }}>RIGHT!</button>\n          <button onClick={() => { centerX = 0; centerY = 0; rerender(); }}>CENTER!</button>\n        </div> : null}\n      <GridPlayer />\n\n      <div>\n\n        {showFog ? <canvas id=\"fog\"\n          width={window.innerWidth}\n          height={window.innerHeight}\n          style={{\n            ...canvasStyle,\n            opacity: .2,\n            //mixBlendMode: \"multiply\",\n            filter: \"blur(5px)\",\n          }} /> : null}\n\n        <div id=\"gamefloor\" style={{ mixBlendMode: \"normal\" }}>\n\n          {FirstFloor.tiles.map((tile) => <GridTile\n            overlayMode={showMap}\n            floor={FirstFloor}\n            tile={tile}\n            key={Index(tile.x, tile.y)}\n          />)}\n\n          {GetItems().map((item) => <GridItem item={item} />)}\n\n        </div>\n      </div>\n\n      <Interactions player={player} />\n      <Inventory player={player} />\n\n    </div>\n  );\n}\n\nlet leftPressed = false;\nlet upPressed = false;\nlet rightPressed = false;\nlet downPressed = false;\n\nlet mPressed = false;\n\ndocument.addEventListener('keydown', e => {\n  if (e.key === \"m\" || e.key === \"M\") {\n    if (!mPressed) { showMap = !showMap; }\n    mPressed = true;\n  }\n\n  if (e.key === \"a\" || e.key === \"A\" || e.key === \"ArrowLeft\") {\n    leftPressed = true;\n    rightPressed = false;\n  }\n  if (e.key === \"d\" || e.key === \"D\" || e.key === \"ArrowRight\") {\n    rightPressed = true;\n    leftPressed = false;\n  }\n  if (e.key === \"w\" || e.key === \"W\" || e.key === \"ArrowUp\") {\n    upPressed = true;\n    downPressed = false;\n  }\n  if (e.key === \"s\" || e.key === \"S\" || e.key === \"ArrowDown\") {\n    downPressed = true;\n    upPressed = false;\n  }\n});\n\ndocument.addEventListener('keyup', e => {\n  //console.log(e.key);\n  if (e.key === \"a\" || e.key === \"A\" || e.key === \"ArrowLeft\") {\n    leftPressed = false;\n  }\n  if (e.key === \"d\" || e.key === \"D\" || e.key === \"ArrowRight\") {\n    rightPressed = false;\n  }\n  if (e.key === \"w\" || e.key === \"W\" || e.key === \"ArrowUp\") {\n    upPressed = false;\n  }\n  if (e.key === \"s\" || e.key === \"S\" || e.key === \"ArrowDown\") {\n    downPressed = false;\n  }\n  if (e.key === \"m\" || e.key === \"M\") {\n    mPressed = false;\n  }\n});\n\nconst moveSpeed = 2;\nconst playerAccel = .3;\nconst mapSpeed = 7;\n\nfunction animate() {\n  if (showMap) {\n    if (leftPressed) {\n      centerX -= mapSpeed;\n    }\n    if (rightPressed) {\n      centerX += mapSpeed;\n    }\n    if (upPressed) {\n      centerY -= mapSpeed;\n    }\n    if (downPressed) {\n      centerY += mapSpeed;\n    }\n  }\n  else {\n    player.velocity = player.velocity || { x: 0, y: 0 };\n    if (leftPressed && player.velocity.x > -moveSpeed) {\n      //player.position.x -= moveSpeed;\n      player.velocity.x -= playerAccel;\n      player.imageTransform = undefined;\n    }\n    if (rightPressed && player.velocity.x < moveSpeed) {\n      //player.position.x += moveSpeed;\n      player.velocity.x += playerAccel;\n      player.imageTransform = \"scale(-1,1)\";\n    }\n    if (upPressed && player.velocity.y > -moveSpeed) {\n      //player.position.y -= moveSpeed;\n      player.velocity.y -= playerAccel;\n    }\n    if (downPressed && player.velocity.y < moveSpeed) {\n      //player.position.y += moveSpeed;\n      player.velocity.y += playerAccel;\n    }\n  }\n\n  // for now we are assuming the player is ALWAYS centered. \n  // This is probably bad and we may want to change it when we switch to a canvas based approach.\n  MoveItems([player]);\n  CollideWithWalls(player, FirstFloor, true);\n  //GetItems().forEach(item => CollideWithWalls(item, FirstFloor));\n  //CollideItems([player]);\n  ApplyFriction([player]);\n\n  // TODO: don't check for interaction distance EVERY frame, this is totaly overkill\n  const roomItems = FirstFloor.getCoord(GetTileCoord(player.position))?.info.items?.filter(item => !item.hidden);\n  SetInteractables(\n    GetItemsInInteractionDistance(\n      player,\n      [\n        ...GetItems(),\n        ...(roomItems || []) // YO! This doesn't handle the tile offset... these are all RELATIVE. maybe we should CHANGE that. the relative thing is really tough.\n      ]\n    )\n  );\n\n  // FOLLOW CAM\n  if (!showMap) {\n    centerX = player.position.x;\n    centerY = player.position.y;\n  }\n\n  //TODO: later. \n  showFog && UpdateFog(player, FirstFloor);\n  RenderApp();\n  requestAnimationFrame(() => animate());\n}\n\nanimate();\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker === null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}