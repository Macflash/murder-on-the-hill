{"version":3,"sources":["images/rooms/BAD_COPIES/dining_room.jpg","images/rooms/BAD_COPIES/kitchen.jpg","images/rooms/BAD_COPIES/storeroom.jpg","images/rooms/BAD_COPIES/patio.jpg","images/rooms/BAD_COPIES/entrance.jpg","images/players/kid_green.png","game/coordinates/Coord.ts","game/hud/SightLines.ts","game/tiles/Size.ts","game/items/Interaction.ts","game/items/Items.tsx","game/items/Collision.ts","game/tiles/GridTile.tsx","game/coordinates/Direction.ts","game/tiles/Tile.ts","game/tiles/Rooms.ts","game/items/Stats.ts","game/items/Monsters.ts","game/tiles/Floor.ts","game/items/Player.tsx","game/hud/MenuStyle.tsx","game/hud/Hud_Interaction.tsx","game/hud/Inventory.tsx","game/hud/Hud_Stats.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","MoveCoord","c","direction","x","y","Add","a","b","Subtract","Multiply","MakeUnitVector","Divide","Math","sqrt","pow","Magnitude","Distance","viewDist","screenSize","max","window","innerWidth","innerHeight","ceil","GetTileViewDist","rayLength","console","log","addEventListener","angleSize","PI","shootRay","start","stepVector","floor","length","ray","CollideWithWalls","position","height","width","velocity","toScreenSpot","centerX","centerY","UpdateFogCanvas","ctx","player","clearRect","rayPoints","points","angle","push","cos","sin","shootRaysInCircle","ps","gradient","createRadialGradient","addColorStop","fillStyle","strokeStyle","beginPath","playerCoord","moveTo","forEach","point","p","lineTo","stroke","fill","PickUpItem","name","canDoOnGround","canDoInInventory","action","item","hidden","Error","inventory","DropItem","splice","indexOf","DisplayItemInfo","alert","description","CantDropItem","Map","ToBoundingBox","RectangleCollision","rect1","rect2","items","GetItems","filter","GridItem","props","tileOffset","center","zIndex","hW","hH","title","style","backgroundColor","image","undefined","color","left","top","src","transform","imageTransform","curesedKnife","mass","playerInteractions","watch","purse","random","CopyItem","GetTileCoord","GetRoomCoord","tileCoord","createOnDoor","hT","hD","hDX","hDY","roomX","roomY","leftWall","rightWall","topWall","bottomWall","tile","getCoord","collisionTrue","hasDoor","hasDoorAndOpenIfNeeded_New","abs","doors","has","HasDoor","coord","newCoord","hasCoord","fillCoord","CreateRoomIfNeeded","UnmoveableCollision","moveable","unmoveable","overlapX","overlapY","max_objects_collided","tileViewDist","GridTile","overlayMode","RenderApp","cameraCoord","display","justifyContent","alignItems","info","map","d","opened","hasNeighbor","getWallPosition","size","bottom","right","GridWall","row","filler","flex","flexDirection","overflow","cursor","onClick","Tile","initialDoors","rotation","imageEl_","this","Set","neededDoors","neededWalls","canPlace","r","t","rotate","topCorner","GetTileTopAndLeft","fillRect","tileSize","rotatedDoors","door","add","allDirections","index","Rotate","document","createElement","Kitchen","kitchen","Patio","patio","Storeroom","storeroom","DiningRoom","dining_room","Entrance","entrance","FourWay","blockObjects","TeeWay","Straight","LTurn","RTurn","DeadEnd","AllWay","copy","TwoWay","TileLibrary","createCanvas","id","canvas","getContext","resultCanvas","resultCtx","tileCanvas","tileCtx","sightCanvas","sightCtx","DoSightLineThing","tiles","drawToCanvas","DrawAllRooms","DrawSightCanvas","getElementById","save","globalCompositeOperation","restore","drawImage","DrawResult","body","append","PlayerStats","str","dex","int","spt","allowBeingSuperAmazing","holder","set","stat","get","n","sum","i","N2Gaussish","buff","damage","monsters","GetMonsters","maybeMonster","decide_move","BasicMonster","attackType","stats","players","closest","closestDistance","Number","MAX_VALUE","dist","getClosestPlayer","Index","FirstFloor","grid","getTile","hasTile","setTile","tileCenter","AddItem","fillTile","neighbor","Opposite","matchingTiles","newTile","Array","from","monster","kid_green","GridPlayer","MenuStyle","border","padding","interactables","toScreenPositionStyle","spot","InteractionButtons","inInventory","onGround","interaction","Interactions","textAlign","Inventory","maxWidth","maxHeight","HudStats","StatRow","statType","num","showMap","canvasStyle","leftPressed","upPressed","rightPressed","downPressed","mPressed","e","key","animate","attackingPlayer","checkForAttack","playerRoll","roll","monsterRoll","ApplyFriction","roomItems","SetInteractables","j","item_unmoveable","other_unmoveable","CollideItems","requestAnimationFrame","setInterval","App","React","useState","setState","rerender","useCallback","useEffect","className","mixBlendMode","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.3da4234e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/dining_room.726d2984.jpg\";","module.exports = __webpack_public_path__ + \"static/media/kitchen.46ae08a3.jpg\";","module.exports = __webpack_public_path__ + \"static/media/storeroom.b622b705.jpg\";","module.exports = __webpack_public_path__ + \"static/media/patio.1d7a8cf4.jpg\";","module.exports = __webpack_public_path__ + \"static/media/entrance.b171268f.jpg\";","module.exports = \"data:image/png;base64,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\"","import { Direction } from './Direction';\r\n\r\nexport interface Coord {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport function MoveCoord(c: Coord, direction: Direction): Coord {\r\n  const { x, y } = c;\r\n  // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return { x, y: y - 1 };\r\n    case \"BOTTOM\":\r\n      return { x, y: y + 1 };\r\n    case \"RIGHT\":\r\n      return { x: x + 1, y };\r\n    case \"LEFT\":\r\n      return { x: x - 1, y };\r\n  }\r\n}\r\n\r\nexport function MidPoint(a: Coord, b: Coord) {\r\n  return {\r\n    x: (a.x + b.x) / 2,\r\n    y: (a.y + b.y) / 2,\r\n  };\r\n}\r\n\r\n// Basic vector ops\r\nexport function Copy(a: Coord) {\r\n  return {\r\n    x: (a.x),\r\n    y: (a.y),\r\n  };\r\n}\r\n\r\nexport function Add(a: Coord, b: Coord) {\r\n  return {\r\n    x: (a.x + b.x),\r\n    y: (a.y + b.y),\r\n  };\r\n}\r\n\r\nexport function Subtract(a: Coord, b: Coord) {\r\n  return {\r\n    x: (a.x - b.x),\r\n    y: (a.y - b.y),\r\n  };\r\n}\r\n\r\nexport function Multiply(a: Coord, b: number) {\r\n  return {\r\n    x: (a.x * b),\r\n    y: (a.y * b),\r\n  };\r\n}\r\n\r\nexport function Divide(a: Coord, b: number) {\r\n  return {\r\n    x: (a.x / b),\r\n    y: (a.y / b),\r\n  };\r\n}\r\n\r\n// Vector direction and scaling ops\r\nexport function Magnitude(a: Coord) {\r\n  return Math.sqrt(Math.pow(a.x, 2) + Math.pow(a.y, 2));\r\n}\r\n\r\nexport function MakeUnitVector(a: Coord) {\r\n  return Divide(a, Magnitude(a));\r\n}\r\n\r\n// Distances ordered by their stupidness\r\nexport function Distance(a: Coord, b: Coord) {\r\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\r\n}\r\n\r\nexport function HammingDistance(a: Coord, b: Coord) {\r\n  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n}\r\n\r\nexport function EitherDirectionDistance(a: Coord, b: Coord) {\r\n  return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\r\n}","import { centerX, centerY } from \"../../App\";\r\nimport { tileSize, wallSize } from \"../tiles/Size\";\r\nimport { CollideWithWalls } from \"../items/Collision\";\r\nimport { Coord } from \"../coordinates/Coord\";\r\nimport { Floor } from \"../tiles/Floor\";\r\nimport { Item } from \"../items/Items\";\r\n\r\n// As long as we factor in their size as well...\r\nexport const sightDistance = 400;\r\nfunction GetTileViewDist(){\r\n    var screenSize = Math.max(window.innerWidth, window.innerHeight);\r\n    return Math.ceil(screenSize / (2 * tileSize));\r\n}\r\n\r\nvar viewDist = GetTileViewDist();\r\n\r\n/** Returns where this hits a wall! */\r\nconst rayStep = wallSize;\r\nvar rayLength = 10 + viewDist * tileSize / rayStep; //was like 75 or 100;\r\nconsole.log(\"ray length\", rayLength);\r\nwindow.addEventListener('resize', () => {\r\n    rayLength = 10 + viewDist * tileSize / rayStep;\r\n    console.log(\"ray length\", rayLength);\r\n});\r\n// 20 is ok, 60 is good, 120 is REAL fine. 200 cant really tell the difference.\r\nconst angleSize = Math.PI / 100;\r\n\r\n// dude you could probably just CALCULATE (DO the math bro! it's faster) the next time the ray would = .5 tilesize  % tilesize\r\nexport function shootRay(start: Coord, stepVector: Coord, floor: Floor): Coord {\r\n    // assume vector is the RIGHT length\r\n    let length = 0;\r\n    let ray = { x: start.x, y: start.y };\r\n    while (!CollideWithWalls({ position: ray, height: 1, width: 1, velocity: { x: 0, y: 0 } } as Item, floor)\r\n        && length < rayLength) {\r\n        ray.x += stepVector.x;\r\n        ray.y += stepVector.y;\r\n        length++;\r\n    }\r\n\r\n    return ray;\r\n}\r\n// PI/10 is clunky, PI/20 is pretty dang smooth.\r\nexport function shootRaysInCircle(start: Coord, floor: Floor) {\r\n    const points: Coord[] = [];\r\n    let angle = 0;\r\n    while (angle < Math.PI * 2) {\r\n        points.push(shootRay(start, {\r\n            x: Math.cos(angle) * rayStep,\r\n            y: Math.sin(angle) * rayStep,\r\n        }, floor));\r\n        angle += angleSize;\r\n    }\r\n    return points;\r\n}\r\n\r\nexport function toScreenSpot(c: Coord): Coord {\r\n    return {\r\n        x: c.x - centerX + (.5 * window.innerWidth),\r\n        y: c.y - centerY + (.5 * window.innerHeight),\r\n    }\r\n}\r\n\r\nexport function UpdateFogCanvas(ctx: CanvasRenderingContext2D, player: Item, floor: Floor) {\r\n    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n\r\n    const rayPoints = shootRaysInCircle(player.position, floor);\r\n    const ps = toScreenSpot(player.position);\r\n    const gradient = ctx.createRadialGradient(ps.x, ps.y,70, ps.x, ps.y, viewDist * tileSize);\r\n    gradient.addColorStop(0, \"lightyellow\");\r\n    gradient.addColorStop(.07, \"rgba(255,255,0,1)\");\r\n    gradient.addColorStop(.2, \"rgba(255,255,0,.8)\");\r\n    gradient.addColorStop(1, \"rgba(255,128,0,0)\");\r\n\r\n    ctx.fillStyle = gradient; // \"lightyellow\";\r\n    ctx.strokeStyle = \"1px lightyellow\";\r\n    ctx.beginPath();\r\n    const playerCoord = toScreenSpot(player.position);\r\n    ctx.moveTo(playerCoord.x, playerCoord.y);\r\n    rayPoints.forEach(point => {\r\n        const p = toScreenSpot(point);\r\n        ctx.lineTo(p.x, p.y);\r\n    });\r\n    const p = toScreenSpot(rayPoints[0]);\r\n    ctx.lineTo(p.x, p.y);\r\n    ctx.stroke();\r\n    ctx.fill();\r\n}","export const tileSize = 400;\r\nexport const wallSize = 12;\r\nexport const doorSize = 100;","import { Copy } from \"../coordinates/Coord\";\r\nimport { Item } from \"./Items\";\r\nimport { Player } from \"./Player\";\r\n\r\nexport interface PlayerItemInteraction {\r\n    name: string,\r\n    canDoOnGround: boolean,\r\n    canDoInInventory: boolean,\r\n    action: PlayerItemInteraction_Action,\r\n}\r\n\r\nexport const PickUpItem: PlayerItemInteraction = {\r\n    name: \"Pick up\",\r\n    canDoOnGround: true,\r\n    canDoInInventory: false,\r\n    action: (player, item) => {\r\n        if (item.hidden) {\r\n            throw new Error(\"Cant pick up a hidden item!!!\");\r\n        }\r\n        player.inventory.push(item);\r\n        item.hidden = true;\r\n    }\r\n}\r\n\r\nexport const DropItem: PlayerItemInteraction = {\r\n    name: \"Drop\",\r\n    canDoOnGround: false,\r\n    canDoInInventory: true,\r\n    action: (player, item) => {\r\n        if (!item.hidden) {\r\n            throw new Error(\"Cant drop up a visible item!!!\");\r\n        }\r\n\r\n        item.position = Copy(player.position);\r\n        player.inventory.splice(player.inventory.indexOf(item), 1);\r\n        item.hidden = false;\r\n    }\r\n}\r\n\r\nexport const DisplayItemInfo: PlayerItemInteraction = {\r\n    name: \"Info\",\r\n    canDoOnGround: true,\r\n    canDoInInventory: true,\r\n    action: (player, item) => {\r\n        alert(item.description);\r\n    }\r\n}\r\n\r\nexport const CantDropItem: PlayerItemInteraction = {\r\n    name: \"Try to drop\",\r\n    canDoOnGround: false,\r\n    canDoInInventory: true,\r\n    action: (player, item) => {\r\n        alert(\"You can't put it down, it's as if it was part of you now.\");\r\n    }\r\n}\r\n\r\nexport type PlayerItemInteraction_Action = (player: Player, item: Item) => void;\r\n","import * as React from 'react';\r\nimport { Add, Coord, Subtract } from \"../coordinates/Coord\";\r\nimport { toScreenSpot } from '../hud/SightLines';\r\nimport { PlayerItemInteraction, PickUpItem, DisplayItemInfo, CantDropItem, DropItem } from './Interaction';\r\n\r\nexport interface Item {\r\n    position: Coord;\r\n    height: number;\r\n    width: number;\r\n\r\n    name?: string;\r\n    description?: string;\r\n    color?: string; // TODO this should be an image or graphic or canvas dude!\r\n\r\n    /** Whether the item can be moved by being collided with */\r\n    moveable?: boolean; // this could probably be signaled by undefined VELOCITY? idk.. w/e\r\n\r\n    /** Whether player/other items can go through the item */\r\n    blockObjects?: boolean;\r\n\r\n    mass: number;\r\n    velocity: Coord;\r\n    image?: string;\r\n    imageTransform?: string;\r\n\r\n    hidden?: boolean;\r\n\r\n    playerInteractions?: PlayerItemInteraction[];\r\n}\r\n\r\nvar drawnImages = new Map<string, HTMLImageElement>();\r\n\r\nexport function DrawItemToCtx(item: Item, ctx: CanvasRenderingContext2D) {\r\n    const box = ToBoundingBox(item);\r\n    const screenC = toScreenSpot(box); // weird cast but ok duck typing do your thing\r\n    if (item.image) {\r\n        let imageEL = drawnImages.get(item.image);\r\n        if (!imageEL) {\r\n            imageEL = document.createElement(\"img\") as HTMLImageElement;\r\n            imageEL.src = item.image;\r\n            drawnImages.set(item.image, imageEL);\r\n        }\r\n        ctx.drawImage(imageEL, screenC.x, screenC.y);\r\n    }\r\n    else {\r\n        ctx.fillStyle = item.color || \"grey\"; // grey..ish?\r\n        ctx.fillRect(screenC.x, screenC.y, box.width, box.height);\r\n    }\r\n}\r\n\r\nexport function ToBoundingBox(item: Item) {\r\n    return {\r\n        x: item.position.x - item.width * .5,\r\n        y: item.position.y - item.height * .5,\r\n        height: item.height,\r\n        width: item.width,\r\n    };\r\n}\r\n\r\n/* Check two items for collision! */\r\nexport function RectangleCollision(a: Item, b: Item) {\r\n    const rect1 = ToBoundingBox(a);\r\n    const rect2 = ToBoundingBox(b);\r\n    return rect1.x < rect2.x + rect2.width &&\r\n        rect1.x + rect1.width > rect2.x &&\r\n        rect1.y < rect2.y + rect2.height &&\r\n        rect1.y + rect1.height > rect2.y;\r\n}\r\n\r\nvar items: Item[] = [];\r\n\r\n// yo if we stored these BY room it would be pretty cool.\r\nexport function AddItem(item: Item) {\r\n    items.push(item);\r\n}\r\n\r\nexport function GetItems() {\r\n    return items.filter(item => !item.hidden);\r\n}\r\n\r\nexport const itemZindex = 50;\r\n\r\nexport function GridItem(props: { item: Item, zIndex?: number, tileOffset?: Coord, center: Coord }) {\r\n    const { item, tileOffset, center, zIndex } = props;\r\n    const hW = item.width * .5;\r\n    const hH = item.height * .5;\r\n\r\n    return <div\r\n        title={item.name}\r\n        style={{\r\n            position: \"absolute\",\r\n            zIndex: zIndex || itemZindex,\r\n            height: item.height,\r\n            width: item.width,\r\n            backgroundColor: item.image ? undefined : item.color || \"grey\",\r\n            left: item.position.x - center.x + (.5 * window.innerWidth) - hW - (tileOffset?.x || 0),\r\n            top: item.position.y - center.y + (.5 * window.innerHeight) - hH - (tileOffset?.y || 0),\r\n        }}>\r\n        {item.image ? <img src={item.image} style={{ transform: item.imageTransform }} /> : null}\r\n    </div>;\r\n}\r\n\r\nconst imageEls = new Map<string, HTMLImageElement>();\r\nexport function GetImageElement(image: string): HTMLImageElement {\r\n    if (imageEls.has(image)) { return imageEls.get(image)!; }\r\n    const newImage = document.createElement(\"img\");\r\n    newImage.src = image;\r\n    imageEls.set(image, newImage);\r\n    return newImage;\r\n}\r\n\r\nexport function DrawItemToCanvas(ctx: CanvasRenderingContext2D, item: Item, center: Coord) {\r\n    const screenSpace = Subtract(ToBoundingBox(item), center); // removes the width and height to get the top left corner, and then subtracts the screen centerto get the canvas coordinates\r\n    if (item.image) {\r\n        console.log(\"drawing image\");\r\n        // TODO: This doesnt handle ROTATION like at all.\r\n        ctx.drawImage(\r\n            GetImageElement(item.image),\r\n            screenSpace.x,\r\n            screenSpace.y);\r\n    }\r\n    else {\r\n        console.log(`item ${screenSpace.x},${screenSpace.y}`);\r\n        ctx.fillStyle = item.color || \"green\"; // zombie..ish?\r\n        ctx.fillRect(screenSpace.x, screenSpace.y, item.width, item.height);\r\n    }\r\n}\r\n\r\nexport const curesedKnife: Item = {\r\n    position: { x: 0, y: 30 },\r\n    height: 5,\r\n    width: 20,\r\n    color: \"red\",\r\n    name: \"Wicked Knife\",\r\n    mass: 5,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A sickening looking knife. You can't tell if that is blood or rust on the blade. Yet you feel oddly... compelled to pick it up.\",\r\n    playerInteractions: [PickUpItem, DisplayItemInfo, CantDropItem],\r\n};\r\n\r\nexport const watch: Item = {\r\n    position: { x: 150, y: 180 },\r\n    height: 15,\r\n    width: 20,\r\n    color: \"green\",\r\n    name: \"Purse\",\r\n    mass: 4,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A fancy purse. It looks old, who could have left it here?\",\r\n    playerInteractions: [PickUpItem, DisplayItemInfo, DropItem],\r\n};\r\n\r\nexport const box: Item = {\r\n    position: { x: 0, y: 40 },\r\n    height: 20,\r\n    width: 20,\r\n    color: \"brown\",\r\n    name: \"Box\",\r\n    mass: 15,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A closed cardboard box. It feels heavy. What could be inside?\",\r\n    playerInteractions: [PickUpItem, DisplayItemInfo, DropItem],\r\n};\r\n\r\n\r\nexport const purse: Item = {\r\n    position: { x: (Math.random() - .5) * 300, y: 150 },\r\n    height: 10,\r\n    width: 10,\r\n    color: \"gold\",\r\n    name: \"Watch\",\r\n    mass: .5,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A small, worn pocketwatch. It looks like it is made of gold, but the time is stuck at midnight. What could happen if you wind it?\",\r\n    playerInteractions: [PickUpItem, DisplayItemInfo, DropItem],\r\n};\r\n\r\nexport const table: Item = {\r\n    position: { x: -70, y: -150 },\r\n    height: 70,\r\n    width: 40,\r\n    color: \"tan\",\r\n    name: \"Table\",\r\n    blockObjects: true,\r\n    mass: 70,\r\n    velocity: { x: 0, y: 0 },\r\n};\r\n\r\nexport function CopyItem(item: Item) {\r\n    return {\r\n        ...item,\r\n        position: { ...item.position },\r\n        velocity: { ...item.velocity },\r\n    }\r\n}\r\n// */","\r\n// ok how can we do... intersections and interactions?\r\n// #1 only can hit things in your room (or very rarely a neighboring room that is close by..)\r\n\r\nimport { Coord, Distance, MoveCoord } from \"../coordinates/Coord\";\r\nimport { Direction } from \"../coordinates/Direction\";\r\nimport { Floor } from \"../tiles/Floor\";\r\nimport { GetItems, Item, RectangleCollision } from \"./Items\";\r\nimport { doorSize, wallSize, tileSize } from \"../tiles/Size\";\r\nimport { Tile } from \"../tiles/Tile\";\r\n\r\n/** The TILE the item is in. */\r\nexport function GetTileCoord(c: Coord): Coord {\r\n    const hT = .5 * tileSize;\r\n    const x = Math.floor((c.x + hT) / tileSize);\r\n    const y = Math.floor((c.y + hT) / tileSize);\r\n    return { x, y };\r\n}\r\n\r\n/** The relative place in the current TILE the item is in. */\r\nexport function GetRoomCoord(item: Item, tileCoord: Coord): Coord {\r\n    const x = item.position.x - (tileCoord.x * tileSize);\r\n    const y = item.position.y - (tileCoord.y * tileSize);\r\n    return { x, y };\r\n}\r\n\r\nconst doorEdgeSize = 3;\r\n\r\nexport function GetWallCorners() {\r\n    // ray trace to all of these basically?\r\n}\r\n\r\nexport function HasRoomOrCreate(floor: Floor | undefined, tile: Tile | undefined, coord: Coord, direction: Direction, create: boolean) {\r\n    const hasDoor = tile && tile.doors.has(direction);\r\n\r\n    if (!hasDoor) { return false; }\r\n\r\n    const newCoord = MoveCoord(coord, direction);\r\n    if (!floor?.hasCoord(newCoord)) {\r\n        if (create) {\r\n            floor?.fillCoord(newCoord);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function HasDoor(tile: Tile | undefined, direction: Direction) {\r\n    return tile && tile.doors.has(direction);\r\n}\r\n\r\nexport function CreateRoomIfNeeded(floor: Floor | undefined, coord: Coord, direction: Direction) {\r\n    const newCoord = MoveCoord(coord, direction);\r\n    if (!floor?.hasCoord(newCoord)) {\r\n        floor?.fillCoord(newCoord);\r\n    }\r\n}\r\n\r\nexport function CollideWithWalls(item: Item, floor?: Floor, createOnDoor = false): boolean {\r\n    const hT = .5 * tileSize;\r\n    const hW = .5 * item.width;\r\n    const hH = .5 * item.height;\r\n    const hD = .5 * doorSize;\r\n\r\n    const hDX = hD - hW;\r\n    const hDY = hD - hH;\r\n\r\n    // which TILE is it in?\r\n\r\n    const tileCoord = GetTileCoord(item.position);\r\n    const { x: roomX, y: roomY } = GetRoomCoord(item, tileCoord);\r\n\r\n    const leftWall = hW + wallSize - hT;\r\n    const rightWall = -1 * leftWall;\r\n    const topWall = hH + wallSize - hT;\r\n    const bottomWall = -1 * topWall;\r\n\r\n    const tile = floor?.getCoord(tileCoord);\r\n\r\n    let collisionTrue = false;\r\n    // If you are inside the wall boundary\r\n    if (roomX <= leftWall) {\r\n        // AND you are outside of the door area (or there is no door):\r\n        // Push you back to the edge of the wall.\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"LEFT\", tile, roomY, hDY, hH, createOnDoor, floor);\r\n        if (Math.abs(roomY) > hDY || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomY > 0) {\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.x += leftWall - roomX;\r\n            item.velocity.x = 0;\r\n            collisionTrue = true;\r\n        }\r\n    }\r\n    if (roomX >= rightWall) {\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"RIGHT\", tile, roomY, hDY, hH, createOnDoor, floor);\r\n        if (Math.abs(roomY) > hDY || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomY > 0) {\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.x += rightWall - roomX;\r\n            item.velocity.x = 0;\r\n            collisionTrue = true;\r\n        }\r\n    }\r\n    if (roomY <= topWall) {\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"TOP\", tile, roomX, hDX, hW, createOnDoor, floor);\r\n        if (Math.abs(roomX) > hDX || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomX > 0) {\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.y += topWall - roomY;\r\n            item.velocity.y = 0;\r\n            collisionTrue = true;\r\n        }\r\n    }\r\n    if (roomY >= bottomWall) {\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"BOTTOM\", tile, roomX, hDX, hW, createOnDoor, floor);\r\n        if (Math.abs(roomX) > hDX || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomX > 0) {\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.y += bottomWall - roomY;\r\n            item.velocity.y = 0;\r\n            collisionTrue = true;\r\n        }\r\n    }\r\n\r\n    return collisionTrue;\r\n}\r\n\r\n// TODO: auto refactor gave these variables TRASH names.\r\nfunction hasDoorAndOpenIfNeeded_New(\r\n    direction: Direction,\r\n    tile: Tile | undefined,\r\n    roomY: number,\r\n    hDY: number,\r\n    hH: number,\r\n    createOnDoor: boolean,\r\n    floor: Floor | undefined,\r\n) {\r\n    const hasDoor = HasDoor(tile, direction);\r\n    if (Math.abs(roomY) <= (hDY + hH + 5) && hasDoor && createOnDoor) {\r\n        CreateRoomIfNeeded(floor, tile!, direction);\r\n    }\r\n    return hasDoor;\r\n}\r\n\r\nexport function ApplyFriction(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach(item => {\r\n        if (item.velocity) {\r\n            if (item.velocity.x) {\r\n                item.velocity.x *= .9;\r\n                if (Math.abs(item.velocity.x) < .1) { item.velocity.x = 0; }\r\n            }\r\n            if (item.velocity.y) {\r\n                item.velocity.y *= .9;\r\n                if (Math.abs(item.velocity.y) < .1) { item.velocity.y = 0; }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n// TODO: this doesn't actually separate the items...\r\nexport function InelasticCollision(a: Item, b: Item) {\r\n    // final velocity\r\n    const x = (a.mass * a.velocity.x + b.mass * b.velocity.x) / (a.mass + b.mass);\r\n    const y = (a.mass * a.velocity.y + b.mass * b.velocity.y) / (a.mass + b.mass);\r\n\r\n    // step back their velocities a bit??\r\n    const fudge = .2;\r\n    a.position.x -= a.velocity.x * fudge;\r\n    a.position.y -= a.velocity.y * fudge;\r\n    b.position.x -= b.velocity.x * fudge;\r\n    b.position.y -= b.velocity.y * fudge;\r\n\r\n    // and we want to PUSH them out so they are not colliding.\r\n    // How can we do that? Ideally we would like factor in the faces,d but for laziness\r\n    // we could just push opposite the direction?\r\n    a.velocity.x = x;\r\n    a.velocity.y = y;\r\n    b.velocity.x = x;\r\n    b.velocity.y = y;\r\n}\r\n\r\nexport const InteractionRange = 5;\r\nexport function GetItemsInInteractionDistance(player: Item, items: Item[]) {\r\n    return items.filter((item, i) => {\r\n        if (Distance(player.position, item.position) < InteractionRange + .4 * (item.width + item.height + player.width + player.height)) {\r\n            // how do we want to handle multiple items?\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    });\r\n}\r\n\r\nfunction UnmoveableCollision(moveable: Item, unmoveable: Item) {\r\n    const overlapX = .5 * (moveable.width + unmoveable.width) - Math.abs(moveable.position.x - unmoveable.position.x);\r\n    const overlapY = .5 * (moveable.height + unmoveable.height) - Math.abs(moveable.position.y - unmoveable.position.y);\r\n\r\n    // Use whichever overlap is smalelr inorder to resolve the collision.\r\n    if (overlapX <= overlapY) {\r\n        // just do that one!\r\n        if (moveable.position.x < unmoveable.position.x) {\r\n            moveable.position.x -= overlapX;\r\n            moveable.velocity.x = -overlapX; // LOL, the bounce is kind of fun. This should really be 0 for inelastic collision.\r\n        }\r\n        else {\r\n            moveable.position.x += overlapX;\r\n            moveable.velocity.x = overlapX;\r\n        }\r\n    }\r\n    else {\r\n        // just do that one!\r\n        if (moveable.position.y < unmoveable.position.y) {\r\n            moveable.position.y -= overlapY;\r\n            moveable.velocity.y = -overlapY;\r\n        }\r\n        else {\r\n            moveable.position.y += overlapY;\r\n            moveable.velocity.y = overlapY;\r\n        }\r\n    }\r\n}\r\n\r\nlet max_objects_collided = 0;\r\nexport function CollideItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()].filter(items => items.blockObjects || items.moveable);\r\n    if (items.length > max_objects_collided) {\r\n        console.log(`checking collisions for ${items.length} items`);\r\n        max_objects_collided = items.length;\r\n    }\r\n    //console.log(\"checking collisions for \", items.length);\r\n    items.forEach((item, i) => {\r\n        if (i < items.length - 1) {\r\n            for (let j = i + 1; j < items.length; j++) {\r\n                if (RectangleCollision(item, items[j])) {\r\n                    const item_unmoveable = item.blockObjects && !item.moveable;\r\n                    const other_unmoveable = items[j].blockObjects && !items[j].moveable\r\n                    if (item_unmoveable && !other_unmoveable) {\r\n                        UnmoveableCollision(items[j], item);\r\n                    }\r\n                    else if (!item_unmoveable && other_unmoveable) {\r\n                        UnmoveableCollision(item, items[j]);\r\n                    }\r\n                    // enable once NOT TERRIBLE InelasticCollision(item, items[j]);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function MoveItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach((item, i) => {\r\n        if (item.velocity.x) {\r\n            item.position.x += item.velocity.x;\r\n        }\r\n        if (item.velocity.y) {\r\n            item.position.y += item.velocity.y;\r\n        }\r\n    });\r\n}","import React from 'react';\r\nimport { Coord, EitherDirectionDistance, MoveCoord } from '../coordinates/Coord';\r\nimport { Direction, AllDirections } from '../coordinates/Direction';\r\nimport { Tile } from './Tile';\r\nimport { Floor } from \"./Floor\";\r\nimport { GetTileCoord } from '../items/Collision';\r\nimport { doorSize, tileSize, wallSize } from './Size';\r\nimport { GridItem } from '../items/Items';\r\n\r\n// probably only update this on resize\r\nexport function GetTileViewDist() {\r\n  var screenSize = Math.max(window.innerWidth, window.innerHeight);\r\n  return Math.ceil(screenSize / (2 * tileSize));\r\n}\r\n\r\nexport var tileViewDist = GetTileViewDist();\r\n\r\nconsole.log(\"grid tile tileViewDist\", tileViewDist);\r\n\r\nwindow.addEventListener('resize', () => {\r\n  tileViewDist = GetTileViewDist();\r\n});\r\n\r\nconsole.log(\"Initial view dist\", tileViewDist);\r\n\r\nexport function GetTileTopAndLeft(tileCoord: Coord, center: Coord) {\r\n  return {\r\n    x: tileCoord.x * tileSize + .5 * (window.innerWidth - tileSize) - center.x,\r\n    y: tileCoord.y * tileSize + .5 * (window.innerHeight - tileSize) - center.y,\r\n  }\r\n}\r\n\r\nexport const GridTile: React.FC<{ tile: Tile; floor: Floor; overlayMode: boolean, center: Coord, RenderApp: () => void }> = props => {\r\n  const { tile, floor, overlayMode, center, RenderApp } = props;\r\n\r\n  // check screen space if we should render it!\r\n  const tileCoord = { x: tile.x, y: tile.y };\r\n  const cameraCoord = GetTileCoord(center);\r\n  if (EitherDirectionDistance(tileCoord, cameraCoord) > tileViewDist) {\r\n    return null;\r\n  }\r\n\r\n  return <><div\r\n    style={{\r\n      zIndex: overlayMode ? 10 : 4,\r\n      position: \"absolute\",\r\n      height: tileSize,\r\n      width: tileSize,\r\n      top: tile.y! * tileSize + .5 * (window.innerHeight - tileSize) - center.y,\r\n      left: tile.x! * tileSize + .5 * (window.innerWidth - tileSize) - center.x,\r\n      display: \"flex\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      color: \"white\",\r\n      //border: '5px solid black',\r\n      backgroundColor: overlayMode ? undefined : \"#663333\",\r\n      //backgroundImage: overlayMode ? undefined : `url(${tile.info.image})`,\r\n    }}>\r\n    {tile.info.name}\r\n    {AllDirections().map(d => <GridWall\r\n      RenderApp={RenderApp}\r\n      overlayMode={overlayMode}\r\n      tile={tile}\r\n      floor={floor}\r\n      direction={d}\r\n      hasDoor={tile.doors.has(d)}\r\n      opened={tile.hasNeighbor(floor, d)}\r\n    />)}\r\n  </div>\r\n    {tile.info.items?.filter(item => !item.hidden).map(item => <GridItem\r\n      item={item}\r\n      center={center}\r\n    />)}\r\n  </>;\r\n}\r\n\r\nfunction getWallPosition(direction: Direction, size: number) {\r\n  let top: string | number = 0;\r\n  let bottom: string | number = 0;\r\n  let left: string | number = 0;\r\n  let right: string | number = 0;\r\n\r\n  let width: number | undefined = size;\r\n  let height: number | undefined = size;\r\n\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      bottom = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"BOTTOM\":\r\n      top = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"RIGHT\":\r\n      left = \"auto\";\r\n      height = undefined;\r\n      break;\r\n    case \"LEFT\":\r\n      right = \"auto\";\r\n      height = undefined;\r\n      break;\r\n  }\r\n\r\n  return { top, bottom, left, right, width, height };\r\n}\r\n\r\nexport const GridWall: React.FC<{ overlayMode: boolean, tile: Tile; floor: Floor; direction: Direction; hasDoor: boolean; opened: boolean; RenderApp: () => void }> = props => {\r\n  const { direction, opened, hasDoor, tile, floor, RenderApp } = props;\r\n  const row = direction === \"TOP\" || direction === \"BOTTOM\";\r\n  const filler = <div style={{\r\n    flex: \"auto\",\r\n    backgroundColor: \"#322\",\r\n    height: row ? \"100%\" : undefined, width: row ? undefined : \"100%\"\r\n  }}></div>;\r\n\r\n  return <div\r\n    style={{\r\n      ...getWallPosition(direction, wallSize),\r\n      position: \"absolute\",\r\n      display: \"flex\",\r\n      flexDirection: row ? \"row\" : \"column\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      overflow: \"hidden\",\r\n    }}>\r\n    {filler}\r\n    {hasDoor ?\r\n      <div\r\n        style={{\r\n          cursor: opened ? undefined : \"pointer\",\r\n          height: doorSize,\r\n          width: doorSize,\r\n          backgroundColor: opened ? \"\" : \"grey\"\r\n        }}\r\n        onClick={opened ? undefined : () => {\r\n          floor.fillCoord(MoveCoord(tile.coord, direction));\r\n          RenderApp();\r\n        }}\r\n      >\r\n      </div>\r\n      : null}\r\n    {filler}\r\n  </div>;\r\n};\r\n","export type Direction = \"TOP\" | \"LEFT\" | \"RIGHT\" | \"BOTTOM\";\r\n\r\nexport function AllDirections(): Direction[] {\r\n  return [\"TOP\", \"RIGHT\", \"BOTTOM\", \"LEFT\"];\r\n}\r\n\r\nexport function Opposite(direction: Direction): Direction {\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return \"BOTTOM\";\r\n    case \"BOTTOM\":\r\n      return \"TOP\";\r\n    case \"RIGHT\":\r\n      return \"LEFT\";\r\n    case \"LEFT\":\r\n      return \"RIGHT\";\r\n  }\r\n}\r\n\r\nexport function Rotate(direction: Direction, rotation: number) {\r\n  const allDirections = AllDirections();\r\n  const index = allDirections.indexOf(direction);\r\n  return allDirections[(index + rotation) % allDirections.length];\r\n}\r\n","import { GetTileTopAndLeft } from './GridTile';\r\nimport { Coord, MoveCoord } from '../coordinates/Coord';\r\nimport { Direction, Rotate } from '../coordinates/Direction';\r\nimport { Floor } from './Floor';\r\nimport { Item, CopyItem } from '../items/Items';\r\nimport { tileSize } from './Size';\r\n\r\ninterface TileInfo {\r\n  name: string;\r\n\r\n  doors: Direction[];\r\n\r\n  image?: string;\r\n\r\n  items?: Item[]; // These positions are in relative roomX, roomY.\r\n\r\n  // is there only 1 copy or are there multiple? \r\n  // SHOULD we just have a stack of rooms and pick from them and take them out when we use them??\r\n  copies?: boolean;\r\n}\r\n\r\nexport class Tile {\r\n  // Rotations RIGHT in 90 increments. 0-3;\r\n  //public rotation = 0; // TODO\r\n  public x = 0;\r\n  public y = 0;\r\n  private initialDoors: Set<Direction>;\r\n  private rotation = 0;\r\n  private imageEl_: HTMLImageElement | null = null;\r\n\r\n  constructor(public readonly info: TileInfo) {\r\n    const { doors } = info;\r\n    this.initialDoors = new Set<Direction>(doors);\r\n  }\r\n\r\n  get coord(): Coord {\r\n    return { x: this.x, y: this.y };\r\n  }\r\n\r\n  get doors(): Set<Direction> {\r\n    const rotatedDoors = new Set<Direction>();\r\n    this.initialDoors.forEach(door => { rotatedDoors.add(Rotate(door, this.rotation)); });\r\n    return rotatedDoors;\r\n  }\r\n\r\n  /** Return valid rotations for the tile to be placed in a spot with the given constraints. */\r\n  // TODO: Handle ROTATION PROBABLY!\r\n  canPlace(neededDoors: Set<Direction>, neededWalls: Set<Direction>): boolean {\r\n    // TODO: Wait what about WALLS where we SHOULDNT have doors!\r\n    // ensure all needed doors are there\r\n    let canPlace = true;\r\n    neededDoors.forEach(direction => {\r\n      if (!this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    // ensure all needed walls have no doors!\r\n    neededWalls.forEach(direction => {\r\n      if (this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    return canPlace;\r\n  }\r\n\r\n  copy(r?: number) {\r\n    const t = new Tile({\r\n      ...this.info,\r\n      items: this.info.items?.map(item => CopyItem(item)), // this breaks monsters :(\r\n    });\r\n    if (r) {\r\n      t.rotate(r);\r\n    }\r\n    else {\r\n      t.rotate(this.rotation);\r\n    }\r\n    return t;\r\n  }\r\n\r\n  rotate(r: number) {\r\n    this.rotation = r % 4;\r\n    return this;\r\n  }\r\n\r\n  hasNeighbor(floor: Floor, direction: Direction): boolean {\r\n    // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n    return floor.hasCoord(MoveCoord(this.coord, direction));\r\n  }\r\n\r\n  get image() {\r\n    if (this.imageEl_) { return this.imageEl_; }\r\n    if (!this.info.image) { return null; }\r\n    this.imageEl_ = document.createElement(\"img\");\r\n    this.imageEl_.width = tileSize;\r\n    this.imageEl_.height = tileSize;\r\n    this.imageEl_.src = this.info.image;\r\n  }\r\n\r\n  drawToCanvas(ctx: CanvasRenderingContext2D, center: Coord) {\r\n    const topCorner = GetTileTopAndLeft(this.coord, center);\r\n    /*\r\n    if (this.image) {\r\n      // this doesn't handle ROTATION right. so we would need to create ANOTHER\r\n      // canvas with the image and THEN rotate it.\r\n      let im: HTMLImageElement | HTMLCanvasElement = this.image;\r\n      \r\n      /* OK, just need to... fix this some how... or have rotated image LOL.\r\n      if (this.rotation) {\r\n        const temp = document.createElement(\"canvas\");\r\n        temp.width = tileSize;\r\n        temp.height = tileSize;\r\n        const tc = temp.getContext(\"2d\")!;\r\n        tc.drawImage(this.image, 0, 0, tileSize, tileSize);\r\n        tc.translate(-.5 * tileSize, -.5 * tileSize);\r\n        console.log(\"ROTATIMG IMAGE!\", this.rotation, Math.PI * this.rotation / 2);\r\n        tc.rotate(Math.PI * this.rotation / 4);\r\n        tc.translate(.5 * tileSize, .5 * tileSize);\r\n        im = temp;\r\n      }\r\n\r\n      ctx.drawImage(im, topCorner.x, topCorner.y, tileSize, tileSize);\r\n    }\r\n    else { */\r\n      ctx.fillStyle = \"#663333\"; // brown..ish?\r\n      ctx.fillRect(topCorner.x - 1, topCorner.y - 1, tileSize + 2, tileSize + 2);\r\n    //}\r\n  }\r\n}\r\n","import { purse, watch, table, CopyItem, curesedKnife, Item, GetItems, DrawItemToCanvas } from '../items/Items';\r\nimport { Tile } from './Tile';\r\nimport { Floor } from './Floor';\r\nimport { UpdateFogCanvas } from '../hud/SightLines';\r\nimport { Coord } from '../coordinates/Coord';\r\nimport dining_room from \"./../../images/rooms/BAD_COPIES/dining_room.jpg\";\r\nimport kitchen from \"./../../images/rooms/BAD_COPIES/kitchen.jpg\";\r\nimport storeroom from \"./../../images/rooms/BAD_COPIES/storeroom.jpg\";\r\nimport patio from \"./../../images/rooms/BAD_COPIES/patio.jpg\";\r\nimport entrance from \"./../../images/rooms/BAD_COPIES/entrance.jpg\";\r\nimport { BasicMonster } from '../items/Monsters';\r\n\r\nconst Kitchen = new Tile({\r\n  name: \"KITCHEN\",\r\n  doors: [\"TOP\", \"RIGHT\"],\r\n  image: kitchen,\r\n});\r\n\r\nconst Patio = new Tile({\r\n  name: \"PATIO\",\r\n  doors: [\"TOP\", \"LEFT\", \"BOTTOM\"],\r\n  image: patio,\r\n});\r\n\r\nconst Storeroom = new Tile({\r\n  name: \"STOREROOM\",\r\n  doors: [\"TOP\"],\r\n  image: storeroom,\r\n});\r\n\r\nconst DiningRoom = new Tile({\r\n  name: \"DINING ROOM\",\r\n  doors: [\"TOP\", \"RIGHT\"],\r\n  image: dining_room,\r\n});\r\n\r\nexport const Entrance = new Tile({\r\n  name: \"Entrance\",\r\n  doors: [\"TOP\", \"LEFT\", \"BOTTOM\"],\r\n  image: entrance,\r\n});\r\n\r\nconst FourWay = new Tile({\r\n  name: \"Hallway\",\r\n  doors: [\"TOP\", \"LEFT\", \"RIGHT\", \"BOTTOM\"],\r\n});\r\n\r\n\r\nFourWay.info.items = [CopyItem(table)];\r\nconst TeeWay = new Tile({ name: \"Hallway\", doors: [\"TOP\", \"LEFT\", \"RIGHT\"] });\r\nconst Straight = new Tile({ name: \"Straight\", doors: [\"TOP\", \"BOTTOM\"] });\r\n\r\nStraight.info.items = [CopyItem(purse)];\r\n\r\nconst LTurn = new Tile({ name: \"Hallway\", doors: [\"TOP\", \"RIGHT\"] });\r\n//LTurn.info.items = [new BasicMonster()]; // THIS IS NOT HOW WE SHOULD DO IT. do this when FILLING THE TILE.\r\n\r\nconst RTurn = new Tile({ name: \"Hallway\", doors: [\"TOP\", \"LEFT\"] });\r\nRTurn.info.items = [CopyItem(curesedKnife)]; // THIS IS NOT HOW WE SHOULD DO IT. do this when FILLING THE TILE.\r\n\r\nconst DeadEnd = new Tile({ name: \"Closet\", doors: [\"TOP\"] });\r\nDeadEnd.info.items = [CopyItem(watch)]; // THIS IS NOT HOW WE SHOULD DO IT. do this when FILLING THE TILE.\r\n\r\nfunction AllWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1), tile.copy(2), tile.copy(3)];\r\n}\r\n\r\nfunction TwoWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1)];\r\n}\r\n\r\nexport const TileLibrary = [\r\n  ...TwoWay(FourWay),\r\n  ...TwoWay(Straight),\r\n  ...AllWay(TeeWay),\r\n  ...AllWay(LTurn),\r\n  ...AllWay(RTurn),\r\n  ...AllWay(DeadEnd),\r\n  ...AllWay(Kitchen),\r\n  ...AllWay(Storeroom),\r\n  ...AllWay(Patio),\r\n  ...AllWay(DiningRoom),\r\n];\r\n\r\nfunction createCanvas(id: string) {\r\n  const canvas: HTMLCanvasElement = document.createElement(\"canvas\");\r\n  canvas.id = \"Canvas_FloorAndItems\";\r\n  canvas.width = window.innerWidth;\r\n  canvas.height = window.innerHeight;\r\n\r\n  document.addEventListener('resize', ()=>{\r\n    canvas.height = window.innerHeight;\r\n    canvas.width = window.innerWidth;\r\n  })\r\n\r\n  return {\r\n    canvas,\r\n    ctx: canvas.getContext(\"2d\")!,\r\n  };\r\n}\r\n\r\nconst { canvas: tileCanvas, ctx: tileCtx } = createCanvas(\"Canvas_Floor\");\r\nconst { canvas: sightCanvas, ctx: sightCtx } = createCanvas(\"Canvas_Sight\");\r\ndocument.body.append(tileCanvas);\r\ndocument.body.append(sightCanvas);\r\nvar resultCanvas: HTMLCanvasElement;\r\nvar resultCtx: CanvasRenderingContext2D;\r\n\r\nexport function DoSightLineThing(player: Item, floor: Floor, center: Coord) {\r\n  DrawAllRooms(floor, center);\r\n  //DrawAllItems(center); // this is wrong somehow\r\n  DrawSightCanvas(player, floor);\r\n  DrawResult();\r\n}\r\n\r\nexport function DrawAllRooms(floor: Floor, center: Coord) {\r\n  tileCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n  floor.tiles.forEach(tile => {\r\n    tile.drawToCanvas(tileCtx, center);\r\n  });\r\n}\r\n\r\nexport function DrawAllItems(center: Coord) {\r\n  GetItems().forEach(item => {\r\n    DrawItemToCanvas(tileCtx, item, center);\r\n  });\r\n}\r\n\r\nexport function DrawSightCanvas(player: Item, floor: Floor) {\r\n  UpdateFogCanvas(sightCtx, player, floor);\r\n  sightCtx.filter = \"blur(5px)\";\r\n}\r\n\r\nexport function DrawResult() {\r\n  if (!resultCanvas) {\r\n    resultCanvas = document.getElementById(\"Canvas_SightResult\") as HTMLCanvasElement;\r\n    if (!resultCanvas) { return; }\r\n  }\r\n  if (!resultCtx) {\r\n    resultCtx = resultCanvas.getContext(\"2d\")!;\r\n    resultCtx.save();\r\n  }\r\n\r\n  resultCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n  resultCtx.globalCompositeOperation = \"source-over\";\r\n  resultCtx.restore();\r\n  //resultCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n  //resultCtx.fillStyle=\"white\";\r\n  //resultCtx.fillRect(0,0,window.innerWidth,window.innerHeight);\r\n  resultCtx.drawImage(sightCanvas, 0, 0);\r\n  resultCtx.globalCompositeOperation = \"source-in\";\r\n  resultCtx.drawImage(tileCanvas, 0, 0);\r\n}","import { Item } from \"./Items\";\r\n\r\nexport type StatType =\r\n    \"strength\" |\r\n    \"dexterity\" |\r\n    \"intellect\" |\r\n    \"spirit\" |\r\n    \"fear\";\r\n\r\nexport interface Creature extends Item {\r\n    /**\r\n     * Items you are carrying.\r\n     * IDK do we need some kind of ACTIVE vs CARRIED distinction for some items,\r\n     * like you can't have 4 weapons at the same time\r\n     */\r\n    inventory: Item[];\r\n    stats: Stats;\r\n}\r\n\r\n/** Pyramid style distribution from 0 - 2  */\r\nexport function Gaussish(){\r\n    return Math.random() + Math.random();\r\n}\r\n\r\n/** Cheap version of normal distribution from 0 - 2N (in increments of .5) */\r\nexport function N2Gaussish(n: number){\r\n    let sum = 0;\r\n    for(let i = 0; i < n * 2; i++){\r\n        sum += Math.random();\r\n    }\r\n\r\n    return sum;\r\n}\r\n\r\nexport interface Stats {\r\n    get(stat: StatType): number;\r\n    roll(stat: StatType): number;\r\n    buff(stat: StatType, buff: number): number;\r\n    damage(stat: StatType, damage: number): number;\r\n}\r\n\r\nexport class PlayerStats implements Stats {\r\n    private holder = new Map<StatType, number>();\r\n    constructor(\r\n        str: number,\r\n        dex: number,\r\n        int: number,\r\n        spt: number,\r\n        allowBeingSuperAmazing = false,\r\n    ) {\r\n        if (str + dex + int + spt > 15 && !allowBeingSuperAmazing) {\r\n            throw new Error(\"You can't be that great!!\");\r\n        }\r\n        this.holder.set(\"strength\", str);\r\n        this.holder.set(\"dexterity\", dex);\r\n        this.holder.set(\"intellect\", int);\r\n        this.holder.set(\"spirit\", spt);\r\n        this.holder.set(\"fear\", 0);\r\n    }\r\n\r\n    get(stat: StatType): number {\r\n        // All stats are always populated\r\n        return this.holder.get(stat)!;\r\n    }\r\n\r\n    roll(stat: StatType): number {\r\n        // Roll for the stat. N2 Gaussish provides a roughly normal distribution at higher numbers\r\n        // strangely this always will do whole numbers, so partials are ignored\r\n        return N2Gaussish(this.get(stat));\r\n    }\r\n\r\n    buff(stat: StatType, buff: number): number {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    \r\n    damage(stat: StatType, damage: number): number {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}","import { Coord, Distance, MakeUnitVector, Multiply, Subtract } from \"../coordinates/Coord\";\r\nimport { GetItems, Item } from \"./Items\";\r\nimport { Player } from \"./Player\";\r\nimport { Creature, PlayerStats, Stats, StatType } from \"./Stats\";\r\n\r\nexport interface Monster extends Creature {\r\n    attackType: StatType;\r\n    decide_move(players: Player[]): void;\r\n    checkForAttack(players: Player[]): Player|null;\r\n}\r\n\r\nconst DumbMosterMoveRange = 600;\r\nconst DumbMosterAttackRange = 10;\r\n\r\nvar monsters: Monster[] = [];\r\n\r\nexport function GetMonsters(){\r\n    return GetItems().filter(maybeMonster => !!(maybeMonster as Monster).decide_move) as Monster[];\r\n}\r\n\r\nexport class BasicMonster implements Monster {\r\n    attackType: StatType = \"strength\";\r\n    inventory: Item[] = [];\r\n    stats = new PlayerStats(1, 1, 1, 1);\r\n    position = { x: 0, y: 0 };\r\n    height = 40;\r\n    width = 40;\r\n    name = \"Monster\";\r\n    color = \"green\";\r\n    moveable = true;\r\n    blockObjects = true;\r\n    mass = 100;\r\n    velocity: Coord = { x: 0, y: 0 };\r\n\r\n    constructor(){\r\n        monsters.push(this);\r\n    }\r\n\r\n    private getClosestPlayer(players: Player[]) {\r\n        // cool\r\n        let closest: Player = players[0];\r\n        let closestDistance = Number.MAX_VALUE;\r\n\r\n        players.forEach(player => {\r\n            const dist = Distance(player.position, this.position);\r\n            if (dist < closestDistance) {\r\n                closestDistance = dist;\r\n                closest = player;\r\n            }\r\n        });\r\n\r\n        return { closest, closestDistance };\r\n    }\r\n\r\n    decide_move(players: Player[]) {\r\n        const { closest, closestDistance } = this.getClosestPlayer(players);\r\n\r\n        if (closestDistance < DumbMosterMoveRange) {\r\n            this.velocity = Multiply(MakeUnitVector(Subtract(closest.position, this.position)), 3);\r\n        }\r\n        else {\r\n            this.velocity = { x: 0, y: 0 };\r\n        }\r\n    }\r\n\r\n    checkForAttack(players: Player[]): Player | null {\r\n        const { closest, closestDistance } = this.getClosestPlayer(players);\r\n\r\n        if (closestDistance < (DumbMosterAttackRange + Math.max(this.width, this.height))) {\r\n            return closest;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}","import { Add, Coord, MoveCoord, Multiply } from '../coordinates/Coord';\r\nimport { Direction, AllDirections, Opposite } from '../coordinates/Direction';\r\nimport { Tile } from './Tile';\r\nimport { Entrance, TileLibrary } from './Rooms';\r\nimport { tileSize } from './Size';\r\nimport { AddItem } from '../items/Items';\r\nimport { BasicMonster } from '../items/Monsters';\r\n\r\nexport function IndexCoord(c: Coord) { return Index(c.x, c.y); }\r\nexport function Index(x: number, y: number) { return `${x}, ${y}`; }\r\n\r\nexport class Floor {\r\n  constructor(public readonly name: string) { }\r\n\r\n  private grid = new Map<string, Tile>();\r\n\r\n  getCoord(c: Coord): Tile | undefined { return this.getTile(c.x, c.y); }\r\n  getTile(x: number, y: number): Tile | undefined { return this.grid.get(Index(x, y)); }\r\n\r\n  hasCoord(c: Coord): boolean { return this.hasTile(c.x, c.y); }\r\n  hasTile(x: number, y: number): boolean { return this.grid.has(Index(x, y)); }\r\n\r\n  setCoord(tile: Tile, c: Coord) { this.setTile(tile, c.x, c.y); }\r\n  setTile(tile: Tile, x: number, y: number) {\r\n    if (this.hasTile(x, y)) {\r\n      throw new Error(`Tried placing a tile where there already was one! ${x}. ${y}: ${tile.info.name}, existing tile was ${this.getTile(x, y)?.info.name}`);\r\n    }\r\n\r\n    tile.x = x;\r\n    tile.y = y;\r\n\r\n    const tileCenter = Multiply(Add(tile.coord, { x: 0, y: 0 }), tileSize);\r\n    tile.info.items = tile.info.items?.filter(item => {\r\n      item.position = Add(item.position, tileCenter);\r\n      if (item.moveable) {\r\n        // make moveable room items just NORMAL items.\r\n        AddItem(item);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n\r\n    this.grid.set(Index(x, y), tile);\r\n  }\r\n\r\n  get tiles(): Tile[] {\r\n    return Array.from(this.grid, ([key, tile]) => tile);\r\n  }\r\n\r\n  // return all POSSIBLE playing places\r\n  getValidSpotsForTiles() {\r\n    // this is maybe not the best approach. Cool ,but not needed right now...\r\n  }\r\n\r\n  fillCoord(c: Coord) { this.fillTile(c.x, c.y); }\r\n  fillTile(x: number, y: number) {\r\n    // 1. get all tiles bordering this.\r\n    const neighbors = AllDirections().map(d => this.getCoord(MoveCoord({ x, y }, d)));\r\n    const neededDoors = new Set<Direction>();\r\n    const neededWalls = new Set<Direction>();\r\n\r\n    AllDirections().forEach(direction => {\r\n      const neighbor = this.getCoord(MoveCoord({ x, y }, direction));\r\n      if (neighbor) {\r\n        if (neighbor.doors.has(Opposite(direction))) {\r\n          neededDoors.add(direction);\r\n        }\r\n        else {\r\n          neededWalls.add(direction);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Find possible tiles\r\n    // TODO: Factor in floor (basement, attic, etc) and stuff.\r\n    const matchingTiles = TileLibrary.filter(tile => tile.canPlace(neededDoors, neededWalls));\r\n\r\n    // TODO: we should never CLOSE off the entire floor, E.G. you should always be able to have at least 1 open door on each floor.\r\n\r\n    // Pick a random tile from the possible ones.\r\n    if (!matchingTiles) { throw new Error(\"No valid tile can go there! Wow we should really fix that!\"); }\r\n\r\n    const newTile = matchingTiles[Math.floor(Math.random() * matchingTiles.length)].copy();\r\n\r\n    // PICK items that apear\r\n\r\n    // things can have like SHELVES/etc you need to search\r\n    // things can be on the ground\r\n    // rooms have affinities for certain items, but never GUARANTEED\r\n    // E>G> Knife often found in Kitchens.\r\n\r\n    this.setTile(newTile, x, y);\r\n  }\r\n}\r\n\r\nexport const FirstFloor = new Floor(\"Main Floor\");\r\nconst entrance = Entrance.copy();\r\nconst monster = new BasicMonster();\r\nmonster.position.x = -125;\r\nmonster.position.y = 125;\r\nentrance.info.items = [monster]\r\nFirstFloor.setTile(entrance, 0, 0);\r\n","import React from 'react';\r\nimport { GridItem } from \"./Items\";\r\nimport kid_green from \"./../../images/players/kid_green.png\";\r\nimport { Coord } from '../coordinates/Coord';\r\nimport { Creature, PlayerStats } from './Stats';\r\n\r\nexport interface Player extends Creature {\r\n  // Right now there is nothing special.\r\n  // Later we will probably add things like.. connection and voice and stuff\r\n}\r\n\r\nexport const player: Player = {\r\n  // item stuff\r\n  position: { x: 0, y: 0 },\r\n  height: 50,\r\n  width: 25,\r\n  color: \"red\",\r\n  name: \"You\",\r\n  velocity: { x: 0, y: 0 },\r\n  mass: 140,\r\n  image: kid_green,\r\n\r\n  blockObjects: true,\r\n  moveable: true, // Is this really smart??\r\n\r\n  //player stuff\r\n  stats: new PlayerStats(4,4,4,3),\r\n  inventory: [],\r\n\r\n};\r\n\r\nexport const playerZindex = 51;\r\n\r\nexport function GridPlayer(props: { center: Coord }) {\r\n  return <GridItem item={player} zIndex={playerZindex} center={props.center} />\r\n}\r\n","import * as React from 'react';\r\n\r\nexport const menuZIndex = 75;\r\n\r\nexport const MenuStyle: React.CSSProperties = {\r\n    zIndex: menuZIndex,\r\n    position: \"absolute\",\r\n    border: \"2px solid white\",\r\n    backgroundColor: \"#442211\",\r\n    padding: 5,\r\n    color: \"white\",\r\n};\r\n\r\n","import * as React from 'react';\r\nimport { Coord } from '../coordinates/Coord';\r\nimport { Item } from \"../items/Items\";\r\nimport { toScreenSpot } from './SightLines';\r\nimport { MenuStyle } from './MenuStyle';\r\nimport { Player } from '../items/Player';\r\n\r\nvar interactables: Item[] = [];\r\n\r\nexport function SetInteractables(items: Item[]) {\r\n    interactables = items;\r\n}\r\n\r\nexport function Add(a: Coord, b: Coord) {\r\n    return {\r\n        x: a.x + b.x,\r\n        y: a.y + b.y,\r\n    };\r\n}\r\n\r\nexport function toScreenPositionStyle(c: Coord): React.CSSProperties {\r\n    const spot = toScreenSpot(c);\r\n    return {\r\n        top: spot.y,\r\n        left: spot.x,\r\n        position: \"absolute\",\r\n    }\r\n}\r\n\r\nexport function InteractionButtons({ item, player, inInventory = false, onGround = false }:\r\n    { item: Item, player: Player, inInventory?: boolean, onGround?: boolean }) {\r\n    return <>\r\n        <div>{item.name}</div>\r\n        {item.playerInteractions\r\n            ?.filter(interaction =>\r\n                (interaction.canDoInInventory || !inInventory)\r\n                && (interaction.canDoOnGround || !onGround))\r\n            ?.map(interaction =>\r\n                <button\r\n                    style={{ cursor: \"pointer\" }}\r\n                    onClick={() => interaction.action(player, item)}>\r\n                    {interaction.name}\r\n                </button>)}\r\n    </>;\r\n}\r\n\r\n// want it like.. by the player?\r\nexport function Interactions(props: { player: Player }) {\r\n    const { player } = props;\r\n    if (interactables.length <= 0) { return null; }\r\n\r\n    return <>\r\n        {interactables.filter(i => i.name || i.playerInteractions?.length).map(item =>\r\n            <div style={{\r\n                ...MenuStyle,\r\n                zIndex: 100,\r\n                ...toScreenPositionStyle(Add(\r\n                    item.position,\r\n                    { x: .5 * item.width + 5, y: .5 * item.height + 5 }\r\n                )),\r\n                textAlign: \"center\",\r\n                display: \"flex\",\r\n                flexDirection: \"column\",\r\n            }}>\r\n                <InteractionButtons item={item} player={player} onGround={true} />\r\n            </div>\r\n        )}\r\n    </>\r\n}","import * as React from 'react';\r\nimport { InteractionButtons } from './Hud_Interaction';\r\nimport { MenuStyle } from \"./MenuStyle\";\r\nimport { Player } from \"../items/Player\";\r\n\r\n// want it like.. by the player?\r\nexport function Inventory(props: { player: Player }) {\r\n    const { player } = props;\r\n    const inventory = player.inventory;\r\n\r\n    if (inventory.length <= 0) { return null; }\r\n    return <div style={{\r\n        ...MenuStyle,\r\n        zIndex: 75,\r\n        bottom: 20,\r\n        left: 20,\r\n\r\n    }}>\r\n        <div style={{\r\n            display: \"flex\",\r\n            flexDirection: \"row\",\r\n            alignItems: \"stretch\",\r\n        }}>\r\n            {inventory.map(item =>\r\n                <div style={{\r\n                    padding: 10,\r\n                    textAlign: \"center\",\r\n                    display: \"flex\",\r\n                    flexDirection: \"column\",\r\n                    alignItems: \"center\",\r\n                    justifyContent: \"flex-end\",\r\n                }}>\r\n                    {item.image\r\n                        ? <img\r\n                            src={item.image}\r\n                            style={{\r\n                                cursor: \"pointer\",\r\n                                maxWidth: 50,\r\n                                maxHeight: 50\r\n                            }}\r\n                        />\r\n                        : <div style={{\r\n                            cursor: \"pointer\",\r\n                            backgroundColor: item.color,\r\n                            width: item.width,\r\n                            height: item.height\r\n                        }}></div>}\r\n\r\n                    <div style={{ display: \"flex\", flexDirection: \"column\" }}>\r\n                        <InteractionButtons item={item} player={player} inInventory={true} />\r\n                    </div>\r\n                </div>\r\n            )}\r\n        </div>\r\n    </div>\r\n}","import * as React from 'react';\r\nimport { MenuStyle } from \"./MenuStyle\";\r\nimport { Player } from \"../items/Player\";\r\nimport { StatType } from '../items/Stats';\r\n\r\n// want it like.. by the player?\r\nexport function HudStats(props: { player: Player }) {\r\n    const stats = props.player.stats;\r\n\r\n    return <div style={{\r\n        ...MenuStyle,\r\n        top: 20,\r\n        right: 20,\r\n\r\n    }}>\r\n            <StatRow statType=\"strength\" num={stats.get(\"strength\")} />\r\n            <StatRow statType=\"dexterity\" num={stats.get(\"dexterity\")} />\r\n            <StatRow statType=\"intellect\" num={stats.get(\"intellect\")} />\r\n            <StatRow statType=\"spirit\" num={stats.get(\"spirit\")} />\r\n            <StatRow statType=\"fear\" num={stats.get(\"fear\")} />\r\n    </div>\r\n}\r\n\r\nfunction StatRow(props: {statType: StatType, num: number}){\r\n    const {statType, num} = props;\r\n    return <div>\r\n        <div>{statType}: {num}</div>\r\n    </div>\r\n}","import React from 'react';\nimport './App.css';\nimport { GridTile } from './game/tiles/GridTile';\nimport { ApplyFriction, CollideItems, CollideWithWalls, GetItemsInInteractionDistance, GetTileCoord, MoveItems } from './game/items/Collision';\nimport { FirstFloor, Index } from './game/tiles/Floor';\nimport { GridPlayer, player } from './game/items/Player';\nimport { GetItems, GridItem } from './game/items/Items';\nimport { Interactions, SetInteractables } from './game/hud/Hud_Interaction';\nimport { Inventory } from './game/hud/Inventory';\nimport { DoSightLineThing } from './game/tiles/Rooms';\nimport { HudStats } from './game/hud/Hud_Stats';\nimport { GetMonsters } from './game/items/Monsters';\n\nexport let centerX = 0;\nexport let centerY = 0;\n\nexport var RenderApp = () => { };\n\nvar showMap = false;\nvar showFog = false; // turn off for now.. Sightlines would be cool, but circle looks dumb.\nconst canvasStyle: React.CSSProperties = {\n  position: \"absolute\",\n  zIndex: 5,\n  width: \"100%\",\n  height: \"100%\",\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n};\n\nfunction App() {\n  const [, setState] = React.useState(0);\n  const rerender = React.useCallback(() => {\n    setState(Math.random());\n  }, [setState]);\n\n  React.useEffect(() => { RenderApp = rerender; }, [rerender]);\n  const center = { x: centerX, y: centerY };\n  return (\n    <div className=\"App\" style={{ overflow: \"hidden\" }}>\n      {showMap ?\n        <div style={{ zIndex: 100, bottom: 0, padding: 20, position: \"absolute\", left: 0, right: 0 }}>\n          <div style={{ color: \"white\" }}>Map</div>\n          <button onClick={() => { centerY -= 100; rerender(); }}>UP!</button>\n          <button onClick={() => { centerY += 100; rerender(); }}>DOWN!</button>\n          <button onClick={() => { centerX -= 100; rerender(); }}>LEFT!</button>\n          <button onClick={() => { centerX += 100; rerender(); }}>RIGHT!</button>\n          <button onClick={() => { centerX = 0; centerY = 0; rerender(); }}>CENTER!</button>\n        </div> : null}\n      <GridPlayer center={center} />\n\n      <div>\n\n        {showFog ? <canvas id=\"fog\"\n          width={window.innerWidth}\n          height={window.innerHeight}\n          style={{\n            ...canvasStyle,\n            opacity: .2,\n            //mixBlendMode: \"multiply\",\n            filter: \"blur(5px)\",\n          }} /> : null}\n\n        <canvas id=\"Canvas_SightResult\"\n          width={window.innerWidth}\n          height={window.innerHeight}\n          style={{\n            ...canvasStyle,\n            zIndex: 6,\n          }} />\n\n        <div id=\"gamefloor\" style={{ mixBlendMode: \"normal\" }}>\n\n          {FirstFloor.tiles.map((tile) => <GridTile\n            RenderApp={rerender}\n            center={center}\n            overlayMode={true}\n            floor={FirstFloor}\n            tile={tile}\n            key={Index(tile.x, tile.y)}\n          />)}\n\n          {GetItems().map((item) => <GridItem item={item} center={center} />)\n          }\n\n        </div>\n      </div>\n\n      <Interactions player={player} />\n      <Inventory player={player} />\n      <HudStats player={player} />\n\n    </div>\n  );\n}\n\nlet leftPressed = false;\nlet upPressed = false;\nlet rightPressed = false;\nlet downPressed = false;\n\nlet mPressed = false;\n\ndocument.addEventListener('keydown', e => {\n  if (e.key === \"m\" || e.key === \"M\") {\n    if (!mPressed) { showMap = !showMap; }\n    mPressed = true;\n  }\n\n  if (e.key === \"a\" || e.key === \"A\" || e.key === \"ArrowLeft\") {\n    leftPressed = true;\n    rightPressed = false;\n  }\n  if (e.key === \"d\" || e.key === \"D\" || e.key === \"ArrowRight\") {\n    rightPressed = true;\n    leftPressed = false;\n  }\n  if (e.key === \"w\" || e.key === \"W\" || e.key === \"ArrowUp\") {\n    upPressed = true;\n    downPressed = false;\n  }\n  if (e.key === \"s\" || e.key === \"S\" || e.key === \"ArrowDown\") {\n    downPressed = true;\n    upPressed = false;\n  }\n});\n\ndocument.addEventListener('keyup', e => {\n  //console.log(e.key);\n  if (e.key === \"a\" || e.key === \"A\" || e.key === \"ArrowLeft\") {\n    leftPressed = false;\n  }\n  if (e.key === \"d\" || e.key === \"D\" || e.key === \"ArrowRight\") {\n    rightPressed = false;\n  }\n  if (e.key === \"w\" || e.key === \"W\" || e.key === \"ArrowUp\") {\n    upPressed = false;\n  }\n  if (e.key === \"s\" || e.key === \"S\" || e.key === \"ArrowDown\") {\n    downPressed = false;\n  }\n  if (e.key === \"m\" || e.key === \"M\") {\n    mPressed = false;\n  }\n});\n\nconst moveSpeed = 2;\nconst playerAccel = .3;\nconst mapSpeed = 7;\n\nfunction animate() {\n  if (showMap) {\n    if (leftPressed) {\n      centerX -= mapSpeed;\n    }\n    if (rightPressed) {\n      centerX += mapSpeed;\n    }\n    if (upPressed) {\n      centerY -= mapSpeed;\n    }\n    if (downPressed) {\n      centerY += mapSpeed;\n    }\n  }\n  else {\n    player.velocity = player.velocity || { x: 0, y: 0 };\n    if (leftPressed && player.velocity.x > -moveSpeed) {\n      //player.position.x -= moveSpeed;\n      player.velocity.x -= playerAccel;\n      player.imageTransform = undefined;\n    }\n    if (rightPressed && player.velocity.x < moveSpeed) {\n      //player.position.x += moveSpeed;\n      player.velocity.x += playerAccel;\n      player.imageTransform = \"scale(-1,1)\";\n    }\n    if (upPressed && player.velocity.y > -moveSpeed) {\n      //player.position.y -= moveSpeed;\n      player.velocity.y -= playerAccel;\n    }\n    if (downPressed && player.velocity.y < moveSpeed) {\n      //player.position.y += moveSpeed;\n      player.velocity.y += playerAccel;\n    }\n  }\n\n  MoveItems([player, ...GetMonsters()]);\n  CollideWithWalls(player, FirstFloor, true);\n  GetItems().filter(item => item.moveable && item.blockObjects).forEach(item => CollideWithWalls(item, FirstFloor));\n\n  GetMonsters().forEach(monster => {\n    const attackingPlayer = monster.checkForAttack([player]);\n    if (attackingPlayer) {\n      // do rolls and stuff!\n      const playerRoll = attackingPlayer.stats.roll(monster.attackType);\n      const monsterRoll = monster.stats.roll(monster.attackType);\n      console.log(`Monster did ${monsterRoll - playerRoll} damage!`);\n    }\n  })\n\n  ApplyFriction([player]);\n\n  // TODO: don't check for interaction distance EVERY frame, this is totaly overkill\n  // BRO DO we really need ROOM items vs NORMAL items??\n  // room items should probably be only things that ARENT moveable.\n  // like decorative things or things for the room geometry like counters and shelves and stuff.  \n  const roomItems = FirstFloor.getCoord(GetTileCoord(player.position))?.info.items?.filter(item => !item.hidden);\n  SetInteractables(\n    GetItemsInInteractionDistance(\n      player,\n      [\n        ...GetItems(),\n        ...(roomItems || []),\n      ]\n    )\n  );\n\n  CollideItems([\n    player,\n    ...(roomItems?.filter(item => item.moveable || item.blockObjects) || [])\n  ]);\n\n  // FOLLOW CAM\n  if (!showMap) {\n    centerX = player.position.x;\n    centerY = player.position.y;\n  }\n\n  const center = { x: centerX, y: centerY };\n\n  DoSightLineThing(player, FirstFloor, center);\n  //  DrawAllRooms(FirstFloor);\n  // BASIC fog, wont need latershowFog && UpdateFog(player, FirstFloor);\n  RenderApp();\n  requestAnimationFrame(() => animate());\n}\n\nanimate();\n\n// SLOW STUFF\nsetInterval(() => {\n  GetMonsters().forEach(monster => monster.decide_move([player]));\n  console.log(\"Monsters\", GetMonsters(), GetItems());\n}, 1000);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker === null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}