{"version":3,"sources":["images/players/kid_green.png","tiles/Coord.ts","tiles/Items.tsx","tiles/Collision.ts","tiles/Size.ts","GridTile.tsx","tiles/Direction.ts","tiles/Tile.ts","tiles/RegisterTiles.ts","tiles/Floor.ts","tiles/SightLines.ts","Player.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","MoveCoord","c","direction","x","y","items","GetItems","GridItem","props","item","hW","width","hH","height","title","name","style","position","zIndex","backgroundColor","image","undefined","color","top","centerY","window","innerHeight","left","centerX","innerWidth","src","transform","imageTransform","GetTileCoord","Math","floor","GetRoomCoord","tileCoord","HasRoomOrCreate","tile","coord","create","doors","has","newCoord","hasCoord","fillCoord","CollideWithWalls","createOnDoor","hT","hD","doorSize","hDX","hDY","roomX","roomY","leftWall","wallSize","rightWall","topWall","bottomWall","getCoord","hasDoor","abs","velocity","screenSize","max","tileViewDist","ceil","addEventListener","console","log","GridTile","a","b","overlayMode","cameraCoord","display","justifyContent","alignItems","info","map","d","opened","hasNeighbor","getWallPosition","size","bottom","right","GridWall","row","filler","flex","flexDirection","overflow","cursor","onClick","RenderApp","Tile","initialDoors","rotation","this","Set","neededDoors","neededWalls","canPlace","forEach","r","t","rotate","rotatedDoors","door","add","allDirections","index","indexOf","length","Rotate","FourWay","TeeWay","Straight","LTurn","RTurn","DeadEnd","AllWay","copy","TwoWay","TileLibrary","Index","FirstFloor","grid","Map","getTile","get","hasTile","setTile","alert","set","fillTile","neighbor","Opposite","matchingTiles","filter","newTile","random","Array","from","fog","ctx","rayStep","rayLength","angleSize","PI","shootRay","start","stepVector","ray","toScreenSpot","UpdateFog","player","document","getElementById","getContext","clearRect","rayPoints","points","angle","push","cos","sin","shootRaysInCircle","fillStyle","strokeStyle","beginPath","playerCoord","moveTo","point","p","lineTo","stroke","fill","mass","kid_green","Player","showMap","canvasStyle","leftPressed","upPressed","rightPressed","downPressed","mPressed","e","key","animate","players","i","ApplyFriction","requestAnimationFrame","App","React","useState","setState","rerender","useCallback","useEffect","className","padding","id","opacity","mixBlendMode","tiles","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.2dfb1120.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAyCAYAAACpgnCWAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpaVUHCwo4pChOlkQv3CUKhbBQmkrtOpgcumH0KQhSXFxFFwLDn4sVh1cnHV1cBUEwQ8QJ0cnRRcp8X9JoUWMB8f9eHfvcfcOEBoVpppdY4CqWUY6ERdz+RUx8IoQ+hFAEFMSM/VkZiELz/F1Dx9f72I8y/vcn6NHKZgM8InEs0w3LOJ14ulNS+e8TxxhZUkhPiceNeiCxI9cl11+41xyWOCZESObniOOEIulDpY7mJUNlXiSOKqoGuULOZcVzluc1UqNte7JXxguaMsZrtMcQgKLSCIFETJq2EAFFmK0aqSYSNN+3MM/6PhT5JLJtQFGjnlUoUJy/OB/8Ltbszgx7iaF40D3i21/DAOBXaBZt+3vY9tungD+Z+BKa/urDWDmk/R6W4seAb3bwMV1W5P3gMsdYOBJlwzJkfw0hWIReD+jb8oDfbdAaNXtrbWP0wcgS10t3QAHh8BIibLXPN4d7Ozt3zOt/n4Ahodyr3VoJPUAAAAGYktHRAANAJMAAP6GeWcAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfkChcHEiZpyWcYAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAB/ZJREFUWMPtl2twlNUZx3/nveTda3azySZLINAgJAEviMUK1KB4aStVa4s61WnHqlXasbHTi6Mf6jidcVrttDpT6tQZx+ZDrXZwxhkvaBUBKQKCsQFBxBgvJAFCLhuybzZ7ed/3nH5gN2TXGAkzfvP5tHsu7/88//M8/+c5IryeL900+ArkK5AvyYyZLJ611a8Bs4HLgQQCpZviIyGQQB7Bpt4V47kvBGn6IKwB1cBwV7Mty6YbgY1AMwAKvLw69TG/+M+cnYFfejnVfWx1Rk4J0rgvGPZ09QBwhZORr819O/DW4Ae5jvql/pxuiMEx4f5UqZMAokC0mnQMN6O+IzTeEhorgUNTgmi6uEs3xW8AdFNfAlDbYg1JVw27GXnUDGlz8gXnlJyaUiWp0k3R3vRBeHVXs50F0K01pxaEDxv7paQWxQJNFxaAYWkBwxA1YZ/RKExRrUQpRVOaYA4C23/I2DXW6KoSkL6HnJw/zqsgXtd04pohWopzDgolwLAEhiWICJ1xp9QdIYrugMyr1dJTT6fnu8kSEGsNZJqlZ89z++KjvhfjjuZboKwVMauCiKYzIt0irXg+MHwCw6ehPFDehBcT7Cvwp+e7L4rpVLhtb/3V8Zj/Rd3SUArGpceY5xHQdWzPRc8rQn6TE47DkbEcewbskv1WWDtSEdYaSzwpt+XHw4cdV+13smphTS6SUISoVn4i4wa5tMPI8DiLzVqW+KqJBjU1L2wJnyE4Op4HoCIgKjVTvDQtyO6E7e2qTb3n/JPEynOWXvpUlYEZXMZSrYIDlVFOhBpYYcWp8yQx5ReWKagJGbSEAwQ1zfEJrS1leC+flqz8rLVp2SJ9jDtyirOcJKbMIAyDXGUVmhAIICBNYtKPEBDzm5wbCXd8LWM90dVsO6clK4N29kBLXeTqc3MKlTsGKG5IG4zr41Q7p+6hxgtwQssyqKdxPXnwyeVH3dMWSDvn/rGjZ3jLyeBRCCAoXeLOKBpyktoKjg5lAQgFjK4ZqfCDVx1MDdjZ73f2JXdNHs86HurUQXhub0/3ps7+m6VUv9I08dhE/sykkfjtC83RsM+8P+d68xQsODBm+753Vn3T4nhEdA/aHX/Z/N71b/baveH1lGSpOJNuJfLuWbp/duAbVpXvkVv7xEXfIiIG3fzIloXqzlci6hiwpyu53TmjelK0ukvrK72c94hu6culocOnkK8xqg4FnWcLSx5qirU+DvR2JbfLGYE0xVqDSqp1XsZdq/uM5QCvRDxkI+wPSHqNCeG8D7gKuBbo+QyI3QZAALgC+BAYBdSPz5/lW/RD+adkjXH9bp9gvKBRoyA3RDwxoVqKcQQBYEmhgrYbZQDa+uvOO//sWZFn+1PZxgE7k9I1bVATyLqwP9I8HKhjGERTni0BWRRErUzmA5P+XdcUa91gdF4Uuxy4GHj0lgYntigR2RwP+aLxkA+IRoDITCj1KViaO4nbaclrs4LbDOB1gN4j7tWVIT1taiJa3HA8laHfzuI39WFN8HbWla811lfu+8hSAvg6sAr47mSQ8/KCW7srpC5Rr85zntwQ8f4xQVdVVFvm1qbY2zfCZc0JAA72j3L38/sxhQiGDHFgxJFPhNczxig0xVq3AifKQXpMsPEOVUt98VWfmr0PNryR1oD3ADo6c7yzV7L1w36Sha4mnT9ZpByl8iOOTJYxUw3cWE5XUlOkHCcDINTJpDSANYND3g/an8nOT46y8ZA+mv9v90B8yeyqc3Z/MrgLSAM28HHh90ScACMlSapg7YhBva4vKOS8O5HxdhsaEC6EK0UVKITzqUZjfUnOXGLAG42uoCEvsCQsTxrMS5YE26Ur527aZhQ2yyLANFZVPHlTrFUDVi10BLf1mMTt0igeqPDer83rbcDOL5SVgpdFG5s0NduEHy239RKArAnbZzts9DI794jdm09buyZR5EwavrjeE02NZR5sanB4vtIjOyZqmkKtZlEkp63xn2eVQyt7xtLB2mN1Yxdkg5KMBVvqXTaHJDkBWoXeArw0nOk5csYqnN7QcGEabu9YHH9st5ubb8zKLDHzsl6lK9DrRnGd/r/5EmbnGUt9bfs9fuDnAO7BwF0QwOmqmsRlLXZe5jLrXnDO6BEUffxOS0rnT8Ba1Oe13BDUG7fO+KW1s+dK8e99K6MLjeS9mmb+otD4aie7eLfbyaX2lL4OKlpmDPJ+/+hCYM+q+tTvS54JyntWSvcCpeSOsi0dMwJ5unNFNBa0Ns+tCi68pkXR6ju4XUrnr8DtQui3DN+x3p4nhiZKovRy9xeT8LQu3m5D4zb+UBf2zQH4ZDh1OFExfM3QTRtL1OHXFw7MqQxoDKfdse6BoecfWrPDOW1PbjovMT/rejcUakv/cTtz8WNruz8jP/2j9sd1wRSLa8dDaxb7/76z58rgtJ60N2zTgASwIHVzx70NRqpGDf6P4/bIw/dd9m7fVIfZ8fHgE7Gg9ZOzZ0UThia+6Ur18puHr3hQE+KNlXM3TdkLzwGeAlorW5bRB1jRBa6T3/FO2X1O2L/2Hfu0PuJfHfVXPDc7GlikG9aqXKTltdFY093tid89XtLctTds8wOPAuvKP5TPZf+8buDb93wete0N2/zjo8k2/9Dh+yvjiZBdOas4dVG5JzdOBQBgVljvTwNgAvcGIrEHiMSwTx3s7QrL12lMUVI/QznwjBDimWliZCnwQPmgbpgP39p7ifN/jBc0XdEwO3oAAAAASUVORK5CYII=\"","import { Direction } from './Direction';\r\n\r\nexport interface Coord {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport function MoveCoord(c: Coord, direction: Direction): Coord {\r\n  const { x, y } = c;\r\n  // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return { x, y: y - 1 };\r\n    case \"BOTTOM\":\r\n      return { x, y: y + 1 };\r\n    case \"RIGHT\":\r\n      return { x: x + 1, y };\r\n    case \"LEFT\":\r\n      return { x: x - 1, y };\r\n  }\r\n}\r\n\r\nexport function MidPoint(a: Coord, b: Coord) {\r\n  return {\r\n    x: (a.x + b.x) / 2,\r\n    y: (a.y + b.y) / 2,\r\n  };\r\n}\r\n\r\n// Distances ordered by their stupidness\r\nexport function Distance(a: Coord, b: Coord) {\r\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\r\n}\r\n\r\nexport function HammingDistance(a: Coord, b: Coord) {\r\n  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n}\r\n\r\nexport function EitherDirectionDistance(a: Coord, b: Coord) {\r\n  return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\r\n}","import * as React from 'react';\r\nimport { centerY, centerX } from '../App';\r\nimport { Coord } from \"./Coord\";\r\n\r\nexport interface Item {\r\n    position: Coord;\r\n    height: number;\r\n    width: number;\r\n\r\n    name?: string;\r\n    color?: string; // TODO this should be an image or graphic or canvas dude!\r\n\r\n    mass: number;\r\n    velocity: Coord;\r\n    image?: string;\r\n    imageTransform?: string;\r\n}\r\n\r\nexport function ToBoundingBox(item: Item) {\r\n    return {\r\n        x: item.position.x - item.width * .5,\r\n        y: item.position.y - item.height * .5,\r\n        height: item.height,\r\n        width: item.width,\r\n    };\r\n}\r\n\r\n/* Check two items for collision! */\r\nexport function RectangleCollision(a: Item, b: Item) {\r\n    const rect1 = ToBoundingBox(a);\r\n    const rect2 = ToBoundingBox(b);\r\n    return rect1.x < rect2.x + rect2.width &&\r\n        rect1.x + rect1.width > rect2.x &&\r\n        rect1.y < rect2.y + rect2.height &&\r\n        rect1.y + rect1.height > rect2.y;\r\n}\r\n\r\nvar items: Item[] = [];\r\n\r\n// yo if we stored these BY room it would be pretty cool.\r\nexport function AddItem(item: Item) {\r\n    items.push(item);\r\n}\r\n\r\nexport function GetItems() {\r\n    return items;\r\n}\r\n\r\nexport const itemZindex = 50;\r\n\r\nexport function GridItem(props: { item: Item, zIndex?: number }) {\r\n    const { item } = props;\r\n    const hW = item.width * .5;\r\n    const hH = item.height * .5;\r\n\r\n    return <div\r\n        title={item.name}\r\n        style={{\r\n            position: \"absolute\",\r\n            zIndex: props.zIndex || itemZindex,\r\n            height: item.height,\r\n            width: item.width,\r\n            backgroundColor: item.image ? undefined : item.color || \"grey\",\r\n            top: item.position.y - centerY + (.5 * window.innerHeight) - hH,\r\n            left: item.position.x - centerX + (.5 * window.innerWidth) - hW,\r\n        }}>\r\n            {item.image ? <img src={item.image} style={{transform: item.imageTransform}} /> : null}\r\n    </div>;\r\n}\r\n\r\n/*\r\nAddItem({\r\n    position: { x: Math.random() * 600 - 300, y: Math.random() * 400 - 200 },\r\n    height: 15,\r\n    width: 20,\r\n    color: \"green\",\r\n    name: \"purse\",\r\n    mass: 4,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n\r\nAddItem({\r\n    position: { x: Math.random() * 200 - 100, y: Math.random() * 400 - 200 },\r\n    height: 20,\r\n    width: 20,\r\n    color: \"brown\",\r\n    name: \"Box\",\r\n    mass: 15,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n\r\n\r\nAddItem({\r\n    position: { x: Math.random() * 200 - 100, y: Math.random() * 800 - 400 },\r\n    height: 10,\r\n    width: 10,\r\n    color: \"gold\",\r\n    name: \"pocketwatch\",\r\n    mass: .5,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n\r\nAddItem({\r\n    position: { x: Math.random() * 200 - 100, y: Math.random() * 800 - 400 },\r\n    height: 70,\r\n    width: 40,\r\n    color: \"tan\",\r\n    name: \"Table\",\r\n    mass: 70,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n*/","\r\n// ok how can we do... intersections and interactions?\r\n// #1 only can hit things in your room (or very rarely a neighboring room that is close by..)\r\n\r\nimport { doorSize, wallSize } from \"../GridTile\";\r\nimport { Coord, MidPoint, MoveCoord } from \"./Coord\";\r\nimport { Direction } from \"./Direction\";\r\nimport { Floor } from \"./Floor\";\r\nimport { GetItems, Item, RectangleCollision } from \"./Items\";\r\nimport { tileSize } from \"./Size\";\r\nimport { Tile } from \"./Tile\";\r\n\r\n/** The TILE the item is in. */\r\nexport function GetTileCoord(c: Coord): Coord {\r\n    const hT = .5 * tileSize;\r\n    const x = Math.floor((c.x + hT) / tileSize);\r\n    const y = Math.floor((c.y + hT) / tileSize);\r\n    return { x, y };\r\n}\r\n\r\n/** The relative place in the current TILE the item is in. */\r\nexport function GetRoomCoord(item: Item, tileCoord: Coord): Coord {\r\n    const x = item.position.x - (tileCoord.x * tileSize);\r\n    const y = item.position.y - (tileCoord.y * tileSize);\r\n    return { x, y };\r\n}\r\n\r\nconst doorEdgeSize = 3;\r\n\r\nexport function GetWallCorners(){\r\n    // ray trace to all of these basically?\r\n}\r\nexport function HasRoomOrCreate(floor: Floor|undefined, tile:Tile|undefined, coord: Coord, direction: Direction, create: boolean) {\r\n    const hasDoor = tile && tile.doors.has(direction);\r\n\r\n    if (!hasDoor) { return false; }\r\n\r\n    const newCoord = MoveCoord(coord, direction);\r\n    if (!floor?.hasCoord(newCoord)) {\r\n        if(create){\r\n            floor?.fillCoord(newCoord);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\nexport function CollideWithWalls(item: Item, floor?: Floor, createOnDoor = false): boolean {\r\n    const hT = .5 * tileSize;\r\n    const hW = .5 * item.width;\r\n    const hH = .5 * item.height;\r\n    const hD = .5 * doorSize;\r\n\r\n    const hDX = hD - hW;\r\n    const hDY = hD - hH;\r\n\r\n    // which TILE is it in?\r\n\r\n    const tileCoord = GetTileCoord(item.position);\r\n    const { x: roomX, y: roomY } = GetRoomCoord(item, tileCoord);\r\n\r\n    const leftWall = hW + wallSize - hT;\r\n    const rightWall = -1 * leftWall;\r\n    const topWall = hH + wallSize - hT;\r\n    const bottomWall = -1 * topWall;\r\n\r\n    const tile = floor?.getCoord(tileCoord);\r\n\r\n    // If you are inside the wall boundary\r\n    if (roomX <= leftWall) {\r\n        // AND you are outside of the door area (or there is no door):\r\n        // Push you back to the edge of the wall.\r\n        const hasDoor = HasRoomOrCreate(floor, tile, tileCoord, \"LEFT\", createOnDoor);\r\n        if (Math.abs(roomY) > hDY || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomY > 0){\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.x += leftWall - roomX;\r\n            item.velocity.x = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomX >= rightWall) {\r\n        const hasDoor = HasRoomOrCreate(floor, tile, tileCoord, \"RIGHT\", createOnDoor);\r\n        if (Math.abs(roomY) > hDY || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomY > 0){\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.x += rightWall - roomX;\r\n            item.velocity.x = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY <= topWall) {\r\n        const hasDoor = HasRoomOrCreate(floor, tile, tileCoord, \"TOP\", createOnDoor);\r\n        if (Math.abs(roomX) > hDX || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomX > 0){\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.y += topWall - roomY;\r\n            item.velocity.y = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY >= bottomWall) {\r\n        const hasDoor = HasRoomOrCreate(floor, tile, tileCoord, \"BOTTOM\", createOnDoor);\r\n        if (Math.abs(roomX) > hDX || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomX > 0){\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.y += bottomWall - roomY;\r\n            item.velocity.y = 0;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function ApplyFriction(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach(item => {\r\n        if (item.velocity) {\r\n            if (item.velocity.x) {\r\n                item.velocity.x *= .9;\r\n                if (Math.abs(item.velocity.x) < .1) { item.velocity.x = 0; }\r\n            }\r\n            if (item.velocity.y) {\r\n                item.velocity.y *= .9;\r\n                if (Math.abs(item.velocity.y) < .1) { item.velocity.y = 0; }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function InelasticCollision(a: Item, b: Item) {\r\n    // final velocity\r\n    const x = (a.mass * a.velocity.x + b.mass * b.velocity.x) / (a.mass + b.mass);\r\n    const y = (a.mass * a.velocity.y + b.mass * b.velocity.y) / (a.mass + b.mass);\r\n\r\n    // step back their velocities a bit??\r\n\r\n    const fudge = .2;\r\n    a.position.x -= a.velocity.x * fudge;\r\n    a.position.y -= a.velocity.y * fudge;\r\n    b.position.x -= b.velocity.x * fudge;\r\n    b.position.y -= b.velocity.y * fudge;\r\n\r\n    // and we want to PUSH them out so they are not colliding.\r\n    // How can we do that? Ideally we would like factor in the faces, but for laziness\r\n    // we could just push opposite the direction?\r\n    a.velocity.x = x;\r\n    a.velocity.y = y;\r\n    b.velocity.x = x;\r\n    b.velocity.y = y;\r\n}\r\n\r\nexport function CollideItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach((item, i) => {\r\n        if (i < items.length - 1) {\r\n            for (let j = i + 1; j < items.length; j++) {\r\n                if (RectangleCollision(item, items[j])) {\r\n                    //console.log(\"COLLISION!\", item.name, items[j].name);\r\n                    // TODO: update velocity and stuff??\r\n                    InelasticCollision(item, items[j]);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function MoveItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach((item, i) => {\r\n        if (item.velocity.x) {\r\n            item.position.x += item.velocity.x;\r\n        }\r\n        if (item.velocity.y) {\r\n            item.position.y += item.velocity.y;\r\n        }\r\n    });\r\n}","export const tileSize = 400;\r\n","import React from 'react';\r\nimport { EitherDirectionDistance, HammingDistance, MoveCoord } from './tiles/Coord';\r\nimport { Direction, AllDirections } from './tiles/Direction';\r\nimport { Tile } from './tiles/Tile';\r\nimport { centerY, centerX, RenderApp } from './App';\r\nimport { Floor } from \"./tiles/Floor\";\r\nimport { GetTileCoord } from './tiles/Collision';\r\nimport { tileSize } from './tiles/Size';\r\n\r\nexport const wallSize = 12;\r\nexport const doorSize = 100;\r\n\r\n// probably only update this on resize\r\nvar screenSize = Math.max(window.innerWidth, window.innerHeight);\r\nexport var tileViewDist = Math.ceil(screenSize / (2 * tileSize));\r\n\r\nwindow.addEventListener('resize', ()=>{\r\n  screenSize = Math.max(window.innerWidth, window.innerHeight);\r\n  tileViewDist = Math.ceil(screenSize / (2 * tileSize));\r\n  console.log(\"Updated view dist\", tileViewDist);\r\n});\r\n\r\nconsole.log(\"Initial view dist\", tileViewDist);\r\n\r\nexport const GridTile: React.FC<{ tile: Tile; floor: Floor; overlayMode: boolean}> = props => {\r\n  const { tile, floor, overlayMode } = props;\r\n\r\n  // check screen space if we should render it!\r\n  const tileCoord = { x: tile.x, y: tile.y };\r\n  const cameraCoord = GetTileCoord({ x: centerX, y: centerY });\r\n  if (EitherDirectionDistance(tileCoord, cameraCoord) > tileViewDist) {\r\n    return null;\r\n  }\r\n\r\n  return <div\r\n    style={{\r\n      zIndex: overlayMode ? 10 : 4,\r\n      position: \"absolute\",\r\n      height: tileSize,\r\n      width: tileSize,\r\n      top: tile.y! * tileSize + .5 * (window.innerHeight - tileSize) - centerY,\r\n      left: tile.x! * tileSize + .5 * (window.innerWidth - tileSize) - centerX,\r\n      display: \"flex\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      color: \"white\",\r\n      //border: '5px solid black',\r\n      backgroundColor:  overlayMode ? undefined : \"#663333\",\r\n    }}>\r\n    {tile.info.name}\r\n    {AllDirections().map(d => <GridWall\r\n      overlayMode={overlayMode}\r\n      tile={tile}\r\n      floor={floor}\r\n      direction={d}\r\n      hasDoor={tile.doors.has(d)}\r\n      opened={tile.hasNeighbor(floor, d)}\r\n    />)}\r\n  </div>;\r\n}\r\n\r\nfunction getWallPosition(direction: Direction, size: number) {\r\n  let top: string | number = 0;\r\n  let bottom: string | number = 0;\r\n  let left: string | number = 0;\r\n  let right: string | number = 0;\r\n\r\n  let width: number | undefined = size;\r\n  let height: number | undefined = size;\r\n\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      bottom = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"BOTTOM\":\r\n      top = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"RIGHT\":\r\n      left = \"auto\";\r\n      height = undefined;\r\n      break;\r\n    case \"LEFT\":\r\n      right = \"auto\";\r\n      height = undefined;\r\n      break;\r\n  }\r\n\r\n  return { top, bottom, left, right, width, height };\r\n}\r\n\r\nexport const GridWall: React.FC<{ overlayMode: boolean, tile: Tile; floor: Floor; direction: Direction; hasDoor: boolean; opened: boolean; }> = props => {\r\n  const { direction, opened, hasDoor, tile, floor, overlayMode } = props;\r\n  const row = direction === \"TOP\" || direction === \"BOTTOM\";\r\n  const filler = <div style={{ \r\n    flex: \"auto\",\r\n     backgroundColor: \"#322\",\r\n      height: row ? \"100%\" : undefined, width: row ? undefined : \"100%\" }}></div>;\r\n\r\n  return <div\r\n    style={{\r\n      ...getWallPosition(direction, overlayMode ? 3 : wallSize),\r\n      position: \"absolute\",\r\n      display: \"flex\",\r\n      flexDirection: row ? \"row\" : \"column\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      overflow: \"hidden\",\r\n    }}>\r\n    {filler}\r\n    {hasDoor ?\r\n      <div\r\n        style={{ \r\n          cursor: opened ? undefined : \"pointer\",\r\n           height: doorSize, \r\n           width: doorSize,\r\n            backgroundColor: opened ? \"\" : \"grey\" }}\r\n        onClick={opened ? undefined : () => {\r\n          floor.fillCoord(MoveCoord(tile.coord, direction));\r\n          RenderApp();\r\n        }}\r\n      >\r\n      </div>\r\n      : null}\r\n    {filler}\r\n  </div>;\r\n};\r\n","export type Direction = \"TOP\" | \"LEFT\" | \"RIGHT\" | \"BOTTOM\";\r\n\r\nexport function AllDirections(): Direction[] {\r\n  return [\"TOP\", \"RIGHT\", \"BOTTOM\", \"LEFT\"];\r\n}\r\n\r\nexport function Opposite(direction: Direction): Direction {\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return \"BOTTOM\";\r\n    case \"BOTTOM\":\r\n      return \"TOP\";\r\n    case \"RIGHT\":\r\n      return \"LEFT\";\r\n    case \"LEFT\":\r\n      return \"RIGHT\";\r\n  }\r\n}\r\n\r\nexport function Rotate(direction: Direction, rotation: number) {\r\n  const allDirections = AllDirections();\r\n  const index = allDirections.indexOf(direction);\r\n  return allDirections[(index + rotation) % allDirections.length];\r\n}\r\n","import { Coord, MoveCoord } from './Coord';\r\nimport { Direction, Rotate } from './Direction';\r\nimport { Floor } from './Floor';\r\n\r\ninterface TileInfo {\r\n  name: string;\r\n\r\n  doors: Direction[];\r\n}\r\n\r\nexport class Tile {\r\n  // Rotations RIGHT in 90 increments. 0-3;\r\n  //public rotation = 0; // TODO\r\n  public x = 0;\r\n  public y = 0;\r\n  private initialDoors: Set<Direction>;\r\n  private rotation = 0;\r\n\r\n  constructor(public readonly info: TileInfo) {\r\n    const { doors } = info;\r\n    this.initialDoors = new Set<Direction>(doors);\r\n  }\r\n\r\n  get coord(): Coord {\r\n    return { x: this.x, y: this.y };\r\n  }\r\n\r\n  get doors(): Set<Direction> {\r\n    const rotatedDoors = new Set<Direction>();\r\n    this.initialDoors.forEach(door => { rotatedDoors.add(Rotate(door, this.rotation)); });\r\n    return rotatedDoors;\r\n  }\r\n\r\n  /** Return valid rotations for the tile to be placed in a spot with the given constraints. */\r\n  // TODO: Handle ROTATION PROBABLY!\r\n  canPlace(neededDoors: Set<Direction>, neededWalls: Set<Direction>): boolean {\r\n    // TODO: Wait what about WALLS where we SHOULDNT have doors!\r\n    // ensure all needed doors are there\r\n    let canPlace = true;\r\n    neededDoors.forEach(direction => {\r\n      if (!this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    // ensure all needed walls have no doors!\r\n    neededWalls.forEach(direction => {\r\n      if (this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    return canPlace;\r\n  }\r\n\r\n  copy(r?: number) {\r\n    const t = new Tile(this.info);\r\n    if (r) {\r\n      t.rotate(r);\r\n    }\r\n    else {\r\n      t.rotate(this.rotation);\r\n    }\r\n    return t;\r\n  }\r\n\r\n  rotate(r: number) {\r\n    this.rotation = r % 4;\r\n    return this;\r\n  }\r\n\r\n  hasNeighbor(floor: Floor, direction: Direction): boolean {\r\n    // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n    return floor.hasCoord(MoveCoord(this.coord, direction));\r\n  }\r\n}\r\n","import { Tile } from './Tile';\r\n\r\nexport const FourWay = new Tile({ name: \"Fourway\", doors: [\"TOP\", \"LEFT\", \"RIGHT\", \"BOTTOM\"] });\r\nconst TeeWay = new Tile({ name: \"TeeWay\", doors: [\"TOP\", \"LEFT\", \"RIGHT\"] });\r\nconst Straight = new Tile({ name: \"Straight\", doors: [\"TOP\", \"BOTTOM\"] });\r\nconst LTurn = new Tile({ name: \"LTurn\", doors: [\"TOP\", \"RIGHT\"] });\r\nconst RTurn = new Tile({ name: \"RTurn\", doors: [\"TOP\", \"LEFT\"] });\r\nconst DeadEnd = new Tile({ name: \"DeadEnd\", doors: [\"TOP\"] });\r\n\r\nfunction AllWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1), tile.copy(2), tile.copy(3)];\r\n}\r\n\r\nfunction TwoWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1)];\r\n}\r\n\r\nexport const TileLibrary = [\r\n  ...TwoWay(FourWay),\r\n  ...TwoWay(Straight),\r\n  ...AllWay(TeeWay),\r\n  ...AllWay(LTurn),\r\n  ...AllWay(RTurn),\r\n  ...AllWay(DeadEnd),\r\n];\r\n","import { Coord, MoveCoord } from './Coord';\r\nimport { Direction, AllDirections, Opposite } from './Direction';\r\nimport { Tile } from './Tile';\r\nimport { TileLibrary, FourWay } from './RegisterTiles';\r\n\r\nexport function IndexCoord(c: Coord) { return Index(c.x, c.y); }\r\nexport function Index(x: number, y: number) { return `${x}, ${y}`; }\r\n\r\nexport class Floor {\r\n  constructor(public readonly name: string) { }\r\n\r\n  private grid = new Map<string, Tile>();\r\n\r\n  getCoord(c: Coord): Tile | undefined { return this.getTile(c.x, c.y); }\r\n  getTile(x: number, y: number): Tile | undefined { return this.grid.get(Index(x, y)); }\r\n\r\n  hasCoord(c: Coord): boolean { return this.hasTile(c.x, c.y); }\r\n  hasTile(x: number, y: number): boolean { return this.grid.has(Index(x, y)); }\r\n\r\n  setCoord(tile: Tile, c: Coord) { this.setTile(tile, c.x, c.y); }\r\n  setTile(tile: Tile, x: number, y: number) {\r\n    if (this.hasTile(x, y)) {\r\n      alert(\"Already had a tile there!\");\r\n      throw \"already had a tile!\";\r\n    }\r\n\r\n    tile.x = x;\r\n    tile.y = y;\r\n    this.grid.set(Index(x, y), tile);\r\n  }\r\n\r\n  get tiles(): Tile[] {\r\n    return Array.from(this.grid, ([key, tile]) => tile);\r\n  }\r\n\r\n  // return all POSSIBLE playing places\r\n  getValidSpotsForTiles() {\r\n    // this is maybe not the best approach. Cool ,but not needed right now...\r\n  }\r\n\r\n  fillCoord(c: Coord) { this.fillTile(c.x, c.y); }\r\n  fillTile(x: number, y: number) {\r\n    // fill a gap with a VALID tile. Woops do we need rotation soon?\r\n    // 1. get all tiles bordering this.\r\n    const neighbors = AllDirections().map(d => this.getCoord(MoveCoord({ x, y }, d)));\r\n    const neededDoors = new Set<Direction>();\r\n    const neededWalls = new Set<Direction>();\r\n\r\n    AllDirections().forEach(direction => {\r\n      const neighbor = this.getCoord(MoveCoord({ x, y }, direction));\r\n      if (neighbor) {\r\n        if (neighbor.doors.has(Opposite(direction))) {\r\n          neededDoors.add(direction);\r\n        }\r\n        else {\r\n          neededWalls.add(direction);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Find possible tiles\r\n    // TODO: Factor in floor type and stuff.\r\n    const matchingTiles = TileLibrary.filter(tile => tile.canPlace(neededDoors, neededWalls));\r\n\r\n    // Pick a random tile from the possible ones.\r\n    if (!matchingTiles) { throw \"wow we should really fix that!\"; }\r\n\r\n    const newTile = matchingTiles[Math.floor(Math.random() * matchingTiles.length)].copy();\r\n    this.setTile(newTile, x, y);\r\n  }\r\n}\r\n\r\nexport const FirstFloor = new Floor(\"Main Floor\");\r\nFirstFloor.setTile(FourWay.copy(), 0, 0);\r\n","// anything beyond this we don't need to render.\r\n\r\nimport { centerX, centerY } from \"../App\";\r\nimport { doorSize, tileViewDist, wallSize } from \"../GridTile\";\r\nimport { GetTileCoord, GetRoomCoord, CollideWithWalls } from \"./Collision\";\r\nimport { Coord, MoveCoord } from \"./Coord\";\r\nimport { Direction } from \"./Direction\";\r\nimport { Floor } from \"./Floor\";\r\nimport { Item } from \"./Items\";\r\nimport { tileSize } from \"./Size\";\r\n\r\n// As long as we factor in their size as well...\r\nexport const sightDistance = 400;\r\n\r\nvar fog: HTMLCanvasElement;\r\nvar ctx: CanvasRenderingContext2D;\r\nwindow.addEventListener('resize', () => {\r\n    fog.width = window.innerWidth;\r\n    fog.height = window.innerHeight;\r\n    //UpdateFog();\r\n});\r\n\r\n// terrible stripped down version of the actual collide item with wall function\r\nexport function IsInWall(c: Coord, floor?: Floor) {\r\n    const hT = .5 * tileSize;\r\n    const hW = 1;\r\n    const hH = 1;\r\n    const hD = .5 * doorSize;\r\n\r\n    const hDX = hD - hW;\r\n    const hDY = hD - hH;\r\n\r\n    // which TILE is it in?\r\n\r\n    const tileCoord = GetTileCoord(c);\r\n    const { x: roomX, y: roomY } = GetRoomCoord({ position: c } as Item, tileCoord);\r\n\r\n    const leftWall = hW + wallSize - hT;\r\n    const rightWall = -1 * leftWall;\r\n    const topWall = hH + wallSize - hT;\r\n    const bottomWall = -1 * topWall;\r\n\r\n    const tile = floor?.getCoord(tileCoord);\r\n\r\n    //hasDoor={tile.doors.has(d)}\r\n    //opened={tile.hasNeighbor(floor, d)}\r\n\r\n    function HasRoom(coord: Coord, direction: Direction) {\r\n        const hasDoor = tile && tile.doors.has(direction);\r\n\r\n        if (!hasDoor) { return false; }\r\n\r\n        const newCoord = MoveCoord(coord, direction);\r\n        return floor?.hasCoord(newCoord);\r\n    }\r\n\r\n    // TODO: Stop weirdness at the EDGE of doors.\r\n\r\n    // If you are inside the wall boundary\r\n    if (roomX <= leftWall) {\r\n        // AND you are outside of the door area (or there is no door):\r\n        // Push you back to the edge of the wall.\r\n        if (Math.abs(roomY) > hDY || !HasRoom(tileCoord, \"LEFT\")) {\r\n            return true;\r\n        }\r\n    }\r\n    if (roomX >= rightWall) {\r\n        if (Math.abs(roomY) > hDY || !HasRoom(tileCoord, \"RIGHT\")) {\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY <= topWall) {\r\n        if (Math.abs(roomX) > hDX || !HasRoom(tileCoord, \"TOP\")) {\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY >= bottomWall) {\r\n        if (Math.abs(roomX) > hDX || !HasRoom(tileCoord, \"BOTTOM\")) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // tile\r\n}\r\n\r\n\r\n/** Returns where this hits a wall! */\r\nconst rayStep = wallSize;\r\nvar rayLength = 10 + tileViewDist * tileSize / rayStep; //was like 75 or 100;\r\nconsole.log(\"ray length\", rayLength);\r\nwindow.addEventListener('resize', () => {\r\n    rayLength = 10 + tileViewDist * tileSize / rayStep;\r\n    console.log(\"ray length\", rayLength);\r\n});\r\n// 20 is ok, 60 is good, \r\nconst angleSize = Math.PI / 100;\r\n\r\n// dude you could probably just CALCULATE (DO the math bro! it's faster) the next time the ray would = .5 tilesize  % tilesize\r\nexport function shootRay(start: Coord, stepVector: Coord, floor: Floor): Coord {\r\n    // assume vector is the RIGHT length\r\n    let length = 0;\r\n    let ray = { x: start.x, y: start.y };\r\n    while (!CollideWithWalls({ position: ray, height: 1, width: 1, velocity: { x: 0, y: 0 } } as Item, floor)\r\n        && length < rayLength) {\r\n        ray.x += stepVector.x;\r\n        ray.y += stepVector.y;\r\n        length++;\r\n    }\r\n\r\n    return ray;\r\n}\r\n// PI/10 is clunky, PI/20 is pretty dang smooth.\r\nexport function shootRaysInCircle(start: Coord, floor: Floor) {\r\n    const points: Coord[] = [];\r\n    let angle = 0;\r\n    while (angle < Math.PI * 2) {\r\n        points.push(shootRay(start, {\r\n            x: Math.cos(angle) * rayStep,\r\n            y: Math.sin(angle) * rayStep,\r\n        }, floor));\r\n        angle += angleSize;\r\n    }\r\n    return points;\r\n}\r\n\r\nfunction toScreenSpot(c: Coord): Coord {\r\n    return {\r\n        x: c.x - centerX + (.5 * window.innerWidth),\r\n        y: c.y - centerY + (.5 * window.innerHeight),\r\n    }\r\n}\r\n\r\nexport function UpdateFog(player: Item, floor: Floor) {\r\n\r\n    if (!ctx) {\r\n        fog = document.getElementById(\"fog\") as HTMLCanvasElement;\r\n        if (!fog) { return; }\r\n        fog.width = window.innerWidth;\r\n        fog.height = window.innerHeight;\r\n\r\n        ctx = fog.getContext(\"2d\")!;\r\n        if (!ctx) { return; }\r\n    }\r\n\r\n    //fog.style.opacity = \".5\";\r\n    ctx.clearRect(0, 0, fog.width, fog.height);\r\n\r\n    const rayPoints = shootRaysInCircle(player.position, floor);\r\n\r\n    ctx.fillStyle = \"lightyellow\";\r\n    ctx.strokeStyle = \"1px lightyellow\";\r\n    ctx.beginPath();\r\n    const playerCoord = toScreenSpot(player.position);\r\n    ctx.moveTo(playerCoord.x, playerCoord.y);\r\n    rayPoints.forEach(point => {\r\n        const p = toScreenSpot(point);\r\n        ctx.lineTo(p.x, p.y);\r\n    });\r\n    const p = toScreenSpot(rayPoints[0]);\r\n    ctx.lineTo(p.x, p.y);\r\n    ctx.stroke();\r\n    ctx.fill();\r\n\r\n    // draw LINES to the wall edge. E.G.\r\n    // we need the player spot and the WALL corners.\r\n\r\n}\r\n\r\nfunction sourceInTest() {\r\n    // TEST ONLY\r\n\r\n    /*\r\n    This would be  the HTML to add in the app:\r\n     <canvas id=\"canvas_map\"\r\n              width={window.innerWidth}\r\n              height={window.innerHeight}\r\n              style={canvasStyle} />\r\n              <canvas id=\"canvas_sightlines\"\r\n                 width={window.innerWidth}\r\n                 height={window.innerHeight}\r\n                 style={canvasStyle} />\r\n                 <canvas id=\"canvas_result\"\r\n                    width={window.innerWidth}\r\n                    height={window.innerHeight}\r\n                    style={canvasStyle} />\r\n    */\r\n    const sightCv = document.getElementById(\"canvas_sightlines\") as HTMLCanvasElement;\r\n    const mapCv = document.getElementById(\"canvas_map\") as HTMLCanvasElement;\r\n    const resultCv = document.getElementById(\"canvas_result\") as HTMLCanvasElement;\r\n\r\n    if (!sightCv) { return; }\r\n\r\n    const sight_ctx = sightCv.getContext(\"2d\")!;\r\n    const map_ctx = mapCv.getContext(\"2d\")!;\r\n    const result_ctx = resultCv.getContext(\"2d\")!;\r\n\r\n    // draw a \"map tile\"\r\n    map_ctx.fillStyle = \"grey\";\r\n    map_ctx.fillRect(window.innerWidth / 2 - 200, window.innerHeight / 2 - 200, 400, 400);\r\n    map_ctx.fillStyle = \"#442222\";\r\n    map_ctx.fillRect(window.innerWidth / 2 - 150, window.innerHeight / 2 - 150, 300, 300);\r\n\r\n    // draw the \"sight line\"\r\n\r\n    sight_ctx.fillStyle = \"yellow\";\r\n    sight_ctx.strokeStyle = \"1px solid yellow\";\r\n    sight_ctx.beginPath();\r\n    sight_ctx.moveTo(window.innerWidth / 2, window.innerHeight / 2);\r\n    sight_ctx.lineTo(200, 200);\r\n    sight_ctx.fill();\r\n    sight_ctx.lineTo(200, 400);\r\n    sight_ctx.fill();\r\n    sight_ctx.lineTo(window.innerWidth / 2, window.innerHeight / 2);\r\n    sight_ctx.arc(window.innerWidth / 2, window.innerHeight / 2, 100, 0, Math.PI * 2)\r\n    sight_ctx.fill();\r\n    sight_ctx.stroke();\r\n    //sight_ctx.fillRect(window.innerWidth / 2-100, window.innerHeight / 2-100, 200,200);\r\n\r\n    // create the result\r\n    result_ctx.drawImage(sightCv, 0, 0);\r\n    result_ctx.globalCompositeOperation = \"source-in\";\r\n    result_ctx.drawImage(mapCv, 0, 0);\r\n\r\n    // hide the other canvases\r\n\r\n    sightCv.style.display = \"none\";\r\n    mapCv.style.display = \"none\";\r\n\r\n\r\n    // END TEST\r\n}","import React from 'react';\r\nimport { GridItem, Item } from \"./tiles/Items\";\r\nimport kid_green from \"./images/players/kid_green.png\";\r\n\r\nexport const player: Item = {\r\n  position: { x: 0, y: 0 },\r\n  height: 50,\r\n  width: 25,\r\n  color: \"red\",\r\n  name: \"You\",\r\n  velocity: { x: 0, y: 0 },\r\n  mass: 140,\r\n  image: kid_green,\r\n};\r\n\r\nexport const playerZindex = 51;\r\n\r\nexport function Player() {\r\n  return <GridItem item={player} zIndex={playerZindex} />\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport { GridTile } from './GridTile';\nimport { ApplyFriction, CollideItems, CollideWithWalls, MoveItems } from './tiles/Collision';\nimport { FirstFloor, Index } from './tiles/Floor';\nimport { sightDistance, UpdateFog } from './tiles/SightLines';\nimport { Player, player } from './Player';\nimport { GetItems, GridItem, Item } from './tiles/Items';\n\nexport let centerX = 0;\nexport let centerY = 0;\n\nexport var RenderApp = () => { };\n\nvar showMap = false;\nvar showFog = true; // turn off for now.. Sightlines would be cool, but circle looks dumb.\nconst canvasStyle:React.CSSProperties = {\n  position: \"absolute\",\n            zIndex: 5,\n            width: \"100%\",\n            height: \"100%\",\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n};\n\nfunction App() {\n  const [, setState] = React.useState(0);\n  const rerender = React.useCallback(() => {\n    setState(Math.random());\n  }, [setState]);\n\n  React.useEffect(() => { RenderApp = rerender; }, [rerender]);\n\n  return (\n    <div className=\"App\" style={{ overflow: \"hidden\" }}>\n      {showMap ?\n        <div style={{ zIndex: 100, bottom: 0, padding: 20, position: \"absolute\", left: 0, right: 0 }}>\n          <div style={{ color: \"white\" }}>Map</div>\n          <button onClick={() => { centerY -= 100; rerender(); }}>UP!</button>\n          <button onClick={() => { centerY += 100; rerender(); }}>DOWN!</button>\n          <button onClick={() => { centerX -= 100; rerender(); }}>LEFT!</button>\n          <button onClick={() => { centerX += 100; rerender(); }}>RIGHT!</button>\n          <button onClick={() => { centerX = 0; centerY = 0; rerender(); }}>CENTER!</button>\n        </div> : null}\n      <Player />\n\n      <div>\n\n        {showFog ? <canvas id=\"fog\"\n          width={window.innerWidth}\n          height={window.innerHeight}\n          style={{\n            ...canvasStyle,\n            opacity: .2,\n            //mixBlendMode: \"multiply\",\n            filter: \"blur(5px)\",\n          }} /> : null}\n\n        <div id=\"gamefloor\" style={{ mixBlendMode: \"normal\" }}>\n\n          {FirstFloor.tiles.map((tile) => <GridTile\n            overlayMode={showMap}\n            floor={FirstFloor}\n            tile={tile}\n            key={Index(tile.x, tile.y)}\n          />)}\n\n          {GetItems().map((item) => <GridItem item={item} />)}\n\n        </div>\n      </div>\n\n    </div>\n  );\n}\n\nlet leftPressed = false;\nlet upPressed = false;\nlet rightPressed = false;\nlet downPressed = false;\n\nlet mPressed = false;\n\ndocument.addEventListener('keydown', e => {\n  if (e.key === \"m\" || e.key === \"M\") {\n    if (!mPressed) { showMap = !showMap; }\n    mPressed = true;\n  }\n\n  if (e.key === \"a\" || e.key === \"A\" || e.key === \"ArrowLeft\") {\n    leftPressed = true;\n    rightPressed = false;\n  }\n  if (e.key === \"d\" || e.key === \"D\" || e.key === \"ArrowRight\") {\n    rightPressed = true;\n    leftPressed = false;\n  }\n  if (e.key === \"w\" || e.key === \"W\" || e.key === \"ArrowUp\") {\n    upPressed = true;\n    downPressed = false;\n  }\n  if (e.key === \"s\" || e.key === \"S\" || e.key === \"ArrowDown\") {\n    downPressed = true;\n    upPressed = false;\n  }\n});\n\ndocument.addEventListener('keyup', e => {\n  //console.log(e.key);\n  if (e.key === \"a\" || e.key === \"A\" || e.key === \"ArrowLeft\") {\n    leftPressed = false;\n  }\n  if (e.key === \"d\" || e.key === \"D\" || e.key === \"ArrowRight\") {\n    rightPressed = false;\n  }\n  if (e.key === \"w\" || e.key === \"W\" || e.key === \"ArrowUp\") {\n    upPressed = false;\n  }\n  if (e.key === \"s\" || e.key === \"S\" || e.key === \"ArrowDown\") {\n    downPressed = false;\n  }\n  if (e.key === \"m\" || e.key === \"M\") {\n    mPressed = false;\n  }\n});\n\nconst moveSpeed = 2;\nconst playerAccel = .3;\nconst mapSpeed = 7;\n\nfunction animate() {\n  if (showMap) {\n    if (leftPressed) {\n      centerX -= mapSpeed;\n    }\n    if (rightPressed) {\n      centerX += mapSpeed;\n    }\n    if (upPressed) {\n      centerY -= mapSpeed;\n    }\n    if (downPressed) {\n      centerY += mapSpeed;\n    }\n  }\n  else {\n    player.velocity = player.velocity || { x: 0, y: 0 };\n    if (leftPressed && player.velocity.x > -moveSpeed) {\n      //player.position.x -= moveSpeed;\n      player.velocity.x -= playerAccel;\n      player.imageTransform = undefined;\n    }\n    if (rightPressed && player.velocity.x < moveSpeed) {\n      //player.position.x += moveSpeed;\n      player.velocity.x += playerAccel;\n      player.imageTransform = \"scale(-1,1)\";\n    }\n    if (upPressed && player.velocity.y > -moveSpeed) {\n      //player.position.y -= moveSpeed;\n      player.velocity.y -= playerAccel;\n    }\n    if (downPressed && player.velocity.y < moveSpeed) {\n      //player.position.y += moveSpeed;\n      player.velocity.y += playerAccel;\n    }\n  }\n\n  // for now we are assuming the player is ALWAYS centered. \n  // This is probably bad and we may want to change it when we switch to a canvas based approach.\n  MoveItems([player]);\n  CollideWithWalls(player, FirstFloor, true);\n  //GetItems().forEach(item => CollideWithWalls(item, FirstFloor));\n  //CollideItems([player]);\n  ApplyFriction([player]);\n\n  // FOLLOW CAM\n  if (!showMap) {\n    centerX = player.position.x;\n    centerY = player.position.y;\n  }\n\n  //TODO: later. \n  showFog && UpdateFog(player, FirstFloor);\n  RenderApp();\n  requestAnimationFrame(() => animate());\n}\n\nanimate();\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker === null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}