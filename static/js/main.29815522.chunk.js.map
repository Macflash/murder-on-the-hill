{"version":3,"sources":["tiles/Coord.ts","GridTile.tsx","tiles/Direction.ts","tiles/Tile.ts","tiles/RegisterTiles.ts","tiles/Floor.ts","App.tsx","tiles/Collision.ts","serviceWorker.ts","index.tsx"],"names":["MoveCoord","c","direction","x","y","GridTile","props","tile","floor","style","position","height","tileSize","width","top","window","innerHeight","centerY","left","innerWidth","centerX","display","justifyContent","alignItems","color","backgroundColor","info","name","map","d","hasDoor","doors","has","opened","hasNeighbor","getWallPosition","bottom","right","undefined","GridWall","row","filler","flex","flexDirection","overflow","cursor","onClick","fillCoord","coord","RenderApp","Tile","initialDoors","rotation","this","Set","neededDoors","neededWalls","canPlace","forEach","r","t","rotate","hasCoord","rotatedDoors","door","add","allDirections","index","indexOf","length","Rotate","FourWay","TeeWay","Straight","LTurn","RTurn","DeadEnd","AllWay","copy","TwoWay","TileLibrary","FirstFloor","grid","Map","getTile","get","hasTile","setTile","alert","set","fillTile","getCoord","neighbor","Opposite","console","log","matchingTiles","filter","newTile","Math","random","Array","from","player","Player","hW","hH","zIndex","leftPressed","upPressed","rightPressed","downPressed","document","addEventListener","e","key","animate","item","hT","tileX","tileY","roomX","roomY","leftWall","rightWall","topWall","bottomWall","tileCoord","HasRoomOrCreate","newCoord","abs","CollidePlayerWithWalls","requestAnimationFrame","App","React","useState","setState","rerender","useCallback","useEffect","className","id","tiles","p","i","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.29815522.chunk.js","sourcesContent":["import { Direction } from './Direction';\r\n\r\nexport interface Coord {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport function MoveCoord(c: Coord, direction: Direction): Coord {\r\n  const { x, y } = c;\r\n  // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return { x, y: y - 1 };\r\n    case \"BOTTOM\":\r\n      return { x, y: y + 1 };\r\n    case \"RIGHT\":\r\n      return { x: x + 1, y };\r\n    case \"LEFT\":\r\n      return { x: x - 1, y };\r\n  }\r\n}\r\n","import React from 'react';\r\nimport { MoveCoord } from './tiles/Coord';\r\nimport { Direction, AllDirections } from './tiles/Direction';\r\nimport { Tile } from './tiles/Tile';\r\nimport { tileSize, centerY, centerX, RenderApp } from './App';\r\nimport { Floor } from \"./tiles/Floor\";\r\n\r\nexport const wallSize = 10;\r\nexport const doorSize = 48;\r\n\r\nexport const GridTile: React.FC<{ tile: Tile; floor: Floor; }> = props => {\r\n  const { tile, floor } = props;\r\n\r\n  // todo draw stuff for each EDGE!\r\n  return <div\r\n    style={{\r\n      position: \"absolute\",\r\n      height: tileSize,\r\n      width: tileSize,\r\n      top: tile.y! * tileSize + .5 * (window.innerHeight - tileSize) - centerY,\r\n      left: tile.x! * tileSize + .5 * (window.innerWidth - tileSize) - centerX,\r\n      display: \"flex\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      color: \"white\",\r\n      //border: '5px solid black',\r\n      backgroundColor: \"#663333\",\r\n    }}>\r\n    {tile.info.name}\r\n    {AllDirections().map(d => <GridWall\r\n      tile={tile}\r\n      floor={floor}\r\n      direction={d}\r\n      hasDoor={tile.doors.has(d)}\r\n      opened={tile.hasNeighbor(floor, d)}\r\n    />)}\r\n  </div>;\r\n}\r\n\r\nfunction getWallPosition(direction: Direction) {\r\n  let top: string | number = 0;\r\n  let bottom: string | number = 0;\r\n  let left: string | number = 0;\r\n  let right: string | number = 0;\r\n\r\n  let width: number | undefined = wallSize;\r\n  let height: number | undefined = wallSize;\r\n\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      bottom = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"BOTTOM\":\r\n      top = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"RIGHT\":\r\n      left = \"auto\";\r\n      height = undefined;\r\n      break;\r\n    case \"LEFT\":\r\n      right = \"auto\";\r\n      height = undefined;\r\n      break;\r\n  }\r\n\r\n  return { top, bottom, left, right, width, height };\r\n}\r\n\r\nexport const GridWall: React.FC<{ tile: Tile; floor: Floor; direction: Direction; hasDoor: boolean; opened: boolean; }> = props => {\r\n  const { direction, opened, hasDoor, tile, floor } = props;\r\n  const row = direction == \"TOP\" || direction == \"BOTTOM\";\r\n  const filler = <div style={{ flex: \"auto\", backgroundColor: \"#322\", height: row ? \"100%\" : undefined, width: row ? undefined : \"100%\" }}></div>;\r\n\r\n  return <div\r\n    style={{\r\n      ...getWallPosition(direction),\r\n      position: \"absolute\",\r\n      display: \"flex\",\r\n      flexDirection: row ? \"row\" : \"column\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      //backgroundColor: \"black\",\r\n      overflow: \"hidden\",\r\n    }}>\r\n    {filler}\r\n    {hasDoor ?\r\n      <div\r\n        style={{ cursor: opened ? undefined : \"pointer\", height: doorSize, width: doorSize, backgroundColor: opened ? \"\" : \"grey\" }}\r\n        onClick={opened ? undefined : () => {\r\n          // TODO: add a NEW tile that like.. matches the constraints!\r\n          // for now... FOURWAY!  \r\n          floor.fillCoord(MoveCoord(tile.coord, direction));\r\n          //floor.setCoord(FourWay.create(), Offset(tile.coord, direction));\r\n          RenderApp();\r\n        }}\r\n      >\r\n      </div>\r\n      : null}\r\n    {filler}\r\n  </div>;\r\n};\r\n","export type Direction = \"TOP\" | \"LEFT\" | \"RIGHT\" | \"BOTTOM\";\r\n\r\nexport function AllDirections(): Direction[] {\r\n  return [\"TOP\", \"RIGHT\", \"BOTTOM\", \"LEFT\"];\r\n}\r\n\r\nexport function Opposite(direction: Direction): Direction {\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return \"BOTTOM\";\r\n    case \"BOTTOM\":\r\n      return \"TOP\";\r\n    case \"RIGHT\":\r\n      return \"LEFT\";\r\n    case \"LEFT\":\r\n      return \"RIGHT\";\r\n  }\r\n}\r\n\r\nexport function Rotate(direction: Direction, rotation: number) {\r\n  const allDirections = AllDirections();\r\n  const index = allDirections.indexOf(direction);\r\n  return allDirections[(index + rotation) % allDirections.length];\r\n}\r\n","import { Coord, MoveCoord } from './Coord';\r\nimport { Direction, Rotate } from './Direction';\r\nimport { Floor } from './Floor';\r\n\r\ninterface TileInfo {\r\n  name: string;\r\n\r\n  doors: Direction[];\r\n}\r\n\r\nexport class Tile {\r\n  // Rotations RIGHT in 90 increments. 0-3;\r\n  //public rotation = 0; // TODO\r\n  public x = 0;\r\n  public y = 0;\r\n  private initialDoors: Set<Direction>;\r\n  private rotation = 0;\r\n\r\n  constructor(public readonly info: TileInfo) {\r\n    const { doors } = info;\r\n    this.initialDoors = new Set<Direction>(doors);\r\n  }\r\n\r\n  get coord(): Coord {\r\n    return { x: this.x, y: this.y };\r\n  }\r\n\r\n  get doors(): Set<Direction> {\r\n    const rotatedDoors = new Set<Direction>();\r\n    this.initialDoors.forEach(door => { rotatedDoors.add(Rotate(door, this.rotation)); });\r\n    return rotatedDoors;\r\n  }\r\n\r\n  /** Return valid rotations for the tile to be placed in a spot with the given constraints. */\r\n  // TODO: Handle ROTATION PROBABLY!\r\n  canPlace(neededDoors: Set<Direction>, neededWalls: Set<Direction>): boolean {\r\n    // TODO: Wait what about WALLS where we SHOULDNT have doors!\r\n    // ensure all needed doors are there\r\n    let canPlace = true;\r\n    neededDoors.forEach(direction => {\r\n      if (!this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    // ensure all needed walls have no doors!\r\n    neededWalls.forEach(direction => {\r\n      if (this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    return canPlace;\r\n  }\r\n\r\n  copy(r?: number) {\r\n    const t = new Tile(this.info);\r\n    if (r) {\r\n      t.rotate(r);\r\n    }\r\n    else {\r\n      t.rotate(this.rotation);\r\n    }\r\n    return t;\r\n  }\r\n\r\n  rotate(r: number) {\r\n    this.rotation = r % 4;\r\n    return this;\r\n  }\r\n\r\n  hasNeighbor(floor: Floor, direction: Direction): boolean {\r\n    // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n    return floor.hasCoord(MoveCoord(this.coord, direction));\r\n  }\r\n}\r\n","import { Tile } from './Tile';\r\n\r\nexport const FourWay = new Tile({ name: \"Fourway\", doors: [\"TOP\", \"LEFT\", \"RIGHT\", \"BOTTOM\"] });\r\nconst TeeWay = new Tile({ name: \"TeeWay\", doors: [\"TOP\", \"LEFT\", \"RIGHT\"] });\r\nconst Straight = new Tile({ name: \"Straight\", doors: [\"TOP\", \"BOTTOM\"] });\r\nconst LTurn = new Tile({ name: \"LTurn\", doors: [\"TOP\", \"RIGHT\"] });\r\nconst RTurn = new Tile({ name: \"RTurn\", doors: [\"TOP\", \"LEFT\"] });\r\nconst DeadEnd = new Tile({ name: \"DeadEnd\", doors: [\"TOP\"] });\r\n\r\nfunction AllWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1), tile.copy(2), tile.copy(3)];\r\n}\r\n\r\nfunction TwoWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1)];\r\n}\r\n\r\nexport const TileLibrary = [\r\n  ...TwoWay(FourWay),\r\n  ...TwoWay(Straight),\r\n  ...AllWay(TeeWay),\r\n  ...AllWay(LTurn),\r\n  ...AllWay(RTurn),\r\n  ...AllWay(DeadEnd),\r\n];\r\n","import { Coord, MoveCoord } from './Coord';\r\nimport { Direction, AllDirections, Opposite } from './Direction';\r\nimport { Tile } from './Tile';\r\nimport { TileLibrary, FourWay } from './RegisterTiles';\r\n\r\nexport class Floor {\r\n  constructor(public readonly name: string) { }\r\n\r\n  private grid = new Map<string, Tile>();\r\n\r\n  private index(x: number, y: number) { return `${x}, ${y}`; }\r\n\r\n  getCoord(c: Coord): Tile | undefined { return this.getTile(c.x, c.y); }\r\n  getTile(x: number, y: number): Tile | undefined { return this.grid.get(this.index(x, y)); }\r\n\r\n  hasCoord(c: Coord): boolean { return this.hasTile(c.x, c.y); }\r\n  hasTile(x: number, y: number): boolean { return this.grid.has(this.index(x, y)); }\r\n\r\n  setCoord(tile: Tile, c: Coord) { this.setTile(tile, c.x, c.y); }\r\n  setTile(tile: Tile, x: number, y: number) {\r\n    if (this.hasTile(x, y)) {\r\n      alert(\"Already had a tile there!\");\r\n      throw \"already had a tile!\";\r\n    }\r\n\r\n    tile.x = x;\r\n    tile.y = y;\r\n    this.grid.set(this.index(x, y), tile);\r\n  }\r\n\r\n  get tiles(): Tile[] {\r\n    return Array.from(this.grid, ([key, tile]) => tile);\r\n  }\r\n\r\n  // return all POSSIBLE playing places\r\n  getValidSpotsForTiles() {\r\n    // this is maybe not the best approach. Cool ,but not needed right now...\r\n  }\r\n\r\n  fillCoord(c: Coord) { this.fillTile(c.x, c.y); }\r\n  fillTile(x: number, y: number) {\r\n    // fill a gap with a VALID tile. Woops do we need rotation soon?\r\n    // 1. get all tiles bordering this.\r\n    const neighbors = AllDirections().map(d => this.getCoord(MoveCoord({ x, y }, d)));\r\n    const neededDoors = new Set<Direction>();\r\n    const neededWalls = new Set<Direction>();\r\n\r\n    AllDirections().forEach(direction => {\r\n      const neighbor = this.getCoord(MoveCoord({ x, y }, direction));\r\n      if (neighbor) {\r\n        if (neighbor.doors.has(Opposite(direction))) {\r\n          neededDoors.add(direction);\r\n        }\r\n        else {\r\n          neededWalls.add(direction);\r\n        }\r\n      }\r\n    });\r\n\r\n    console.log(\"fill tile needs these doors:\", neededDoors, \"and these walls:\", neededWalls);\r\n\r\n    // now find available tiles\r\n    const matchingTiles = TileLibrary.filter(tile => tile.canPlace(neededDoors, neededWalls));\r\n    console.log(\"These tiles could fit here!\", matchingTiles);\r\n    // pick a random tile!\r\n    if (!matchingTiles) { throw \"wow we should really fix that!\"; }\r\n\r\n    const newTile = matchingTiles[Math.floor(Math.random() * matchingTiles.length)].copy();\r\n    console.log(\"adding new tile!\", newTile);\r\n    this.setTile(newTile, x, y);\r\n  }\r\n}\r\n\r\nexport const FirstFloor = new Floor(\"Main Floor\");\r\nFirstFloor.setTile(FourWay.copy(), 0, 0);\r\n","import React from 'react';\nimport './App.css';\nimport { GridTile } from './GridTile';\nimport { CollidePlayerWithWalls, Item } from './tiles/Collision';\nimport { FirstFloor } from './tiles/Floor';\n\nexport const tileSize = 200;\nexport let centerX = 0;\nexport let centerY = 0;\n\nexport var RenderApp = () => { };\n\nconst player: Item = {\n  position: { x: 0, y: 0 },\n  height: 30,\n  width: 15,\n}\n\nfunction Player() {\n  const hW = player.width * .5;\n  const hH = player.height * .5;\n  return <div style={{\n    position: \"absolute\",\n    zIndex: 50,\n    height: player.height,\n    width: player.width,\n    backgroundColor: \"red\",\n    left: `calc(50% - ${hW}px)`,\n    right: `calc(50% + ${hW}px)`,\n    top: `calc(50% - ${hH}px)`,\n    bottom: `calc(50% + ${hH}px)`,\n  }}>\n  </div>;\n}\n\nfunction App() {\n  const [, setState] = React.useState(0);\n  const rerender = React.useCallback(() => {\n    setState(Math.random());\n  }, [setState]);\n\n  React.useEffect(() => { RenderApp = rerender; }, [rerender]);\n  return (\n    <div className=\"App\" style={{ overflow: \"hidden\" }}>\n\n      {/*\n      <div style={{ zIndex: 100, bottom: 0, padding: 20, position: \"absolute\", left: 0, right: 0 }}>\n        <button onClick={() => { centerY -= 100; rerender(); }}>UP!</button>\n        <button onClick={() => { centerY += 100; rerender(); }}>DOWN!</button>\n        <button onClick={() => { centerX -= 100; rerender(); }}>LEFT!</button>\n        <button onClick={() => { centerX += 100; rerender(); }}>RIGHT!</button> \n        <button onClick={() => { centerX = 0; centerY = 0; rerender(); }}>CENTER!</button>\n      </div>\n      */}\n      <Player />\n\n      <div id=\"gamefloor\">\n        {FirstFloor.tiles.map((p, i) => <GridTile floor={FirstFloor} tile={p} key={i} />)}\n      </div>\n\n    </div>\n  );\n}\n\nlet leftPressed = false;\nlet upPressed = false;\nlet rightPressed = false;\nlet downPressed = false;\n\ndocument.addEventListener('keydown', e => {\n  //console.log(e.key);\n  if (e.key == \"a\" || e.key == \"ArrowLeft\") {\n    leftPressed = true;\n    rightPressed = false;\n  }\n  if (e.key == \"d\" || e.key == \"ArrowRight\") {\n    rightPressed = true;\n    leftPressed = false;\n  }\n  if (e.key == \"w\" || e.key == \"ArrowUp\") {\n    upPressed = true;\n    downPressed = false;\n  }\n  if (e.key == \"s\" || e.key == \"ArrowDown\") {\n    downPressed = true;\n    upPressed = false;\n  }\n});\n\ndocument.addEventListener('keyup', e => {\n  //console.log(e.key);\n  if (e.key == \"a\" || e.key == \"ArrowLeft\") {\n    leftPressed = false;\n  }\n  if (e.key == \"d\" || e.key == \"ArrowRight\") {\n    rightPressed = false;\n  }\n  if (e.key == \"w\" || e.key == \"ArrowUp\") {\n    upPressed = false;\n  }\n  if (e.key == \"s\" || e.key == \"ArrowDown\") {\n    downPressed = false;\n  }\n});\n\nconst moveSpeed = 2;\n\nfunction animate() {\n  if (leftPressed) {\n    player.position.x -= moveSpeed;\n  }\n  if (rightPressed) {\n    player.position.x += moveSpeed;\n  }\n  if (upPressed) {\n    player.position.y -= moveSpeed;\n  }\n  if (downPressed) {\n    player.position.y += moveSpeed;\n  }\n\n  // for now we are assuming the player is ALWAYS centered. \n  // This is probably bad and we may want to change it when we switch to a canvas based approach.\n\n  CollidePlayerWithWalls(player, FirstFloor);\n\n  // FOLLOW CAM\n  centerX = player.position.x;\n  centerY = player.position.y;\n\n\n  RenderApp();\n  requestAnimationFrame(() => animate());\n}\n\nanimate();\n\nexport default App;\n","\r\n// ok how can we do... intersections and interactions?\r\n// #1 only can hit things in your room (or very rarely a neighboring room that is close by..)\r\n\r\nimport { tileSize } from \"../App\";\r\nimport { doorSize, wallSize } from \"../GridTile\";\r\nimport { Coord, MoveCoord } from \"./Coord\";\r\nimport { Direction } from \"./Direction\";\r\nimport { Floor } from \"./Floor\";\r\nimport { Tile } from \"./Tile\";\r\n\r\nexport interface Item {\r\n    position: Coord,\r\n    height: number,\r\n    width: number,\r\n\r\n    //    movable?: boolean, // can it be pushed?\r\n    //mass?: number, // how heavy is it?\r\n\r\n    // Oh? What, you didn't think we would do PHYSICS?\r\n    // Fuck yeah we will.\r\n    //speedX: number,\r\n    //speedY: number,\r\n}\r\n\r\nvar items: Item[] = [];\r\n// yo if we stored these BY room it would be pretty cool.\r\n\r\nexport function AddItem(item: Item) {\r\n    items.push(item);\r\n}\r\n\r\nexport function CollidePlayerWithWalls(item: Item, floor?: Floor) {\r\n    const hT = .5 * tileSize;\r\n    const hW = .5 * item.width;\r\n    const hH = .5 * item.height;\r\n    const hD = .5 * doorSize;\r\n\r\n    // which TILE is it in?\r\n    const tileX = Math.floor((item.position.x + hT) / tileSize);\r\n    const tileY = Math.floor((item.position.y + hT) / tileSize);\r\n\r\n\r\n    const roomX = item.position.x - (tileX * tileSize);\r\n    const roomY = item.position.y - (tileY * tileSize);\r\n\r\n    //console.log(`Tile: ${tileX},${tileY} at ${roomX},${roomY}`);\r\n\r\n    const leftWall = hW + wallSize - hT;\r\n    const rightWall = -1 * leftWall;\r\n    const topWall = hH + wallSize - hT;\r\n    const bottomWall = -1 * topWall;\r\n\r\n    const tileCoord = { x: tileX, y: tileY };\r\n    const tile = floor?.getCoord(tileCoord);\r\n\r\n    //hasDoor={tile.doors.has(d)}\r\n    //opened={tile.hasNeighbor(floor, d)}\r\n\r\n    function HasRoomOrCreate(coord: Coord, direction: Direction) {\r\n        const hasDoor = tile && tile.doors.has(direction);\r\n\r\n        if (!hasDoor) { return false; }\r\n\r\n        const newCoord = MoveCoord(coord, direction);\r\n        if (!floor?.hasCoord(newCoord)) {\r\n            floor?.fillCoord(newCoord);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // TODO: stop the item's actual move speed too.\r\n    // TODO: Stop weirdness at the EDGE of doors.\r\n    if (roomX <= leftWall) {\r\n        if (Math.abs(roomY) > hD || !HasRoomOrCreate(tileCoord, \"LEFT\")) {\r\n            item.position.x += leftWall - roomX;\r\n        }\r\n    }\r\n    if (roomX >= rightWall) {\r\n        if (Math.abs(roomY) > hD || !HasRoomOrCreate(tileCoord, \"RIGHT\")) {\r\n            item.position.x += rightWall - roomX;\r\n        }\r\n    }\r\n    if (roomY <= topWall) {\r\n        if (Math.abs(roomX) > hD || !HasRoomOrCreate(tileCoord, \"TOP\")) {\r\n            item.position.y += topWall - roomY;\r\n        }\r\n    }\r\n    if (roomY >= bottomWall) {\r\n        if (Math.abs(roomX) > hD || !HasRoomOrCreate(tileCoord, \"BOTTOM\")) {\r\n            item.position.y += bottomWall - roomY;\r\n        }\r\n    }\r\n\r\n    // tile\r\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}