{"version":3,"sources":["images/rooms/Kitchen.png","images/players/kid_green.png","tiles/Coord.ts","tiles/SightLines.ts","tiles/Size.ts","tiles/Items.tsx","tiles/Collision.ts","GridTile.tsx","tiles/Direction.ts","tiles/Tile.ts","tiles/Rooms.ts","tiles/Floor.ts","Player.tsx","tiles/Interaction.tsx","tiles/Inventory.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","MoveCoord","c","direction","x","y","Add","a","b","viewDist","screenSize","Math","max","window","innerWidth","innerHeight","ceil","GetTileViewDist","rayLength","console","log","addEventListener","angleSize","PI","shootRay","start","stepVector","floor","length","ray","CollideWithWalls","position","height","width","velocity","toScreenSpot","centerX","centerY","UpdateFogCanvas","ctx","player","clearRect","rayPoints","points","angle","push","cos","sin","shootRaysInCircle","ps","gradient","createRadialGradient","addColorStop","fillStyle","strokeStyle","beginPath","playerCoord","moveTo","forEach","point","p","lineTo","stroke","fill","PickUpItem","name","canDoOnGround","canDoInInventory","action","item","hidden","Error","inventory","DropItem","splice","indexOf","DisplayItemInfo","alert","description","CantDropItem","Map","ToBoundingBox","RectangleCollision","rect1","rect2","items","GetItems","filter","GridItem","props","tileOffset","hW","hH","title","style","zIndex","backgroundColor","image","undefined","color","top","left","src","transform","imageTransform","curesedKnife","mass","playerInteractions","watch","purse","random","CopyItem","GetTileCoord","GetRoomCoord","tileCoord","createOnDoor","hT","hD","hDX","hDY","roomX","roomY","leftWall","rightWall","topWall","bottomWall","tile","getCoord","hasDoor","hasDoorAndOpenIfNeeded_New","abs","doors","has","HasDoor","coord","newCoord","hasCoord","fillCoord","CreateRoomIfNeeded","GetItemsInInteractionDistance","i","sqrt","pow","UnmoveableCollision","moveable","unmoveable","overlapX","overlapY","max_objects_collided","tileViewDist","GridTile","overlayMode","cameraCoord","display","justifyContent","alignItems","info","map","d","opened","hasNeighbor","getWallPosition","size","bottom","right","GridWall","row","filler","flex","flexDirection","overflow","cursor","onClick","RenderApp","Tile","initialDoors","rotation","imageEl_","this","Set","neededDoors","neededWalls","canPlace","r","t","rotate","center","topCorner","GetTileTopAndLeft","drawImage","fillRect","tileSize","rotatedDoors","door","add","allDirections","index","Rotate","document","createElement","FourWay","Kitchen","blockObjects","TeeWay","Straight","LTurn","RTurn","DeadEnd","AllWay","copy","TwoWay","TileLibrary","createCanvas","id","canvas","getContext","resultCanvas","resultCtx","tileCanvas","tileCtx","sightCanvas","sightCtx","DoSightLineThing","tiles","drawToCanvas","DrawAllRooms","DrawSightCanvas","getElementById","save","globalCompositeOperation","restore","DrawResult","Index","body","append","FirstFloor","grid","getTile","get","hasTile","setTile","tileCenter","set","fillTile","neighbor","Opposite","matchingTiles","newTile","Array","from","kid_green","fear","health","intelligence","speed","spirit","strength","GridPlayer","interactables","toScreenPositionStyle","spot","MenuStyle","border","padding","InteractionButtons","inInventory","onGround","interaction","Interactions","textAlign","Inventory","maxWidth","maxHeight","showMap","canvasStyle","leftPressed","upPressed","rightPressed","downPressed","mPressed","e","key","animate","players","ApplyFriction","roomItems","j","item_unmoveable","other_unmoveable","CollideItems","requestAnimationFrame","App","React","useState","setState","rerender","useCallback","useEffect","className","mixBlendMode","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.de074ff8.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/Kitchen.a733900c.png\";","module.exports = \"data:image/png;base64,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\"","import { Direction } from './Direction';\r\n\r\nexport interface Coord {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport function MoveCoord(c: Coord, direction: Direction): Coord {\r\n  const { x, y } = c;\r\n  // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return { x, y: y - 1 };\r\n    case \"BOTTOM\":\r\n      return { x, y: y + 1 };\r\n    case \"RIGHT\":\r\n      return { x: x + 1, y };\r\n    case \"LEFT\":\r\n      return { x: x - 1, y };\r\n  }\r\n}\r\n\r\nexport function MidPoint(a: Coord, b: Coord) {\r\n  return {\r\n    x: (a.x + b.x) / 2,\r\n    y: (a.y + b.y) / 2,\r\n  };\r\n}\r\n\r\n\r\nexport function Copy(a: Coord) {\r\n  return {\r\n    x: (a.x),\r\n    y: (a.y),\r\n  };\r\n}\r\n\r\nexport function Add(a: Coord, b: Coord) {\r\n  return {\r\n    x: (a.x + b.x),\r\n    y: (a.y + b.y),\r\n  };\r\n}\r\n\r\nexport function Multiply(a: Coord, b: number) {\r\n  return {\r\n    x: (a.x * b),\r\n    y: (a.y * b),\r\n  };\r\n}\r\n\r\n// Distances ordered by their stupidness\r\nexport function Distance(a: Coord, b: Coord) {\r\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\r\n}\r\n\r\nexport function HammingDistance(a: Coord, b: Coord) {\r\n  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n}\r\n\r\nexport function EitherDirectionDistance(a: Coord, b: Coord) {\r\n  return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\r\n}","import { centerX, centerY } from \"../App\";\r\nimport { tileSize, wallSize } from \"./Size\";\r\nimport { CollideWithWalls } from \"./Collision\";\r\nimport { Coord } from \"./Coord\";\r\nimport { Floor } from \"./Floor\";\r\nimport { Item } from \"./Items\";\r\n\r\n// As long as we factor in their size as well...\r\nexport const sightDistance = 400;\r\nfunction GetTileViewDist(){\r\n    var screenSize = Math.max(window.innerWidth, window.innerHeight);\r\n    return Math.ceil(screenSize / (2 * tileSize));\r\n}\r\n\r\nvar viewDist = GetTileViewDist();\r\n\r\n/*\r\nvar fog: HTMLCanvasElement;\r\nvar ctx: CanvasRenderingContext2D;\r\nwindow.addEventListener('resize', () => {\r\n    if(!fog){ return; }\r\n    fog.width = window.innerWidth;\r\n    fog.height = window.innerHeight;\r\n    //UpdateFog();\r\n});\r\n*/\r\n\r\n/** Returns where this hits a wall! */\r\nconst rayStep = wallSize;\r\nvar rayLength = 10 + viewDist * tileSize / rayStep; //was like 75 or 100;\r\nconsole.log(\"ray length\", rayLength);\r\nwindow.addEventListener('resize', () => {\r\n    rayLength = 10 + viewDist * tileSize / rayStep;\r\n    console.log(\"ray length\", rayLength);\r\n});\r\n// 20 is ok, 60 is good, 120 is REAL fine. 200 cant really tell the difference.\r\nconst angleSize = Math.PI / 100;\r\n\r\n// dude you could probably just CALCULATE (DO the math bro! it's faster) the next time the ray would = .5 tilesize  % tilesize\r\nexport function shootRay(start: Coord, stepVector: Coord, floor: Floor): Coord {\r\n    // assume vector is the RIGHT length\r\n    let length = 0;\r\n    let ray = { x: start.x, y: start.y };\r\n    while (!CollideWithWalls({ position: ray, height: 1, width: 1, velocity: { x: 0, y: 0 } } as Item, floor)\r\n        && length < rayLength) {\r\n        ray.x += stepVector.x;\r\n        ray.y += stepVector.y;\r\n        length++;\r\n    }\r\n\r\n    return ray;\r\n}\r\n// PI/10 is clunky, PI/20 is pretty dang smooth.\r\nexport function shootRaysInCircle(start: Coord, floor: Floor) {\r\n    const points: Coord[] = [];\r\n    let angle = 0;\r\n    while (angle < Math.PI * 2) {\r\n        points.push(shootRay(start, {\r\n            x: Math.cos(angle) * rayStep,\r\n            y: Math.sin(angle) * rayStep,\r\n        }, floor));\r\n        angle += angleSize;\r\n    }\r\n    return points;\r\n}\r\n\r\nexport function toScreenSpot(c: Coord): Coord {\r\n    return {\r\n        x: c.x - centerX + (.5 * window.innerWidth),\r\n        y: c.y - centerY + (.5 * window.innerHeight),\r\n    }\r\n}\r\n\r\n/*\r\nexport function UpdateFog(player: Item, floor: Floor) {\r\n    if (!ctx) {\r\n        fog = document.getElementById(\"fog\") as HTMLCanvasElement;\r\n        if (!fog) { return; }\r\n        fog.width = window.innerWidth;\r\n        fog.height = window.innerHeight;\r\n\r\n        ctx = fog.getContext(\"2d\")!;\r\n        if (!ctx) { return; }\r\n    }\r\n    UpdateFogCanvas(ctx, player, floor);\r\n}*/\r\n\r\nexport function UpdateFogCanvas(ctx: CanvasRenderingContext2D, player: Item, floor: Floor) {\r\n    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n\r\n    const rayPoints = shootRaysInCircle(player.position, floor);\r\n    const ps = toScreenSpot(player.position);\r\n    const gradient = ctx.createRadialGradient(ps.x, ps.y,70, ps.x, ps.y, viewDist * tileSize);\r\n    gradient.addColorStop(0, \"lightyellow\");\r\n    gradient.addColorStop(.07, \"rgba(255,255,0,1)\");\r\n    gradient.addColorStop(.2, \"rgba(255,255,0,.8)\");\r\n    gradient.addColorStop(1, \"rgba(255,128,0,0)\");\r\n\r\n    ctx.fillStyle = gradient; // \"lightyellow\";\r\n    ctx.strokeStyle = \"1px lightyellow\";\r\n    ctx.beginPath();\r\n    const playerCoord = toScreenSpot(player.position);\r\n    ctx.moveTo(playerCoord.x, playerCoord.y);\r\n    rayPoints.forEach(point => {\r\n        const p = toScreenSpot(point);\r\n        ctx.lineTo(p.x, p.y);\r\n    });\r\n    const p = toScreenSpot(rayPoints[0]);\r\n    ctx.lineTo(p.x, p.y);\r\n    ctx.stroke();\r\n    ctx.fill();\r\n}","export const tileSize = 400;\r\nexport const wallSize = 12;\r\nexport const doorSize = 100;","import * as React from 'react';\r\nimport { centerY, centerX } from '../App';\r\nimport { Coord, Copy } from \"./Coord\";\r\nimport { toScreenSpot } from './SightLines';\r\n\r\nexport interface Item {\r\n    position: Coord;\r\n    height: number;\r\n    width: number;\r\n\r\n    name?: string;\r\n    description?: string;\r\n    color?: string; // TODO this should be an image or graphic or canvas dude!\r\n\r\n    /** Whether the item can be moved by being collided with */\r\n    moveable?: boolean; // this could probably be signaled by undefined VELOCITY? idk.. w/e\r\n\r\n    /** Whether player/other items can go through the item */\r\n    blockObjects?: boolean;\r\n\r\n    mass: number;\r\n    velocity: Coord;\r\n    image?: string;\r\n    imageTransform?: string;\r\n\r\n    hidden?: boolean;\r\n\r\n    playerInteractions?: PlayerItemInteraction[];\r\n}\r\n\r\n// TODO: actually do this stuff and like track some basic stats\r\nexport interface Player extends Item {\r\n    /**\r\n     * Items you are carrying.\r\n     * IDK do we need some kind of ACTIVE vs CARRIED distinction for some items,\r\n     * like you can't have 4 weapons at the same time\r\n     */\r\n    inventory: Item[];\r\n    health: number;\r\n    fear: number;\r\n    strength: number; // force when moving, affects carry strength\r\n    speed: number;\r\n    intelligence: number;\r\n    spirit: number; // like religion, spiritual strength. e/g/ won't be scared from weird shit dude.\r\n}\r\n\r\ninterface PlayerItemInteraction {\r\n    name: string,\r\n    canDoOnGround: boolean,\r\n    canDoInInventory: boolean,\r\n    action: PlayerItemInteraction_Action,\r\n}\r\n\r\nconst PickUpItem: PlayerItemInteraction = {\r\n    name: \"Pick up\",\r\n    canDoOnGround: true,\r\n    canDoInInventory: false,\r\n    action: (player, item) => {\r\n        if (item.hidden) {\r\n            throw new Error(\"Cant pick up a hidden item!!!\");\r\n        }\r\n        player.inventory.push(item);\r\n        item.hidden = true;\r\n    }\r\n}\r\n\r\nconst DropItem: PlayerItemInteraction = {\r\n    name: \"Drop\",\r\n    canDoOnGround: false,\r\n    canDoInInventory: true,\r\n    action: (player, item) => {\r\n        if (!item.hidden) {\r\n            throw new Error(\"Cant drop up a visible item!!!\");\r\n        }\r\n\r\n        item.position = Copy(player.position);\r\n        player.inventory.splice(player.inventory.indexOf(item), 1);\r\n        item.hidden = false;\r\n    }\r\n}\r\n\r\nconst DisplayItemInfo: PlayerItemInteraction = {\r\n    name: \"Info\",\r\n    canDoOnGround: true,\r\n    canDoInInventory: true,\r\n    action: (player, item) => {\r\n        alert(item.description);\r\n    }\r\n}\r\n\r\nconst CantDropItem: PlayerItemInteraction = {\r\n    name: \"Try to drop\",\r\n    canDoOnGround: false,\r\n    canDoInInventory: true,\r\n    action: (player, item) => {\r\n        alert(\"You can't put it down, it's as if it was part of you now.\");\r\n    }\r\n}\r\n\r\n\r\ntype PlayerItemInteraction_Action = (player: Player, item: Item) => void;\r\n\r\nvar drawnImages = new Map<string, HTMLImageElement>();\r\n\r\nexport function DrawItemToCtx(item: Item, ctx: CanvasRenderingContext2D){\r\n    const box = ToBoundingBox(item);\r\n    const screenC = toScreenSpot(box); // weird cast but ok duck typing do your thing\r\n    if (item.image) {\r\n        let imageEL = drawnImages.get(item.image);\r\n        if(!imageEL){\r\n            imageEL = document.createElement(\"img\") as HTMLImageElement;\r\n            imageEL.src=item.image;\r\n            drawnImages.set(item.image, imageEL);\r\n        }\r\n      ctx.drawImage(imageEL, screenC.x, screenC.y);\r\n    }\r\n    else {\r\n      ctx.fillStyle = item.color || \"grey\"; // grey..ish?\r\n      ctx.fillRect(screenC.x, screenC.y, box.width, box.height);\r\n    }\r\n}\r\n\r\nexport function ToBoundingBox(item: Item) {\r\n    return {\r\n        x: item.position.x - item.width * .5,\r\n        y: item.position.y - item.height * .5,\r\n        height: item.height,\r\n        width: item.width,\r\n    };\r\n}\r\n\r\n/* Check two items for collision! */\r\nexport function RectangleCollision(a: Item, b: Item) {\r\n    const rect1 = ToBoundingBox(a);\r\n    const rect2 = ToBoundingBox(b);\r\n    return rect1.x < rect2.x + rect2.width &&\r\n        rect1.x + rect1.width > rect2.x &&\r\n        rect1.y < rect2.y + rect2.height &&\r\n        rect1.y + rect1.height > rect2.y;\r\n}\r\n\r\nvar items: Item[] = [];\r\n\r\n// yo if we stored these BY room it would be pretty cool.\r\nexport function AddItem(item: Item) {\r\n    items.push(item);\r\n}\r\n\r\nexport function GetItems() {\r\n    return items.filter(item => !item.hidden);\r\n}\r\n\r\nexport const itemZindex = 50;\r\n\r\n\r\nexport function GridItem(props: { item: Item, zIndex?: number, tileOffset?: Coord }) {\r\n    const { item, tileOffset } = props;\r\n    const hW = item.width * .5;\r\n    const hH = item.height * .5;\r\n\r\n    return <div\r\n        title={item.name}\r\n        style={{\r\n            position: \"absolute\",\r\n            zIndex: props.zIndex || itemZindex,\r\n            height: item.height,\r\n            width: item.width,\r\n            backgroundColor: item.image ? undefined : item.color || \"grey\",\r\n            top: item.position.y - centerY + (.5 * window.innerHeight) - hH - (tileOffset?.y ||0),\r\n            left: item.position.x - centerX + (.5 * window.innerWidth) - hW - (tileOffset?.x ||0),\r\n        }}>\r\n        {item.image ? <img src={item.image} style={{ transform: item.imageTransform }} /> : null}\r\n    </div>;\r\n}\r\n\r\nexport const curesedKnife: Item = {\r\n    position: { x: 0, y: 30 },\r\n    height: 5,\r\n    width: 20,\r\n    color: \"red\",\r\n    name: \"Wicked Knife\",\r\n    mass: 5,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A sickening looking knife. You can't tell if that is blood or rust on the blade. Yet you feel oddly... compelled to pick it up.\",\r\n    playerInteractions: [PickUpItem, DisplayItemInfo, CantDropItem],\r\n};\r\n\r\nexport const watch: Item = {\r\n    position: { x: 150, y: 180 },\r\n    height: 15,\r\n    width: 20,\r\n    color: \"green\",\r\n    name: \"Purse\",\r\n    mass: 4,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A fancy purse. It looks old, who could have left it here?\",\r\n    playerInteractions: [PickUpItem, DisplayItemInfo, DropItem],\r\n};\r\n\r\nexport const box: Item = {\r\n    position: {x: 0, y: 40 },\r\n    height: 20,\r\n    width: 20,\r\n    color: \"brown\",\r\n    name: \"Box\",\r\n    mass: 15,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A closed cardboard box. It feels heavy. What could be inside?\",\r\n    playerInteractions: [PickUpItem,DisplayItemInfo, DropItem],\r\n};\r\n\r\n\r\nexport const purse: Item = {\r\n    position: {x: (Math.random() - .5) * 300, y: 150 },\r\n    height: 10,\r\n    width: 10,\r\n    color: \"gold\",\r\n    name: \"Watch\",\r\n    mass: .5,\r\n    velocity: { x: 0, y: 0 },\r\n    description: \"A small, worn pocketwatch. It looks like it is made of gold, but the time is stuck at midnight. What could happen if you wind it?\",\r\n    playerInteractions: [PickUpItem, DisplayItemInfo, DropItem],\r\n};\r\n\r\nexport const table: Item = {\r\n    position: { x: -70, y: -150 },\r\n    height: 70,\r\n    width: 40,\r\n    color: \"tan\",\r\n    name: \"Table\",\r\n    blockObjects: true,\r\n    mass: 70,\r\n    velocity: { x: 0, y: 0 },\r\n};\r\n\r\nexport function CopyItem(item: Item){\r\n    return {\r\n        ...item,\r\n        position: { ...item.position},\r\n        velocity: { ...item.velocity},\r\n    }\r\n}\r\n// */","\r\n// ok how can we do... intersections and interactions?\r\n// #1 only can hit things in your room (or very rarely a neighboring room that is close by..)\r\n\r\nimport { Coord, Distance, MoveCoord } from \"./Coord\";\r\nimport { Direction } from \"./Direction\";\r\nimport { Floor } from \"./Floor\";\r\nimport { GetItems, Item, RectangleCollision } from \"./Items\";\r\nimport { doorSize, wallSize, tileSize } from \"./Size\";\r\nimport { Tile } from \"./Tile\";\r\n\r\n/** The TILE the item is in. */\r\nexport function GetTileCoord(c: Coord): Coord {\r\n    const hT = .5 * tileSize;\r\n    const x = Math.floor((c.x + hT) / tileSize);\r\n    const y = Math.floor((c.y + hT) / tileSize);\r\n    return { x, y };\r\n}\r\n\r\n/** The relative place in the current TILE the item is in. */\r\nexport function GetRoomCoord(item: Item, tileCoord: Coord): Coord {\r\n    const x = item.position.x - (tileCoord.x * tileSize);\r\n    const y = item.position.y - (tileCoord.y * tileSize);\r\n    return { x, y };\r\n}\r\n\r\nconst doorEdgeSize = 3;\r\n\r\nexport function GetWallCorners() {\r\n    // ray trace to all of these basically?\r\n}\r\n\r\nexport function HasRoomOrCreate(floor: Floor | undefined, tile: Tile | undefined, coord: Coord, direction: Direction, create: boolean) {\r\n    const hasDoor = tile && tile.doors.has(direction);\r\n\r\n    if (!hasDoor) { return false; }\r\n\r\n    const newCoord = MoveCoord(coord, direction);\r\n    if (!floor?.hasCoord(newCoord)) {\r\n        if (create) {\r\n            floor?.fillCoord(newCoord);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function HasDoor(tile: Tile | undefined, direction: Direction) {\r\n    return tile && tile.doors.has(direction);\r\n}\r\n\r\nexport function CreateRoomIfNeeded(floor: Floor | undefined, coord: Coord, direction: Direction) {\r\n    const newCoord = MoveCoord(coord, direction);\r\n    if (!floor?.hasCoord(newCoord)) {\r\n        floor?.fillCoord(newCoord);\r\n    }\r\n}\r\n\r\nconst openDoorExtraSize = 10;\r\n\r\nexport function CollideWithWalls(item: Item, floor?: Floor, createOnDoor = false): boolean {\r\n    const hT = .5 * tileSize;\r\n    const hW = .5 * item.width;\r\n    const hH = .5 * item.height;\r\n    const hD = .5 * doorSize;\r\n\r\n    const hDX = hD - hW;\r\n    const hDY = hD - hH;\r\n\r\n    // which TILE is it in?\r\n\r\n    const tileCoord = GetTileCoord(item.position);\r\n    const { x: roomX, y: roomY } = GetRoomCoord(item, tileCoord);\r\n\r\n    const leftWall = hW + wallSize - hT;\r\n    const rightWall = -1 * leftWall;\r\n    const topWall = hH + wallSize - hT;\r\n    const bottomWall = -1 * topWall;\r\n\r\n    const tile = floor?.getCoord(tileCoord);\r\n\r\n    // If you are inside the wall boundary\r\n    if (roomX <= leftWall) {\r\n        // AND you are outside of the door area (or there is no door):\r\n        // Push you back to the edge of the wall.\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"LEFT\", tile, roomY, hDY, hH, createOnDoor, floor);\r\n        if (Math.abs(roomY) > hDY || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomY > 0) {\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.x += leftWall - roomX;\r\n            item.velocity.x = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomX >= rightWall) {\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"RIGHT\", tile, roomY, hDY, hH, createOnDoor, floor);\r\n        if (Math.abs(roomY) > hDY || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomY > 0) {\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.x += rightWall - roomX;\r\n            item.velocity.x = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY <= topWall) {\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"TOP\", tile, roomX, hDX, hW, createOnDoor, floor);\r\n        if (Math.abs(roomX) > hDX || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomX > 0) {\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.y += topWall - roomY;\r\n            item.velocity.y = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY >= bottomWall) {\r\n        const hasDoor = hasDoorAndOpenIfNeeded_New(\"BOTTOM\", tile, roomX, hDX, hW, createOnDoor, floor);\r\n        if (Math.abs(roomX) > hDX || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if (roomX > 0) {\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.y += bottomWall - roomY;\r\n            item.velocity.y = 0;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction hasDoorAndOpenIfNeeded_New(direction: Direction, tile: Tile | undefined, roomY: number, hDY: number, hH: number, createOnDoor: boolean, floor: Floor | undefined) {\r\n    const hasDoor = HasDoor(tile, direction);\r\n    if (Math.abs(roomY) <= (hDY + hH + 5) && hasDoor && createOnDoor) {\r\n        CreateRoomIfNeeded(floor, tile!, direction);\r\n    }\r\n    return hasDoor;\r\n}\r\n\r\nexport function ApplyFriction(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach(item => {\r\n        if (item.velocity) {\r\n            if (item.velocity.x) {\r\n                item.velocity.x *= .9;\r\n                if (Math.abs(item.velocity.x) < .1) { item.velocity.x = 0; }\r\n            }\r\n            if (item.velocity.y) {\r\n                item.velocity.y *= .9;\r\n                if (Math.abs(item.velocity.y) < .1) { item.velocity.y = 0; }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function InelasticCollision(a: Item, b: Item) {\r\n    // final velocity\r\n    const x = (a.mass * a.velocity.x + b.mass * b.velocity.x) / (a.mass + b.mass);\r\n    const y = (a.mass * a.velocity.y + b.mass * b.velocity.y) / (a.mass + b.mass);\r\n\r\n    // step back their velocities a bit??\r\n\r\n    const fudge = .2;\r\n    a.position.x -= a.velocity.x * fudge;\r\n    a.position.y -= a.velocity.y * fudge;\r\n    b.position.x -= b.velocity.x * fudge;\r\n    b.position.y -= b.velocity.y * fudge;\r\n\r\n    // and we want to PUSH them out so they are not colliding.\r\n    // How can we do that? Ideally we would like factor in the faces,d but for laziness\r\n    // we could just push opposite the direction?\r\n    a.velocity.x = x;\r\n    a.velocity.y = y;\r\n    b.velocity.x = x;\r\n    b.velocity.y = y;\r\n}\r\n\r\nexport const InteractionRange = 5;\r\nexport function GetItemsInInteractionDistance(player: Item, items: Item[]) {\r\n    return items.filter((item, i) => {\r\n        if (Distance(player.position, item.position) < InteractionRange + .4 * (item.width + item.height + player.width + player.height)) {\r\n            // how do we want to handle multiple items?\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    });\r\n}\r\n\r\nfunction UnmoveableCollision(moveable: Item, unmoveable: Item) {\r\n    // step BACKWARDS on the moveable item VELOCITY?\r\n    if (moveable.velocity.x === 0 && moveable.velocity.y === 0) {\r\n        // this is bad but moving you arbitrarily could be worse!! Don't want to go through walls or some crap\r\n        //    console.error(\"if you aren't moving you shouldn't have hit an item!!\");\r\n        //   return;\r\n    }\r\n\r\n    const overlapX = .5 * (moveable.width + unmoveable.width) - Math.abs(moveable.position.x - unmoveable.position.x);\r\n    const overlapY = .5 * (moveable.height + unmoveable.height) - Math.abs(moveable.position.y - unmoveable.position.y);\r\n\r\n    // do the smallest overlap to get back to normal?\r\n    if (overlapX <= overlapY) {\r\n        // just do that one!\r\n        if (moveable.position.x < unmoveable.position.x) {\r\n            moveable.position.x -= overlapX;\r\n            moveable.velocity.x = -overlapX; // LOL, the bounce is kind of fun. This should really be 0 for inelastic collision.\r\n        }\r\n        else {\r\n            moveable.position.x += overlapX;\r\n            moveable.velocity.x = overlapX;\r\n        }\r\n    }\r\n    else {\r\n        // just do that one!\r\n        if (moveable.position.y < unmoveable.position.y) {\r\n            moveable.position.y -= overlapY;\r\n            moveable.velocity.y = -overlapY;\r\n        }\r\n        else {\r\n            moveable.position.y += overlapY;\r\n            moveable.velocity.y = overlapY;\r\n        }\r\n    }\r\n\r\n    console.log(\"overlap\", overlapX, overlapY);\r\n\r\n    // shoot this doesn't figure out WHICH one it should do...\r\n    console.log(`${moveable.name} hit an unmoveable ${unmoveable.name}`);\r\n    /*\r\n    This is ok for 1D, but shoots people over walls in 2D....\r\n    // treat this just like a WALL!\r\n    if (moveable.position.x > unmoveable.position.x) {\r\n        moveable.position.x = unmoveable.position.x + .5 * (moveable.width + unmoveable.width);\r\n        //moveable.velocity.x = 0;\r\n    }\r\n    if (moveable.position.x <= unmoveable.position.x) {\r\n        moveable.position.x = unmoveable.position.x - .5 * (moveable.width + unmoveable.width);\r\n        //moveable.velocity.x = 0;\r\n    }\r\n    if (moveable.position.y > unmoveable.position.y) {\r\n        moveable.position.y = unmoveable.position.y + .5 * (moveable.height + unmoveable.height);\r\n        //moveable.velocity.y = 0;\r\n    }\r\n    if (moveable.position.y <= unmoveable.position.y) {\r\n        moveable.position.y = unmoveable.position.y - .5 * (moveable.height + unmoveable.height);\r\n        //moveable.velocity.y = 0;\r\n    } */\r\n}\r\n\r\nlet max_objects_collided = 0;\r\nexport function CollideItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()].filter(items => items.blockObjects || items.moveable);\r\n    if (items.length > max_objects_collided) {\r\n        console.log(`checking collisions for ${items.length} items`);\r\n        max_objects_collided = items.length;\r\n    }\r\n    //console.log(\"checking collisions for \", items.length);\r\n    items.forEach((item, i) => {\r\n        if (i < items.length - 1) {\r\n            for (let j = i + 1; j < items.length; j++) {\r\n                if (RectangleCollision(item, items[j])) {\r\n                    const item_unmoveable = item.blockObjects && !item.moveable;\r\n                    const other_unmoveable = items[j].blockObjects && !items[j].moveable\r\n                    if (item_unmoveable && !other_unmoveable) {\r\n                        UnmoveableCollision(items[j], item);\r\n                    }\r\n                    else if (!item_unmoveable && other_unmoveable) {\r\n                        UnmoveableCollision(item, items[j]);\r\n                    }\r\n                    // enable once NOT TERRIBLE InelasticCollision(item, items[j]);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function MoveItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach((item, i) => {\r\n        if (item.velocity.x) {\r\n            item.position.x += item.velocity.x;\r\n        }\r\n        if (item.velocity.y) {\r\n            item.position.y += item.velocity.y;\r\n        }\r\n    });\r\n}","import React from 'react';\r\nimport { Coord, EitherDirectionDistance, MoveCoord } from './tiles/Coord';\r\nimport { Direction, AllDirections } from './tiles/Direction';\r\nimport { Tile } from './tiles/Tile';\r\nimport { centerY, centerX, RenderApp } from './App';\r\nimport { Floor } from \"./tiles/Floor\";\r\nimport { GetTileCoord } from './tiles/Collision';\r\nimport { doorSize, tileSize, wallSize } from './tiles/Size';\r\nimport { GridItem } from './tiles/Items';\r\n\r\n// probably only update this on resize\r\nexport function GetTileViewDist(){\r\nvar screenSize = Math.max(window.innerWidth, window.innerHeight);\r\nreturn Math.ceil(screenSize / (2 * tileSize));\r\n}\r\n\r\nexport var tileViewDist = GetTileViewDist();\r\n\r\nconsole.log(\"grid tile tileViewDist\", tileViewDist);\r\n\r\nwindow.addEventListener('resize', ()=>{\r\n  tileViewDist = GetTileViewDist();\r\n});\r\n\r\nconsole.log(\"Initial view dist\", tileViewDist);\r\n\r\nexport function GetTileTopAndLeft(tileCoord: Coord, center: Coord){\r\n  return {\r\n    x: tileCoord.x * tileSize + .5 * (window.innerWidth - tileSize) - center.x,\r\n    y: tileCoord.y * tileSize + .5 * (window.innerHeight - tileSize) - center.y,\r\n  }\r\n}\r\n\r\nexport const GridTile: React.FC<{ tile: Tile; floor: Floor; overlayMode: boolean}> = props => {\r\n  const { tile, floor, overlayMode } = props;\r\n\r\n  // check screen space if we should render it!\r\n  const tileCoord = { x: tile.x, y: tile.y };\r\n  const cameraCoord = GetTileCoord({ x: centerX, y: centerY });\r\n  if (EitherDirectionDistance(tileCoord, cameraCoord) > tileViewDist) {\r\n    return null;\r\n  }\r\n\r\n  return <><div\r\n    style={{\r\n      zIndex: overlayMode ? 10 : 4,\r\n      position: \"absolute\",\r\n      height: tileSize,\r\n      width: tileSize,\r\n      top: tile.y! * tileSize + .5 * (window.innerHeight - tileSize) - centerY,\r\n      left: tile.x! * tileSize + .5 * (window.innerWidth - tileSize) - centerX,\r\n      display: \"flex\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      color: \"white\",\r\n      //border: '5px solid black',\r\n      backgroundColor:  overlayMode ? undefined : \"#663333\",\r\n      //backgroundImage: overlayMode ? undefined : `url(${tile.info.image})`,\r\n    }}>\r\n    {tile.info.name}\r\n    {AllDirections().map(d => <GridWall\r\n      overlayMode={overlayMode}\r\n      tile={tile}\r\n      floor={floor}\r\n      direction={d}\r\n      hasDoor={tile.doors.has(d)}\r\n      opened={tile.hasNeighbor(floor, d)}\r\n    />)}\r\n  </div>\r\n  {tile.info.items?.filter(item => !item.hidden).map(item => <GridItem \r\n  item={item} \r\n  // this was bad and you should feel bad: tileOffset={tileCenter}\r\n   />)}\r\n  </>;\r\n}\r\n\r\nfunction getWallPosition(direction: Direction, size: number) {\r\n  let top: string | number = 0;\r\n  let bottom: string | number = 0;\r\n  let left: string | number = 0;\r\n  let right: string | number = 0;\r\n\r\n  let width: number | undefined = size;\r\n  let height: number | undefined = size;\r\n\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      bottom = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"BOTTOM\":\r\n      top = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"RIGHT\":\r\n      left = \"auto\";\r\n      height = undefined;\r\n      break;\r\n    case \"LEFT\":\r\n      right = \"auto\";\r\n      height = undefined;\r\n      break;\r\n  }\r\n\r\n  return { top, bottom, left, right, width, height };\r\n}\r\n\r\nexport const GridWall: React.FC<{ overlayMode: boolean, tile: Tile; floor: Floor; direction: Direction; hasDoor: boolean; opened: boolean; }> = props => {\r\n  const { direction, opened, hasDoor, tile, floor } = props;\r\n  const row = direction === \"TOP\" || direction === \"BOTTOM\";\r\n  const filler = <div style={{ \r\n    flex: \"auto\",\r\n     backgroundColor: \"#322\",\r\n      height: row ? \"100%\" : undefined, width: row ? undefined : \"100%\" }}></div>;\r\n\r\n  return <div\r\n    style={{\r\n      ...getWallPosition(direction, wallSize),\r\n      position: \"absolute\",\r\n      display: \"flex\",\r\n      flexDirection: row ? \"row\" : \"column\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      overflow: \"hidden\",\r\n    }}>\r\n    {filler}\r\n    {hasDoor ?\r\n      <div\r\n        style={{ \r\n          cursor: opened ? undefined : \"pointer\",\r\n           height: doorSize, \r\n           width: doorSize,\r\n            backgroundColor: opened ? \"\" : \"grey\" }}\r\n        onClick={opened ? undefined : () => {\r\n          floor.fillCoord(MoveCoord(tile.coord, direction));\r\n          RenderApp();\r\n        }}\r\n      >\r\n      </div>\r\n      : null}\r\n    {filler}\r\n  </div>;\r\n};\r\n","export type Direction = \"TOP\" | \"LEFT\" | \"RIGHT\" | \"BOTTOM\";\r\n\r\nexport function AllDirections(): Direction[] {\r\n  return [\"TOP\", \"RIGHT\", \"BOTTOM\", \"LEFT\"];\r\n}\r\n\r\nexport function Opposite(direction: Direction): Direction {\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return \"BOTTOM\";\r\n    case \"BOTTOM\":\r\n      return \"TOP\";\r\n    case \"RIGHT\":\r\n      return \"LEFT\";\r\n    case \"LEFT\":\r\n      return \"RIGHT\";\r\n  }\r\n}\r\n\r\nexport function Rotate(direction: Direction, rotation: number) {\r\n  const allDirections = AllDirections();\r\n  const index = allDirections.indexOf(direction);\r\n  return allDirections[(index + rotation) % allDirections.length];\r\n}\r\n","import { centerX, centerY } from '../App';\r\nimport { GetTileTopAndLeft } from '../GridTile';\r\nimport { Coord, MoveCoord } from './Coord';\r\nimport { Direction, Rotate } from './Direction';\r\nimport { Floor } from './Floor';\r\nimport { Item, CopyItem } from './Items';\r\nimport { tileSize } from './Size';\r\n\r\ninterface TileInfo {\r\n  name: string;\r\n\r\n  doors: Direction[];\r\n\r\n  image?: string;\r\n\r\n  items?: Item[]; // These positions are in relative roomX, roomY.\r\n}\r\n\r\nexport class Tile {\r\n  // Rotations RIGHT in 90 increments. 0-3;\r\n  //public rotation = 0; // TODO\r\n  public x = 0;\r\n  public y = 0;\r\n  private initialDoors: Set<Direction>;\r\n  private rotation = 0;\r\n  private imageEl_: HTMLImageElement | null = null;\r\n\r\n  constructor(public readonly info: TileInfo) {\r\n    const { doors } = info;\r\n    this.initialDoors = new Set<Direction>(doors);\r\n  }\r\n\r\n  get coord(): Coord {\r\n    return { x: this.x, y: this.y };\r\n  }\r\n\r\n  get doors(): Set<Direction> {\r\n    const rotatedDoors = new Set<Direction>();\r\n    this.initialDoors.forEach(door => { rotatedDoors.add(Rotate(door, this.rotation)); });\r\n    return rotatedDoors;\r\n  }\r\n\r\n  /** Return valid rotations for the tile to be placed in a spot with the given constraints. */\r\n  // TODO: Handle ROTATION PROBABLY!\r\n  canPlace(neededDoors: Set<Direction>, neededWalls: Set<Direction>): boolean {\r\n    // TODO: Wait what about WALLS where we SHOULDNT have doors!\r\n    // ensure all needed doors are there\r\n    let canPlace = true;\r\n    neededDoors.forEach(direction => {\r\n      if (!this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    // ensure all needed walls have no doors!\r\n    neededWalls.forEach(direction => {\r\n      if (this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    return canPlace;\r\n  }\r\n\r\n  copy(r?: number) {\r\n    const t = new Tile({\r\n      ...this.info,\r\n      items: this.info.items?.map(item => CopyItem(item)),\r\n    });\r\n    if (r) {\r\n      t.rotate(r);\r\n    }\r\n    else {\r\n      t.rotate(this.rotation);\r\n    }\r\n    return t;\r\n  }\r\n\r\n  rotate(r: number) {\r\n    this.rotation = r % 4;\r\n    return this;\r\n  }\r\n\r\n  hasNeighbor(floor: Floor, direction: Direction): boolean {\r\n    // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n    return floor.hasCoord(MoveCoord(this.coord, direction));\r\n  }\r\n\r\n  get image() {\r\n    if (this.imageEl_) { return this.imageEl_; }\r\n    if (!this.info.image) { return null; }\r\n    this.imageEl_ = document.createElement(\"img\");\r\n    this.imageEl_.width = tileSize;\r\n    this.imageEl_.height = tileSize;\r\n    this.imageEl_.src = this.info.image;\r\n  }\r\n\r\n  drawToCanvas(ctx: CanvasRenderingContext2D, center: Coord) {\r\n    const topCorner = GetTileTopAndLeft(this.coord, center);\r\n    if (this.image) {\r\n      ctx.drawImage(this.image, topCorner.x, topCorner.y);\r\n    }\r\n    else {\r\n      ctx.fillStyle = \"#663333\"; // brown..ish?\r\n      ctx.fillRect(topCorner.x-1, topCorner.y-1, tileSize+2, tileSize+2);\r\n    }\r\n  }\r\n}\r\n","import { purse, watch, table, CopyItem, curesedKnife, Item, itemZindex } from './Items';\r\nimport { Tile } from './Tile';\r\nimport Kitchen from \"./../images/rooms/Kitchen.png\";\r\nimport { Floor } from './Floor';\r\nimport { centerX, centerY } from '../App';\r\nimport { player } from '../Player';\r\nimport { UpdateFogCanvas } from './SightLines';\r\n\r\nexport const FourWay = new Tile({ name: \"Fourway\", doors: [\"TOP\", \"LEFT\", \"RIGHT\", \"BOTTOM\"], image: Kitchen });\r\nFourWay.info.items = [CopyItem(table)];\r\nconst TeeWay = new Tile({ name: \"TeeWay\", doors: [\"TOP\", \"LEFT\", \"RIGHT\"] });\r\nconst Straight = new Tile({ name: \"Straight\", doors: [\"TOP\", \"BOTTOM\"] });\r\n\r\nStraight.info.items = [CopyItem(purse)];\r\n\r\nconst LTurn = new Tile({ name: \"LTurn\", doors: [\"TOP\", \"RIGHT\"] });\r\nconst RTurn = new Tile({ name: \"RTurn\", doors: [\"TOP\", \"LEFT\"] });\r\nRTurn.info.items = [CopyItem(curesedKnife)]; // THIS IS NOT HOW WE SHOULD DO IT. do this when FILLING THE TILE.\r\n\r\nconst DeadEnd = new Tile({ name: \"DeadEnd\", doors: [\"TOP\"] });\r\nDeadEnd.info.items = [CopyItem(watch)]; // THIS IS NOT HOW WE SHOULD DO IT. do this when FILLING THE TILE.\r\n\r\nfunction AllWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1), tile.copy(2), tile.copy(3)];\r\n}\r\n\r\nfunction TwoWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1)];\r\n}\r\n\r\nexport const TileLibrary = [\r\n  ...TwoWay(FourWay),\r\n  ...TwoWay(Straight),\r\n  ...AllWay(TeeWay),\r\n  ...AllWay(LTurn),\r\n  ...AllWay(RTurn),\r\n  ...AllWay(DeadEnd),\r\n];\r\n\r\nfunction createCanvas(id: string) {\r\n  const canvas: HTMLCanvasElement = document.createElement(\"canvas\");\r\n  canvas.id = \"Canvas_FloorAndItems\";\r\n  canvas.width = window.innerWidth;\r\n  canvas.height = window.innerHeight;\r\n\r\n  return {\r\n    canvas,\r\n    ctx: canvas.getContext(\"2d\")!,\r\n  };\r\n}\r\n\r\nconst { canvas: tileCanvas, ctx: tileCtx } = createCanvas(\"Canvas_Floor\");\r\nconst { canvas: sightCanvas, ctx: sightCtx } = createCanvas(\"Canvas_Sight\");\r\ndocument.body.append(tileCanvas);\r\ndocument.body.append(sightCanvas);\r\nvar resultCanvas: HTMLCanvasElement;\r\nvar resultCtx: CanvasRenderingContext2D;\r\n\r\nexport function DoSightLineThing(player: Item, floor:Floor){\r\n  DrawAllRooms(floor);\r\n  DrawSightCanvas(player, floor);\r\n  DrawResult();\r\n}\r\n\r\nexport function DrawAllRooms(floor: Floor) {\r\n  tileCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n  floor.tiles.forEach(tile => {\r\n    tile.drawToCanvas(tileCtx, { x: centerX, y: centerY });\r\n  });\r\n}\r\n\r\nexport function DrawSightCanvas(player: Item, floor: Floor){\r\n  UpdateFogCanvas(sightCtx, player, floor);\r\n  sightCtx.filter = \"blur(5px)\";\r\n}\r\n\r\nexport function DrawResult(){\r\n  if (!resultCanvas) {\r\n    resultCanvas = document.getElementById(\"Canvas_SightResult\") as HTMLCanvasElement;\r\n    if (!resultCanvas) { return; }\r\n  }\r\n  if (!resultCtx) {\r\n    resultCtx = resultCanvas.getContext(\"2d\")!;\r\n    resultCtx.save();\r\n  }\r\n\r\n  resultCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n  resultCtx.globalCompositeOperation = \"source-over\";\r\n  resultCtx.restore();\r\n  //resultCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n  //resultCtx.fillStyle=\"white\";\r\n  //resultCtx.fillRect(0,0,window.innerWidth,window.innerHeight);\r\n  resultCtx.drawImage(sightCanvas,0,0);\r\n  resultCtx.globalCompositeOperation = \"source-in\";\r\n  resultCtx.drawImage(tileCanvas,0,0);\r\n}","import { Add, Coord, MoveCoord, Multiply } from './Coord';\r\nimport { Direction, AllDirections, Opposite } from './Direction';\r\nimport { Tile } from './Tile';\r\nimport { TileLibrary, FourWay } from './Rooms';\r\nimport { tileSize } from './Size';\r\n\r\nexport function IndexCoord(c: Coord) { return Index(c.x, c.y); }\r\nexport function Index(x: number, y: number) { return `${x}, ${y}`; }\r\n\r\nexport class Floor {\r\n  constructor(public readonly name: string) { }\r\n\r\n  private grid = new Map<string, Tile>();\r\n\r\n  getCoord(c: Coord): Tile | undefined { return this.getTile(c.x, c.y); }\r\n  getTile(x: number, y: number): Tile | undefined { return this.grid.get(Index(x, y)); }\r\n\r\n  hasCoord(c: Coord): boolean { return this.hasTile(c.x, c.y); }\r\n  hasTile(x: number, y: number): boolean { return this.grid.has(Index(x, y)); }\r\n\r\n  setCoord(tile: Tile, c: Coord) { this.setTile(tile, c.x, c.y); }\r\n  setTile(tile: Tile, x: number, y: number) {\r\n    if (this.hasTile(x, y)) {\r\n      alert(\"Already had a tile there!\");\r\n      throw \"already had a tile!\";\r\n    }\r\n\r\n    tile.x = x;\r\n    tile.y = y;\r\n    \r\n    const tileCenter = Multiply(Add(tile.coord, { x: 0, y: 0 }), tileSize);\r\n    console.log(\"tile center!\", tileCenter);\r\n    tile.info.items?.forEach(item =>{\r\n    console.log(\"item \" + item.name, item.position);\r\n    item.position = Add(item.position, tileCenter);\r\n    console.log(\"new position \" + item.name, item.position);\r\n    });\r\n\r\n    this.grid.set(Index(x, y), tile);\r\n  }\r\n\r\n  get tiles(): Tile[] {\r\n    return Array.from(this.grid, ([key, tile]) => tile);\r\n  }\r\n\r\n  // return all POSSIBLE playing places\r\n  getValidSpotsForTiles() {\r\n    // this is maybe not the best approach. Cool ,but not needed right now...\r\n  }\r\n\r\n  fillCoord(c: Coord) { this.fillTile(c.x, c.y); }\r\n  fillTile(x: number, y: number) {\r\n    // 1. get all tiles bordering this.\r\n    const neighbors = AllDirections().map(d => this.getCoord(MoveCoord({ x, y }, d)));\r\n    const neededDoors = new Set<Direction>();\r\n    const neededWalls = new Set<Direction>();\r\n\r\n    AllDirections().forEach(direction => {\r\n      const neighbor = this.getCoord(MoveCoord({ x, y }, direction));\r\n      if (neighbor) {\r\n        if (neighbor.doors.has(Opposite(direction))) {\r\n          neededDoors.add(direction);\r\n        }\r\n        else {\r\n          neededWalls.add(direction);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Find possible tiles\r\n    // TODO: Factor in floor (basement, attic, etc) and stuff.\r\n    const matchingTiles = TileLibrary.filter(tile => tile.canPlace(neededDoors, neededWalls));\r\n\r\n    // TODO: we should never CLOSE off the entire floor, E.G. you should always be able to have at least 1 open door on each floor.\r\n\r\n    // Pick a random tile from the possible ones.\r\n    if (!matchingTiles) { throw new Error(\"No valid tile can go there! Wow we should really fix that!\"); }\r\n\r\n    const newTile = matchingTiles[Math.floor(Math.random() * matchingTiles.length)].copy();\r\n\r\n    // PICK items that apear\r\n\r\n    // things can have like SHELVES/etc you need to search\r\n    // things can be on the ground\r\n    // rooms have affinities for certain items, but never GUARANTEED\r\n    // E>G> Knife often found in Kitchens.\r\n    \r\n    this.setTile(newTile, x, y);\r\n  }\r\n}\r\n\r\nexport const FirstFloor = new Floor(\"Main Floor\");\r\nFirstFloor.setTile(FourWay.copy(), 0, 0);\r\n","import React from 'react';\r\nimport { GridItem, Item, Player } from \"./tiles/Items\";\r\nimport kid_green from \"./images/players/kid_green.png\";\r\n\r\nexport const player: Player = {\r\n  // item stuff\r\n  position: { x: 0, y: 0 },\r\n  height: 50,\r\n  width: 25,\r\n  color: \"red\",\r\n  name: \"You\",\r\n  velocity: { x: 0, y: 0 },\r\n  mass: 140,\r\n  image: kid_green,\r\n\r\n  blockObjects: true,\r\n  moveable: true, // Is this really smart??\r\n  \r\n  //player stuff\r\n  fear: 0,\r\n  health: 100,\r\n  intelligence: 5,\r\n  speed: 2,\r\n  inventory: [],\r\n  spirit: 2,\r\n  strength: 5,\r\n\r\n};\r\n\r\nexport const playerZindex = 51;\r\n\r\nexport function GridPlayer() {\r\n  return <GridItem item={player} zIndex={playerZindex} />\r\n}\r\n","import * as React from 'react';\r\nimport { Coord } from './Coord';\r\nimport { GridItem, Item, Player } from \"./Items\";\r\nimport { toScreenSpot } from './SightLines';\r\n\r\nvar interactables: Item[] = [];\r\n\r\nexport function SetInteractables(items: Item[]) {\r\n    interactables = items;\r\n}\r\n\r\nexport function Add(a: Coord, b: Coord) {\r\n    return {\r\n        x: a.x + b.x,\r\n        y: a.y + b.y,\r\n    };\r\n}\r\n\r\nexport function toScreenPositionStyle(c: Coord): React.CSSProperties {\r\n    const spot = toScreenSpot(c);\r\n    return {\r\n        top: spot.y,\r\n        left: spot.x,\r\n        position: \"absolute\",\r\n    }\r\n}\r\n\r\nexport const MenuStyle: React.CSSProperties = {\r\n    position: \"absolute\",\r\n    border: \"2px solid white\",\r\n    backgroundColor: \"#442211\",\r\n    padding: 5,\r\n    color: \"white\",\r\n}\r\n\r\nexport function InteractionButtons({ item, player, inInventory = false, onGround = false }:\r\n    { item: Item, player: Player, inInventory?: boolean, onGround?: boolean }) {\r\n    return <>\r\n        <div>{item.name}</div>\r\n        {item.playerInteractions\r\n            ?.filter(interaction =>\r\n                (interaction.canDoInInventory || !inInventory)\r\n                && (interaction.canDoOnGround || !onGround))\r\n            ?.map(interaction =>\r\n                <button\r\n                    style={{ cursor: \"pointer\" }}\r\n                    onClick={() => interaction.action(player, item)}>\r\n                    {interaction.name}\r\n                </button>)}\r\n    </>;\r\n}\r\n\r\n// want it like.. by the player?\r\nexport function Interactions(props: { player: Player }) {\r\n    const { player } = props;\r\n    if (interactables.length <= 0) { return null; }\r\n\r\n\r\n    return <>\r\n        {interactables.map(item =>\r\n            <div style={{\r\n                ...MenuStyle,\r\n                zIndex: 100,\r\n                ...toScreenPositionStyle(Add(\r\n                    item.position,\r\n                    { x: .5 * item.width + 5, y: .5 * item.height + 5 }\r\n                )),\r\n                textAlign: \"center\",\r\n                display: \"flex\",\r\n                flexDirection: \"column\",\r\n            }}>\r\n                <InteractionButtons item={item} player={player} onGround={true} />\r\n            </div>\r\n        )}\r\n    </>\r\n}","import * as React from 'react';\r\nimport { InteractionButtons, MenuStyle } from './Interaction';\r\nimport { Player } from \"./Items\";\r\n\r\n// want it like.. by the player?\r\nexport function Inventory(props: { player: Player }) {\r\n    const { player } = props;\r\n    const inventory = player.inventory;\r\n\r\n    if (inventory.length <= 0) { return null; }\r\n    return <div style={{\r\n        ...MenuStyle,\r\n        zIndex: 75,\r\n        bottom: 20,\r\n        left: 20,\r\n\r\n    }}>\r\n        <div style={{\r\n            display: \"flex\",\r\n            flexDirection: \"row\",\r\n            alignItems: \"stretch\",\r\n        }}>\r\n            {inventory.map(item =>\r\n                <div style={{\r\n                    padding: 10,\r\n                    textAlign: \"center\",\r\n                    display: \"flex\",\r\n                    flexDirection: \"column\",\r\n                    alignItems: \"center\",\r\n                    justifyContent: \"flex-end\",\r\n                }}>\r\n                    {item.image\r\n                        ? <img\r\n                            src={item.image}\r\n                            style={{\r\n                                cursor: \"pointer\",\r\n                                maxWidth: 50,\r\n                                maxHeight: 50\r\n                            }}\r\n                        />\r\n                        : <div style={{\r\n                            cursor: \"pointer\",\r\n                            backgroundColor: item.color,\r\n                            width: item.width,\r\n                            height: item.height\r\n                        }}></div>}\r\n\r\n                    <div style={{ display: \"flex\", flexDirection: \"column\" }}>\r\n                        <InteractionButtons item={item} player={player} inInventory={true} />\r\n                    </div>\r\n                </div>\r\n            )}\r\n        </div>\r\n    </div>\r\n}","import React from 'react';\nimport './App.css';\nimport { GridTile } from './GridTile';\nimport { ApplyFriction, CollideItems, CollideWithWalls, GetItemsInInteractionDistance, GetTileCoord, MoveItems } from './tiles/Collision';\nimport { FirstFloor, Index } from './tiles/Floor';\nimport { GridPlayer, player } from './Player';\nimport { GetItems, GridItem } from './tiles/Items';\nimport { Interactions, SetInteractables } from './tiles/Interaction';\nimport { Inventory } from './tiles/Inventory';\nimport { DoSightLineThing } from './tiles/Rooms';\n\nexport let centerX = 0;\nexport let centerY = 0;\n\nexport var RenderApp = () => { };\n\nvar showMap = false;\nvar showFog = false; // turn off for now.. Sightlines would be cool, but circle looks dumb.\nconst canvasStyle: React.CSSProperties = {\n  position: \"absolute\",\n  zIndex: 5,\n  width: \"100%\",\n  height: \"100%\",\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n};\n\nfunction App() {\n  const [, setState] = React.useState(0);\n  const rerender = React.useCallback(() => {\n    setState(Math.random());\n  }, [setState]);\n\n  React.useEffect(() => { RenderApp = rerender; }, [rerender]);\n\n  return (\n    <div className=\"App\" style={{ overflow: \"hidden\" }}>\n      {showMap ?\n        <div style={{ zIndex: 100, bottom: 0, padding: 20, position: \"absolute\", left: 0, right: 0 }}>\n          <div style={{ color: \"white\" }}>Map</div>\n          <button onClick={() => { centerY -= 100; rerender(); }}>UP!</button>\n          <button onClick={() => { centerY += 100; rerender(); }}>DOWN!</button>\n          <button onClick={() => { centerX -= 100; rerender(); }}>LEFT!</button>\n          <button onClick={() => { centerX += 100; rerender(); }}>RIGHT!</button>\n          <button onClick={() => { centerX = 0; centerY = 0; rerender(); }}>CENTER!</button>\n        </div> : null}\n      <GridPlayer />\n\n      <div>\n\n        {showFog ? <canvas id=\"fog\"\n          width={window.innerWidth}\n          height={window.innerHeight}\n          style={{\n            ...canvasStyle,\n            opacity: .2,\n            //mixBlendMode: \"multiply\",\n            filter: \"blur(5px)\",\n          }} /> : null}\n\n        <canvas id=\"Canvas_SightResult\"\n          width={window.innerWidth}\n          height={window.innerHeight}\n          style={{\n            ...canvasStyle,\n            zIndex: 6,\n          }} />\n\n        <div id=\"gamefloor\" style={{ mixBlendMode: \"normal\" }}>\n\n          {FirstFloor.tiles.map((tile) => <GridTile\n            overlayMode={true}\n            floor={FirstFloor}\n            tile={tile}\n            key={Index(tile.x, tile.y)}\n          />)} \n          \n          {GetItems().map((item) => <GridItem item={item} />)}\n\n        </div>\n      </div>\n\n      <Interactions player={player} />\n      <Inventory player={player} />\n\n    </div>\n  );\n}\n\nlet leftPressed = false;\nlet upPressed = false;\nlet rightPressed = false;\nlet downPressed = false;\n\nlet mPressed = false;\n\ndocument.addEventListener('keydown', e => {\n  if (e.key === \"m\" || e.key === \"M\") {\n    if (!mPressed) { showMap = !showMap; }\n    mPressed = true;\n  }\n\n  if (e.key === \"a\" || e.key === \"A\" || e.key === \"ArrowLeft\") {\n    leftPressed = true;\n    rightPressed = false;\n  }\n  if (e.key === \"d\" || e.key === \"D\" || e.key === \"ArrowRight\") {\n    rightPressed = true;\n    leftPressed = false;\n  }\n  if (e.key === \"w\" || e.key === \"W\" || e.key === \"ArrowUp\") {\n    upPressed = true;\n    downPressed = false;\n  }\n  if (e.key === \"s\" || e.key === \"S\" || e.key === \"ArrowDown\") {\n    downPressed = true;\n    upPressed = false;\n  }\n});\n\ndocument.addEventListener('keyup', e => {\n  //console.log(e.key);\n  if (e.key === \"a\" || e.key === \"A\" || e.key === \"ArrowLeft\") {\n    leftPressed = false;\n  }\n  if (e.key === \"d\" || e.key === \"D\" || e.key === \"ArrowRight\") {\n    rightPressed = false;\n  }\n  if (e.key === \"w\" || e.key === \"W\" || e.key === \"ArrowUp\") {\n    upPressed = false;\n  }\n  if (e.key === \"s\" || e.key === \"S\" || e.key === \"ArrowDown\") {\n    downPressed = false;\n  }\n  if (e.key === \"m\" || e.key === \"M\") {\n    mPressed = false;\n  }\n});\n\nconst moveSpeed = 2;\nconst playerAccel = .3;\nconst mapSpeed = 7;\n\nfunction animate() {\n  if (showMap) {\n    if (leftPressed) {\n      centerX -= mapSpeed;\n    }\n    if (rightPressed) {\n      centerX += mapSpeed;\n    }\n    if (upPressed) {\n      centerY -= mapSpeed;\n    }\n    if (downPressed) {\n      centerY += mapSpeed;\n    }\n  }\n  else {\n    player.velocity = player.velocity || { x: 0, y: 0 };\n    if (leftPressed && player.velocity.x > -moveSpeed) {\n      //player.position.x -= moveSpeed;\n      player.velocity.x -= playerAccel;\n      player.imageTransform = undefined;\n    }\n    if (rightPressed && player.velocity.x < moveSpeed) {\n      //player.position.x += moveSpeed;\n      player.velocity.x += playerAccel;\n      player.imageTransform = \"scale(-1,1)\";\n    }\n    if (upPressed && player.velocity.y > -moveSpeed) {\n      //player.position.y -= moveSpeed;\n      player.velocity.y -= playerAccel;\n    }\n    if (downPressed && player.velocity.y < moveSpeed) {\n      //player.position.y += moveSpeed;\n      player.velocity.y += playerAccel;\n    }\n  }\n\n  // for now we are assuming the player is ALWAYS centered. \n  // This is probably bad and we may want to change it when we switch to a canvas based approach.\n  MoveItems([player]);\n  CollideWithWalls(player, FirstFloor, true);\n  //GetItems().forEach(item => CollideWithWalls(item, FirstFloor));\n  ApplyFriction([player]);\n\n  // TODO: don't check for interaction distance EVERY frame, this is totaly overkill\n  const roomItems = FirstFloor.getCoord(GetTileCoord(player.position))?.info.items?.filter(item => !item.hidden);\n  SetInteractables(\n    GetItemsInInteractionDistance(\n      player,\n      [\n        ...GetItems(),\n        ...(roomItems || []) // YO! This doesn't handle the tile offset... these are all RELATIVE. maybe we should CHANGE that. the relative thing is really tough.\n      ]\n    )\n  );\n  \n  CollideItems([\n    player,\n    ...(roomItems?.filter(item => item.moveable || item.blockObjects) || [])\n  ]);\n\n  // FOLLOW CAM\n  if (!showMap) {\n    centerX = player.position.x;\n    centerY = player.position.y;\n  }\n  \n  DoSightLineThing(player, FirstFloor);\n//  DrawAllRooms(FirstFloor);\n  // BASIC fog, wont need latershowFog && UpdateFog(player, FirstFloor);\n  RenderApp();\n  requestAnimationFrame(() => animate());\n}\n\nanimate();\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker === null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}