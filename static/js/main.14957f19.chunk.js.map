{"version":3,"sources":["tiles/Coord.ts","tiles/Items.tsx","tiles/Collision.ts","tiles/Size.ts","GridTile.tsx","tiles/Direction.ts","tiles/Tile.ts","tiles/RegisterTiles.ts","tiles/Floor.ts","Player.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["MoveCoord","c","direction","x","y","items","GetItems","GridItem","props","item","hW","width","hH","height","title","name","style","position","zIndex","backgroundColor","color","top","centerY","window","innerHeight","left","centerX","innerWidth","GetTileCoord","Math","floor","wallSize","doorSize","screenSize","max","tileViewDist","ceil","addEventListener","console","log","GridTile","a","b","tile","overlayMode","tileCoord","cameraCoord","abs","display","justifyContent","alignItems","undefined","info","map","d","hasDoor","doors","has","opened","hasNeighbor","getWallPosition","size","bottom","right","GridWall","row","filler","flex","flexDirection","overflow","cursor","onClick","fillCoord","coord","RenderApp","Tile","initialDoors","rotation","this","Set","neededDoors","neededWalls","canPlace","forEach","r","t","rotate","hasCoord","rotatedDoors","door","add","allDirections","index","indexOf","length","Rotate","FourWay","TeeWay","Straight","LTurn","RTurn","DeadEnd","AllWay","copy","TwoWay","TileLibrary","Index","FirstFloor","grid","Map","getTile","get","hasTile","setTile","alert","set","fillTile","getCoord","neighbor","Opposite","matchingTiles","filter","newTile","random","Array","from","player","velocity","mass","Player","showMap","leftPressed","upPressed","rightPressed","downPressed","mPressed","document","e","key","animate","players","i","hD","hDX","hDY","GetRoomCoord","roomX","roomY","leftWall","rightWall","topWall","bottomWall","HasRoomOrCreate","newCoord","CollideWithWalls","ApplyFriction","requestAnimationFrame","App","React","useState","setState","rerender","useCallback","useEffect","className","padding","id","mixBlendMode","tiles","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.14957f19.chunk.js","sourcesContent":["import { Direction } from './Direction';\r\n\r\nexport interface Coord {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport function MoveCoord(c: Coord, direction: Direction): Coord {\r\n  const { x, y } = c;\r\n  // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return { x, y: y - 1 };\r\n    case \"BOTTOM\":\r\n      return { x, y: y + 1 };\r\n    case \"RIGHT\":\r\n      return { x: x + 1, y };\r\n    case \"LEFT\":\r\n      return { x: x - 1, y };\r\n  }\r\n}\r\n\r\nexport function MidPoint(a: Coord, b: Coord) {\r\n  return {\r\n    x: (a.x + b.x) / 2,\r\n    y: (a.y + b.y) / 2,\r\n  };\r\n}\r\n\r\n// Distances ordered by their stupidness\r\nexport function Distance(a: Coord, b: Coord) {\r\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\r\n}\r\n\r\nexport function HammingDistance(a: Coord, b: Coord) {\r\n  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n}\r\n\r\nexport function EitherDirectionDistance(a: Coord, b: Coord) {\r\n  return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\r\n}","import * as React from 'react';\r\nimport { centerY, centerX } from '../App';\r\nimport { Coord } from \"./Coord\";\r\n\r\nexport interface Item {\r\n    position: Coord;\r\n    height: number;\r\n    width: number;\r\n\r\n    name?: string;\r\n    color?: string; // TODO this should be an image or graphic or canvas dude!\r\n\r\n    mass: number;\r\n    velocity: Coord;\r\n}\r\n\r\nexport function ToBoundingBox(item: Item) {\r\n    return {\r\n        x: item.position.x - item.width * .5,\r\n        y: item.position.y - item.height * .5,\r\n        height: item.height,\r\n        width: item.width,\r\n    };\r\n}\r\n\r\n/* Check two items for collision! */\r\nexport function RectangleCollision(a: Item, b: Item) {\r\n    const rect1 = ToBoundingBox(a);\r\n    const rect2 = ToBoundingBox(b);\r\n    return rect1.x < rect2.x + rect2.width &&\r\n        rect1.x + rect1.width > rect2.x &&\r\n        rect1.y < rect2.y + rect2.height &&\r\n        rect1.y + rect1.height > rect2.y;\r\n}\r\n\r\nvar items: Item[] = [];\r\n\r\n// yo if we stored these BY room it would be pretty cool.\r\nexport function AddItem(item: Item) {\r\n    items.push(item);\r\n}\r\n\r\nexport function GetItems() {\r\n    return items;\r\n}\r\n\r\nexport const itemZindex = 50;\r\n\r\nexport function GridItem(props: { item: Item, zIndex?: number }) {\r\n    const { item } = props;\r\n    const hW = item.width * .5;\r\n    const hH = item.height * .5;\r\n\r\n    return <div\r\n        title={item.name}\r\n        style={{\r\n            position: \"absolute\",\r\n            zIndex: props.zIndex || itemZindex,\r\n            height: item.height,\r\n            width: item.width,\r\n            backgroundColor: item.color || \"grey\",\r\n            top: item.position.y - centerY + (.5 * window.innerHeight) - hH,\r\n            left: item.position.x - centerX + (.5 * window.innerWidth) - hW,\r\n        }}>\r\n    </div>;\r\n}\r\n\r\n/*\r\nAddItem({\r\n    position: { x: Math.random() * 600 - 300, y: Math.random() * 400 - 200 },\r\n    height: 15,\r\n    width: 20,\r\n    color: \"green\",\r\n    name: \"purse\",\r\n    mass: 4,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n\r\nAddItem({\r\n    position: { x: Math.random() * 200 - 100, y: Math.random() * 400 - 200 },\r\n    height: 20,\r\n    width: 20,\r\n    color: \"brown\",\r\n    name: \"Box\",\r\n    mass: 15,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n\r\n\r\nAddItem({\r\n    position: { x: Math.random() * 200 - 100, y: Math.random() * 800 - 400 },\r\n    height: 10,\r\n    width: 10,\r\n    color: \"gold\",\r\n    name: \"pocketwatch\",\r\n    mass: .5,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n\r\nAddItem({\r\n    position: { x: Math.random() * 200 - 100, y: Math.random() * 800 - 400 },\r\n    height: 70,\r\n    width: 40,\r\n    color: \"tan\",\r\n    name: \"Table\",\r\n    mass: 70,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n*/","\r\n// ok how can we do... intersections and interactions?\r\n// #1 only can hit things in your room (or very rarely a neighboring room that is close by..)\r\n\r\nimport { doorSize, wallSize } from \"../GridTile\";\r\nimport { Coord, MidPoint, MoveCoord } from \"./Coord\";\r\nimport { Direction } from \"./Direction\";\r\nimport { Floor } from \"./Floor\";\r\nimport { GetItems, Item, RectangleCollision } from \"./Items\";\r\nimport { tileSize } from \"./Size\";\r\n\r\n/** The TILE the item is in. */\r\nexport function GetTileCoord(c: Coord): Coord {\r\n    const hT = .5 * tileSize;\r\n    const x = Math.floor((c.x + hT) / tileSize);\r\n    const y = Math.floor((c.y + hT) / tileSize);\r\n    return { x, y };\r\n}\r\n\r\n/** The relative place in the current TILE the item is in. */\r\nexport function GetRoomCoord(item: Item, tileCoord: Coord): Coord {\r\n    const x = item.position.x - (tileCoord.x * tileSize);\r\n    const y = item.position.y - (tileCoord.y * tileSize);\r\n    return { x, y };\r\n}\r\n\r\nconst doorEdgeSize = 3;\r\n\r\nexport function CollideWithWalls(item: Item, floor?: Floor) {\r\n    const hT = .5 * tileSize;\r\n    const hW = .5 * item.width;\r\n    const hH = .5 * item.height;\r\n    const hD = .5 * doorSize;\r\n\r\n    const hDX = hD - hW;\r\n    const hDY = hD - hH;\r\n\r\n    // which TILE is it in?\r\n\r\n    const tileCoord = GetTileCoord(item.position);\r\n    const { x: roomX, y: roomY } = GetRoomCoord(item, tileCoord);\r\n\r\n    const leftWall = hW + wallSize - hT;\r\n    const rightWall = -1 * leftWall;\r\n    const topWall = hH + wallSize - hT;\r\n    const bottomWall = -1 * topWall;\r\n\r\n    const tile = floor?.getCoord(tileCoord);\r\n\r\n    //hasDoor={tile.doors.has(d)}\r\n    //opened={tile.hasNeighbor(floor, d)}\r\n\r\n    function HasRoomOrCreate(coord: Coord, direction: Direction) {\r\n        const hasDoor = tile && tile.doors.has(direction);\r\n\r\n        if (!hasDoor) { return false; }\r\n\r\n        const newCoord = MoveCoord(coord, direction);\r\n        if (!floor?.hasCoord(newCoord)) {\r\n            floor?.fillCoord(newCoord);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // TODO: Stop weirdness at the EDGE of doors.\r\n\r\n    // If you are inside the wall boundary\r\n    if (roomX <= leftWall) {\r\n        // AND you are outside of the door area (or there is no door):\r\n        // Push you back to the edge of the wall.\r\n        if (Math.abs(roomY) > hDY || !HasRoomOrCreate(tileCoord, \"LEFT\")) {\r\n            if (Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomY > 0){\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return;\r\n            }\r\n\r\n            item.position.x += leftWall - roomX;\r\n            item.velocity.x = 0;\r\n        }\r\n    }\r\n    if (roomX >= rightWall) {\r\n        if (Math.abs(roomY) > hDY || !HasRoomOrCreate(tileCoord, \"RIGHT\")) {\r\n            if (Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomY > 0){\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return;\r\n            }\r\n\r\n            item.position.x += rightWall - roomX;\r\n            item.velocity.x = 0;\r\n        }\r\n    }\r\n    if (roomY <= topWall) {\r\n        if (Math.abs(roomX) > hDX || !HasRoomOrCreate(tileCoord, \"TOP\")) {\r\n            if (Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomX > 0){\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return;\r\n            }\r\n\r\n            item.position.y += topWall - roomY;\r\n            item.velocity.y = 0;\r\n        }\r\n    }\r\n    if (roomY >= bottomWall) {\r\n        if (Math.abs(roomX) > hDX || !HasRoomOrCreate(tileCoord, \"BOTTOM\")) {\r\n            if (Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomX > 0){\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return;\r\n            }\r\n            \r\n            item.position.y += bottomWall - roomY;\r\n            item.velocity.y = 0;\r\n        }\r\n    }\r\n\r\n    // tile\r\n}\r\n\r\nexport function ApplyFriction(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach(item => {\r\n        if (item.velocity) {\r\n            if (item.velocity.x) {\r\n                item.velocity.x *= .9;\r\n                if (Math.abs(item.velocity.x) < .1) { item.velocity.x = 0; }\r\n            }\r\n            if (item.velocity.y) {\r\n                item.velocity.y *= .9;\r\n                if (Math.abs(item.velocity.y) < .1) { item.velocity.y = 0; }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function InelasticCollision(a: Item, b: Item) {\r\n    // final velocity\r\n    const x = (a.mass * a.velocity.x + b.mass * b.velocity.x) / (a.mass + b.mass);\r\n    const y = (a.mass * a.velocity.y + b.mass * b.velocity.y) / (a.mass + b.mass);\r\n\r\n    // step back their velocities a bit??\r\n\r\n    const fudge = .2;\r\n    a.position.x -= a.velocity.x * fudge;\r\n    a.position.y -= a.velocity.y * fudge;\r\n    b.position.x -= b.velocity.x * fudge;\r\n    b.position.y -= b.velocity.y * fudge;\r\n\r\n    // and we want to PUSH them out so they are not colliding.\r\n    // How can we do that? Ideally we would like factor in the faces, but for laziness\r\n    // we could just push opposite the direction?\r\n    a.velocity.x = x;\r\n    a.velocity.y = y;\r\n    b.velocity.x = x;\r\n    b.velocity.y = y;\r\n}\r\n\r\nexport function CollideItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach((item, i) => {\r\n        if (i < items.length - 1) {\r\n            for (let j = i + 1; j < items.length; j++) {\r\n                if (RectangleCollision(item, items[j])) {\r\n                    //console.log(\"COLLISION!\", item.name, items[j].name);\r\n                    // TODO: update velocity and stuff??\r\n                    InelasticCollision(item, items[j]);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function MoveItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach((item, i) => {\r\n        if (item.velocity.x) {\r\n            item.position.x += item.velocity.x;\r\n        }\r\n        if (item.velocity.y) {\r\n            item.position.y += item.velocity.y;\r\n        }\r\n    });\r\n}","export const tileSize = 300;\r\n","import React from 'react';\r\nimport { EitherDirectionDistance, HammingDistance, MoveCoord } from './tiles/Coord';\r\nimport { Direction, AllDirections } from './tiles/Direction';\r\nimport { Tile } from './tiles/Tile';\r\nimport { centerY, centerX, RenderApp } from './App';\r\nimport { Floor } from \"./tiles/Floor\";\r\nimport { GetTileCoord } from './tiles/Collision';\r\nimport { tileSize } from './tiles/Size';\r\n\r\nexport const wallSize = 10;\r\nexport const doorSize = 75;\r\n\r\n// probably only update this on resize\r\nvar screenSize = Math.max(window.innerWidth, window.innerHeight);\r\nvar tileViewDist = Math.ceil(screenSize / (2 * tileSize));\r\n\r\nwindow.addEventListener('resize', ()=>{\r\n  screenSize = Math.max(window.innerWidth, window.innerHeight);\r\n  tileViewDist = Math.ceil(screenSize / (2 * tileSize));\r\n  console.log(\"Updated view dist\", tileViewDist);\r\n});\r\n\r\nconsole.log(\"Initial view dist\", tileViewDist);\r\n\r\nexport const GridTile: React.FC<{ tile: Tile; floor: Floor; overlayMode: boolean}> = props => {\r\n  const { tile, floor, overlayMode } = props;\r\n\r\n  // check screen space if we should render it!\r\n  const tileCoord = { x: tile.x, y: tile.y };\r\n  const cameraCoord = GetTileCoord({ x: centerX, y: centerY });\r\n  if (EitherDirectionDistance(tileCoord, cameraCoord) > tileViewDist) {\r\n    return null;\r\n  }\r\n\r\n  return <div\r\n    style={{\r\n      zIndex: overlayMode ? 10 : 4,\r\n      position: \"absolute\",\r\n      height: tileSize,\r\n      width: tileSize,\r\n      top: tile.y! * tileSize + .5 * (window.innerHeight - tileSize) - centerY,\r\n      left: tile.x! * tileSize + .5 * (window.innerWidth - tileSize) - centerX,\r\n      display: \"flex\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      color: \"white\",\r\n      //border: '5px solid black',\r\n      backgroundColor:  overlayMode ? undefined : \"#663333\",\r\n    }}>\r\n    {tile.info.name}\r\n    {AllDirections().map(d => <GridWall\r\n      overlayMode={overlayMode}\r\n      tile={tile}\r\n      floor={floor}\r\n      direction={d}\r\n      hasDoor={tile.doors.has(d)}\r\n      opened={tile.hasNeighbor(floor, d)}\r\n    />)}\r\n  </div>;\r\n}\r\n\r\nfunction getWallPosition(direction: Direction, size: number) {\r\n  let top: string | number = 0;\r\n  let bottom: string | number = 0;\r\n  let left: string | number = 0;\r\n  let right: string | number = 0;\r\n\r\n  let width: number | undefined = size;\r\n  let height: number | undefined = size;\r\n\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      bottom = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"BOTTOM\":\r\n      top = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"RIGHT\":\r\n      left = \"auto\";\r\n      height = undefined;\r\n      break;\r\n    case \"LEFT\":\r\n      right = \"auto\";\r\n      height = undefined;\r\n      break;\r\n  }\r\n\r\n  return { top, bottom, left, right, width, height };\r\n}\r\n\r\nexport const GridWall: React.FC<{ overlayMode: boolean, tile: Tile; floor: Floor; direction: Direction; hasDoor: boolean; opened: boolean; }> = props => {\r\n  const { direction, opened, hasDoor, tile, floor, overlayMode } = props;\r\n  const row = direction == \"TOP\" || direction == \"BOTTOM\";\r\n  const filler = <div style={{ \r\n    flex: \"auto\",\r\n     backgroundColor: \"#322\",\r\n      height: row ? \"100%\" : undefined, width: row ? undefined : \"100%\" }}></div>;\r\n\r\n  return <div\r\n    style={{\r\n      ...getWallPosition(direction, overlayMode ? 3 : wallSize),\r\n      position: \"absolute\",\r\n      display: \"flex\",\r\n      flexDirection: row ? \"row\" : \"column\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      overflow: \"hidden\",\r\n    }}>\r\n    {filler}\r\n    {hasDoor ?\r\n      <div\r\n        style={{ \r\n          cursor: opened ? undefined : \"pointer\",\r\n           height: doorSize, \r\n           width: doorSize,\r\n            backgroundColor: opened ? \"\" : \"grey\" }}\r\n        onClick={opened ? undefined : () => {\r\n          floor.fillCoord(MoveCoord(tile.coord, direction));\r\n          RenderApp();\r\n        }}\r\n      >\r\n      </div>\r\n      : null}\r\n    {filler}\r\n  </div>;\r\n};\r\n","export type Direction = \"TOP\" | \"LEFT\" | \"RIGHT\" | \"BOTTOM\";\r\n\r\nexport function AllDirections(): Direction[] {\r\n  return [\"TOP\", \"RIGHT\", \"BOTTOM\", \"LEFT\"];\r\n}\r\n\r\nexport function Opposite(direction: Direction): Direction {\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return \"BOTTOM\";\r\n    case \"BOTTOM\":\r\n      return \"TOP\";\r\n    case \"RIGHT\":\r\n      return \"LEFT\";\r\n    case \"LEFT\":\r\n      return \"RIGHT\";\r\n  }\r\n}\r\n\r\nexport function Rotate(direction: Direction, rotation: number) {\r\n  const allDirections = AllDirections();\r\n  const index = allDirections.indexOf(direction);\r\n  return allDirections[(index + rotation) % allDirections.length];\r\n}\r\n","import { Coord, MoveCoord } from './Coord';\r\nimport { Direction, Rotate } from './Direction';\r\nimport { Floor } from './Floor';\r\n\r\ninterface TileInfo {\r\n  name: string;\r\n\r\n  doors: Direction[];\r\n}\r\n\r\nexport class Tile {\r\n  // Rotations RIGHT in 90 increments. 0-3;\r\n  //public rotation = 0; // TODO\r\n  public x = 0;\r\n  public y = 0;\r\n  private initialDoors: Set<Direction>;\r\n  private rotation = 0;\r\n\r\n  constructor(public readonly info: TileInfo) {\r\n    const { doors } = info;\r\n    this.initialDoors = new Set<Direction>(doors);\r\n  }\r\n\r\n  get coord(): Coord {\r\n    return { x: this.x, y: this.y };\r\n  }\r\n\r\n  get doors(): Set<Direction> {\r\n    const rotatedDoors = new Set<Direction>();\r\n    this.initialDoors.forEach(door => { rotatedDoors.add(Rotate(door, this.rotation)); });\r\n    return rotatedDoors;\r\n  }\r\n\r\n  /** Return valid rotations for the tile to be placed in a spot with the given constraints. */\r\n  // TODO: Handle ROTATION PROBABLY!\r\n  canPlace(neededDoors: Set<Direction>, neededWalls: Set<Direction>): boolean {\r\n    // TODO: Wait what about WALLS where we SHOULDNT have doors!\r\n    // ensure all needed doors are there\r\n    let canPlace = true;\r\n    neededDoors.forEach(direction => {\r\n      if (!this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    // ensure all needed walls have no doors!\r\n    neededWalls.forEach(direction => {\r\n      if (this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    return canPlace;\r\n  }\r\n\r\n  copy(r?: number) {\r\n    const t = new Tile(this.info);\r\n    if (r) {\r\n      t.rotate(r);\r\n    }\r\n    else {\r\n      t.rotate(this.rotation);\r\n    }\r\n    return t;\r\n  }\r\n\r\n  rotate(r: number) {\r\n    this.rotation = r % 4;\r\n    return this;\r\n  }\r\n\r\n  hasNeighbor(floor: Floor, direction: Direction): boolean {\r\n    // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n    return floor.hasCoord(MoveCoord(this.coord, direction));\r\n  }\r\n}\r\n","import { Tile } from './Tile';\r\n\r\nexport const FourWay = new Tile({ name: \"Fourway\", doors: [\"TOP\", \"LEFT\", \"RIGHT\", \"BOTTOM\"] });\r\nconst TeeWay = new Tile({ name: \"TeeWay\", doors: [\"TOP\", \"LEFT\", \"RIGHT\"] });\r\nconst Straight = new Tile({ name: \"Straight\", doors: [\"TOP\", \"BOTTOM\"] });\r\nconst LTurn = new Tile({ name: \"LTurn\", doors: [\"TOP\", \"RIGHT\"] });\r\nconst RTurn = new Tile({ name: \"RTurn\", doors: [\"TOP\", \"LEFT\"] });\r\nconst DeadEnd = new Tile({ name: \"DeadEnd\", doors: [\"TOP\"] });\r\n\r\nfunction AllWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1), tile.copy(2), tile.copy(3)];\r\n}\r\n\r\nfunction TwoWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1)];\r\n}\r\n\r\nexport const TileLibrary = [\r\n  ...TwoWay(FourWay),\r\n  ...TwoWay(Straight),\r\n  ...AllWay(TeeWay),\r\n  ...AllWay(LTurn),\r\n  ...AllWay(RTurn),\r\n  ...AllWay(DeadEnd),\r\n];\r\n","import { Coord, MoveCoord } from './Coord';\r\nimport { Direction, AllDirections, Opposite } from './Direction';\r\nimport { Tile } from './Tile';\r\nimport { TileLibrary, FourWay } from './RegisterTiles';\r\n\r\nexport function IndexCoord(c: Coord) { return Index(c.x, c.y); }\r\nexport function Index(x: number, y: number) { return `${x}, ${y}`; }\r\n\r\nexport class Floor {\r\n  constructor(public readonly name: string) { }\r\n\r\n  private grid = new Map<string, Tile>();\r\n\r\n  getCoord(c: Coord): Tile | undefined { return this.getTile(c.x, c.y); }\r\n  getTile(x: number, y: number): Tile | undefined { return this.grid.get(Index(x, y)); }\r\n\r\n  hasCoord(c: Coord): boolean { return this.hasTile(c.x, c.y); }\r\n  hasTile(x: number, y: number): boolean { return this.grid.has(Index(x, y)); }\r\n\r\n  setCoord(tile: Tile, c: Coord) { this.setTile(tile, c.x, c.y); }\r\n  setTile(tile: Tile, x: number, y: number) {\r\n    if (this.hasTile(x, y)) {\r\n      alert(\"Already had a tile there!\");\r\n      throw \"already had a tile!\";\r\n    }\r\n\r\n    tile.x = x;\r\n    tile.y = y;\r\n    this.grid.set(Index(x, y), tile);\r\n  }\r\n\r\n  get tiles(): Tile[] {\r\n    return Array.from(this.grid, ([key, tile]) => tile);\r\n  }\r\n\r\n  // return all POSSIBLE playing places\r\n  getValidSpotsForTiles() {\r\n    // this is maybe not the best approach. Cool ,but not needed right now...\r\n  }\r\n\r\n  fillCoord(c: Coord) { this.fillTile(c.x, c.y); }\r\n  fillTile(x: number, y: number) {\r\n    // fill a gap with a VALID tile. Woops do we need rotation soon?\r\n    // 1. get all tiles bordering this.\r\n    const neighbors = AllDirections().map(d => this.getCoord(MoveCoord({ x, y }, d)));\r\n    const neededDoors = new Set<Direction>();\r\n    const neededWalls = new Set<Direction>();\r\n\r\n    AllDirections().forEach(direction => {\r\n      const neighbor = this.getCoord(MoveCoord({ x, y }, direction));\r\n      if (neighbor) {\r\n        if (neighbor.doors.has(Opposite(direction))) {\r\n          neededDoors.add(direction);\r\n        }\r\n        else {\r\n          neededWalls.add(direction);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Find possible tiles\r\n    // TODO: Factor in floor type and stuff.\r\n    const matchingTiles = TileLibrary.filter(tile => tile.canPlace(neededDoors, neededWalls));\r\n\r\n    // Pick a random tile from the possible ones.\r\n    if (!matchingTiles) { throw \"wow we should really fix that!\"; }\r\n\r\n    const newTile = matchingTiles[Math.floor(Math.random() * matchingTiles.length)].copy();\r\n    this.setTile(newTile, x, y);\r\n  }\r\n}\r\n\r\nexport const FirstFloor = new Floor(\"Main Floor\");\r\nFirstFloor.setTile(FourWay.copy(), 0, 0);\r\n","import React from 'react';\r\nimport { GridItem, Item } from \"./tiles/Items\";\r\n\r\nexport const player: Item = {\r\n  position: { x: 0, y: 0 },\r\n  height: 30,\r\n  width: 15,\r\n  color: \"red\",\r\n  name: \"You\",\r\n  velocity: { x: 0, y: 0 },\r\n  mass: 140,\r\n};\r\n\r\nexport const playerZindex = 51;\r\n\r\nexport function Player() {\r\n  return <GridItem item={player} zIndex={playerZindex} />\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport { GridTile } from './GridTile';\nimport { ApplyFriction, CollideItems, CollideWithWalls, MoveItems } from './tiles/Collision';\nimport { FirstFloor, Index } from './tiles/Floor';\nimport { sightDistance, UpdateFog } from './tiles/SightLines';\nimport { Player, player } from './Player';\nimport { GetItems, GridItem, Item } from './tiles/Items';\n\nexport let centerX = 0;\nexport let centerY = 0;\n\nexport var RenderApp = () => { };\n\nvar showMap = false;\nvar showFog = false; // turn off for now.. Sightlines would be cool, but circle looks dumb.\n\nfunction App() {\n  const [, setState] = React.useState(0);\n  const rerender = React.useCallback(() => {\n    setState(Math.random());\n  }, [setState]);\n\n  React.useEffect(() => { RenderApp = rerender; }, [rerender]);\n\n  return (\n    <div className=\"App\" style={{ overflow: \"hidden\" }}>\n      {showMap ?\n        <div style={{ zIndex: 100, bottom: 0, padding: 20, position: \"absolute\", left: 0, right: 0 }}>\n          <div style={{ color: \"white\" }}>Map</div>\n          <button onClick={() => { centerY -= 100; rerender(); }}>UP!</button>\n          <button onClick={() => { centerY += 100; rerender(); }}>DOWN!</button>\n          <button onClick={() => { centerX -= 100; rerender(); }}>LEFT!</button>\n          <button onClick={() => { centerX += 100; rerender(); }}>RIGHT!</button>\n          <button onClick={() => { centerX = 0; centerY = 0; rerender(); }}>CENTER!</button>\n        </div> : null}\n      <Player />\n\n      <div>\n        {showFog ? <canvas id=\"fog\"\n          width={window.innerWidth}\n          height={window.innerHeight}\n          style={{\n            mixBlendMode: \"multiply\",\n            position: \"absolute\",\n            zIndex: 5,\n            width: \"100%\",\n            height: \"100%\",\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            //filter: \"blur(25px)\",\n          }} /> : null}\n\n        <div id=\"gamefloor\" style={{ mixBlendMode: \"normal\" }}>\n\n          {FirstFloor.tiles.map((tile) => <GridTile\n            overlayMode={showMap}\n            floor={FirstFloor}\n            tile={tile}\n            key={Index(tile.x, tile.y)}\n          />)}\n\n          {GetItems().map((item) => <GridItem item={item} />)}\n\n        </div>\n      </div>\n\n    </div>\n  );\n}\n\nlet leftPressed = false;\nlet upPressed = false;\nlet rightPressed = false;\nlet downPressed = false;\n\nlet mPressed = false;\n\ndocument.addEventListener('keydown', e => {\n  if (e.key == \"m\" || e.key == \"M\") {\n    if (!mPressed) { showMap = !showMap; }\n    mPressed = true;\n  }\n\n  if (e.key == \"a\" || e.key == \"A\" || e.key == \"ArrowLeft\") {\n    leftPressed = true;\n    rightPressed = false;\n  }\n  if (e.key == \"d\" || e.key == \"D\" || e.key == \"ArrowRight\") {\n    rightPressed = true;\n    leftPressed = false;\n  }\n  if (e.key == \"w\" || e.key == \"W\" || e.key == \"ArrowUp\") {\n    upPressed = true;\n    downPressed = false;\n  }\n  if (e.key == \"s\" || e.key == \"S\" || e.key == \"ArrowDown\") {\n    downPressed = true;\n    upPressed = false;\n  }\n});\n\ndocument.addEventListener('keyup', e => {\n  //console.log(e.key);\n  if (e.key == \"a\" || e.key == \"A\" || e.key == \"ArrowLeft\") {\n    leftPressed = false;\n  }\n  if (e.key == \"d\" || e.key == \"D\" || e.key == \"ArrowRight\") {\n    rightPressed = false;\n  }\n  if (e.key == \"w\" || e.key == \"W\" || e.key == \"ArrowUp\") {\n    upPressed = false;\n  }\n  if (e.key == \"s\" || e.key == \"S\" || e.key == \"ArrowDown\") {\n    downPressed = false;\n  }\n  if (e.key == \"m\" || e.key == \"M\") {\n    mPressed = false;\n  }\n});\n\nconst moveSpeed = 2;\nconst playerAccel = .3;\nconst mapSpeed = 7;\n\nfunction animate() {\n  if (showMap) {\n    if (leftPressed) {\n      centerX -= mapSpeed;\n    }\n    if (rightPressed) {\n      centerX += mapSpeed;\n    }\n    if (upPressed) {\n      centerY -= mapSpeed;\n    }\n    if (downPressed) {\n      centerY += mapSpeed;\n    }\n  }\n  else {\n    player.velocity = player.velocity || { x: 0, y: 0 };\n    if (leftPressed && player.velocity.x > -moveSpeed) {\n      //player.position.x -= moveSpeed;\n      player.velocity.x -= playerAccel;\n    }\n    if (rightPressed && player.velocity.x < moveSpeed) {\n      //player.position.x += moveSpeed;\n      player.velocity.x += playerAccel;\n    }\n    if (upPressed && player.velocity.y > -moveSpeed) {\n      //player.position.y -= moveSpeed;\n      player.velocity.y -= playerAccel;\n    }\n    if (downPressed && player.velocity.y < moveSpeed) {\n      //player.position.y += moveSpeed;\n      player.velocity.y += playerAccel;\n    }\n  }\n\n  // for now we are assuming the player is ALWAYS centered. \n  // This is probably bad and we may want to change it when we switch to a canvas based approach.\n  MoveItems([player]);\n  CollideWithWalls(player, FirstFloor);\n  //GetItems().forEach(item => CollideWithWalls(item, FirstFloor));\n  //CollideItems([player]);\n  ApplyFriction([player]);\n\n  // FOLLOW CAM\n  if (!showMap) {\n    centerX = player.position.x;\n    centerY = player.position.y;\n  }\n\n  //TODO: later. UpdateFog();\n  RenderApp();\n  requestAnimationFrame(() => animate());\n}\n\nanimate();\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}