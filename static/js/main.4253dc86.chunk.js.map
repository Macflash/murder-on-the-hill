{"version":3,"sources":["tiles/Coord.ts","tiles/Items.tsx","tiles/Collision.ts","tiles/Size.ts","GridTile.tsx","tiles/Direction.ts","tiles/Tile.ts","tiles/RegisterTiles.ts","tiles/Floor.ts","tiles/SightLines.ts","Player.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["MoveCoord","c","direction","x","y","items","GetItems","GridItem","props","item","hW","width","hH","height","title","name","style","position","zIndex","backgroundColor","color","top","centerY","window","innerHeight","left","centerX","innerWidth","GetTileCoord","Math","floor","GetRoomCoord","tileCoord","HasRoomOrCreate","tile","coord","create","doors","has","newCoord","hasCoord","fillCoord","CollideWithWalls","createOnDoor","hT","hD","doorSize","hDX","hDY","roomX","roomY","leftWall","wallSize","rightWall","topWall","bottomWall","getCoord","hasDoor","abs","velocity","screenSize","max","tileViewDist","ceil","addEventListener","console","log","GridTile","a","b","overlayMode","cameraCoord","display","justifyContent","alignItems","undefined","info","map","d","opened","hasNeighbor","getWallPosition","size","bottom","right","GridWall","row","filler","flex","flexDirection","overflow","cursor","onClick","RenderApp","Tile","initialDoors","rotation","this","Set","neededDoors","neededWalls","canPlace","forEach","r","t","rotate","rotatedDoors","door","add","allDirections","index","indexOf","length","Rotate","FourWay","TeeWay","Straight","LTurn","RTurn","DeadEnd","AllWay","copy","TwoWay","TileLibrary","Index","FirstFloor","grid","Map","getTile","get","hasTile","setTile","alert","set","fillTile","neighbor","Opposite","matchingTiles","filter","newTile","random","Array","from","fog","ctx","rayStep","rayLength","angleSize","PI","shootRay","start","stepVector","ray","toScreenSpot","UpdateFog","player","document","getElementById","getContext","clearRect","rayPoints","points","angle","push","cos","sin","shootRaysInCircle","fillStyle","strokeStyle","beginPath","playerCoord","moveTo","point","p","lineTo","stroke","fill","mass","Player","showMap","canvasStyle","leftPressed","upPressed","rightPressed","downPressed","mPressed","e","key","animate","players","i","ApplyFriction","requestAnimationFrame","App","React","useState","setState","rerender","useCallback","useEffect","className","padding","id","opacity","mixBlendMode","tiles","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.4253dc86.chunk.js","sourcesContent":["import { Direction } from './Direction';\r\n\r\nexport interface Coord {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport function MoveCoord(c: Coord, direction: Direction): Coord {\r\n  const { x, y } = c;\r\n  // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return { x, y: y - 1 };\r\n    case \"BOTTOM\":\r\n      return { x, y: y + 1 };\r\n    case \"RIGHT\":\r\n      return { x: x + 1, y };\r\n    case \"LEFT\":\r\n      return { x: x - 1, y };\r\n  }\r\n}\r\n\r\nexport function MidPoint(a: Coord, b: Coord) {\r\n  return {\r\n    x: (a.x + b.x) / 2,\r\n    y: (a.y + b.y) / 2,\r\n  };\r\n}\r\n\r\n// Distances ordered by their stupidness\r\nexport function Distance(a: Coord, b: Coord) {\r\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\r\n}\r\n\r\nexport function HammingDistance(a: Coord, b: Coord) {\r\n  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n}\r\n\r\nexport function EitherDirectionDistance(a: Coord, b: Coord) {\r\n  return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\r\n}","import * as React from 'react';\r\nimport { centerY, centerX } from '../App';\r\nimport { Coord } from \"./Coord\";\r\n\r\nexport interface Item {\r\n    position: Coord;\r\n    height: number;\r\n    width: number;\r\n\r\n    name?: string;\r\n    color?: string; // TODO this should be an image or graphic or canvas dude!\r\n\r\n    mass: number;\r\n    velocity: Coord;\r\n}\r\n\r\nexport function ToBoundingBox(item: Item) {\r\n    return {\r\n        x: item.position.x - item.width * .5,\r\n        y: item.position.y - item.height * .5,\r\n        height: item.height,\r\n        width: item.width,\r\n    };\r\n}\r\n\r\n/* Check two items for collision! */\r\nexport function RectangleCollision(a: Item, b: Item) {\r\n    const rect1 = ToBoundingBox(a);\r\n    const rect2 = ToBoundingBox(b);\r\n    return rect1.x < rect2.x + rect2.width &&\r\n        rect1.x + rect1.width > rect2.x &&\r\n        rect1.y < rect2.y + rect2.height &&\r\n        rect1.y + rect1.height > rect2.y;\r\n}\r\n\r\nvar items: Item[] = [];\r\n\r\n// yo if we stored these BY room it would be pretty cool.\r\nexport function AddItem(item: Item) {\r\n    items.push(item);\r\n}\r\n\r\nexport function GetItems() {\r\n    return items;\r\n}\r\n\r\nexport const itemZindex = 50;\r\n\r\nexport function GridItem(props: { item: Item, zIndex?: number }) {\r\n    const { item } = props;\r\n    const hW = item.width * .5;\r\n    const hH = item.height * .5;\r\n\r\n    return <div\r\n        title={item.name}\r\n        style={{\r\n            position: \"absolute\",\r\n            zIndex: props.zIndex || itemZindex,\r\n            height: item.height,\r\n            width: item.width,\r\n            backgroundColor: item.color || \"grey\",\r\n            top: item.position.y - centerY + (.5 * window.innerHeight) - hH,\r\n            left: item.position.x - centerX + (.5 * window.innerWidth) - hW,\r\n        }}>\r\n    </div>;\r\n}\r\n\r\n/*\r\nAddItem({\r\n    position: { x: Math.random() * 600 - 300, y: Math.random() * 400 - 200 },\r\n    height: 15,\r\n    width: 20,\r\n    color: \"green\",\r\n    name: \"purse\",\r\n    mass: 4,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n\r\nAddItem({\r\n    position: { x: Math.random() * 200 - 100, y: Math.random() * 400 - 200 },\r\n    height: 20,\r\n    width: 20,\r\n    color: \"brown\",\r\n    name: \"Box\",\r\n    mass: 15,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n\r\n\r\nAddItem({\r\n    position: { x: Math.random() * 200 - 100, y: Math.random() * 800 - 400 },\r\n    height: 10,\r\n    width: 10,\r\n    color: \"gold\",\r\n    name: \"pocketwatch\",\r\n    mass: .5,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n\r\nAddItem({\r\n    position: { x: Math.random() * 200 - 100, y: Math.random() * 800 - 400 },\r\n    height: 70,\r\n    width: 40,\r\n    color: \"tan\",\r\n    name: \"Table\",\r\n    mass: 70,\r\n    velocity: { x: 0, y: 0 },\r\n});\r\n*/","\r\n// ok how can we do... intersections and interactions?\r\n// #1 only can hit things in your room (or very rarely a neighboring room that is close by..)\r\n\r\nimport { doorSize, wallSize } from \"../GridTile\";\r\nimport { Coord, MidPoint, MoveCoord } from \"./Coord\";\r\nimport { Direction } from \"./Direction\";\r\nimport { Floor } from \"./Floor\";\r\nimport { GetItems, Item, RectangleCollision } from \"./Items\";\r\nimport { tileSize } from \"./Size\";\r\nimport { Tile } from \"./Tile\";\r\n\r\n/** The TILE the item is in. */\r\nexport function GetTileCoord(c: Coord): Coord {\r\n    const hT = .5 * tileSize;\r\n    const x = Math.floor((c.x + hT) / tileSize);\r\n    const y = Math.floor((c.y + hT) / tileSize);\r\n    return { x, y };\r\n}\r\n\r\n/** The relative place in the current TILE the item is in. */\r\nexport function GetRoomCoord(item: Item, tileCoord: Coord): Coord {\r\n    const x = item.position.x - (tileCoord.x * tileSize);\r\n    const y = item.position.y - (tileCoord.y * tileSize);\r\n    return { x, y };\r\n}\r\n\r\nconst doorEdgeSize = 3;\r\n\r\nexport function GetWallCorners(){\r\n    // ray trace to all of these basically?\r\n}\r\nexport function HasRoomOrCreate(floor: Floor|undefined, tile:Tile|undefined, coord: Coord, direction: Direction, create: boolean) {\r\n    const hasDoor = tile && tile.doors.has(direction);\r\n\r\n    if (!hasDoor) { return false; }\r\n\r\n    const newCoord = MoveCoord(coord, direction);\r\n    if (!floor?.hasCoord(newCoord)) {\r\n        if(create){\r\n            floor?.fillCoord(newCoord);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\nexport function CollideWithWalls(item: Item, floor?: Floor, createOnDoor = false): boolean {\r\n    const hT = .5 * tileSize;\r\n    const hW = .5 * item.width;\r\n    const hH = .5 * item.height;\r\n    const hD = .5 * doorSize;\r\n\r\n    const hDX = hD - hW;\r\n    const hDY = hD - hH;\r\n\r\n    // which TILE is it in?\r\n\r\n    const tileCoord = GetTileCoord(item.position);\r\n    const { x: roomX, y: roomY } = GetRoomCoord(item, tileCoord);\r\n\r\n    const leftWall = hW + wallSize - hT;\r\n    const rightWall = -1 * leftWall;\r\n    const topWall = hH + wallSize - hT;\r\n    const bottomWall = -1 * topWall;\r\n\r\n    const tile = floor?.getCoord(tileCoord);\r\n\r\n    // If you are inside the wall boundary\r\n    if (roomX <= leftWall) {\r\n        // AND you are outside of the door area (or there is no door):\r\n        // Push you back to the edge of the wall.\r\n        const hasDoor = HasRoomOrCreate(floor, tile, tileCoord, \"LEFT\", createOnDoor);\r\n        if (Math.abs(roomY) > hDY || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomY > 0){\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.x += leftWall - roomX;\r\n            item.velocity.x = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomX >= rightWall) {\r\n        const hasDoor = HasRoomOrCreate(floor, tile, tileCoord, \"RIGHT\", createOnDoor);\r\n        if (Math.abs(roomY) > hDY || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomY) < hDY + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomY > 0){\r\n                    item.position.y += hDY - roomY;\r\n                }\r\n                else {\r\n                    item.position.y -= hDY + roomY;\r\n                }\r\n                item.velocity.y = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.x += rightWall - roomX;\r\n            item.velocity.x = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY <= topWall) {\r\n        const hasDoor = HasRoomOrCreate(floor, tile, tileCoord, \"TOP\", createOnDoor);\r\n        if (Math.abs(roomX) > hDX || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomX > 0){\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.y += topWall - roomY;\r\n            item.velocity.y = 0;\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY >= bottomWall) {\r\n        const hasDoor = HasRoomOrCreate(floor, tile, tileCoord, \"BOTTOM\", createOnDoor);\r\n        if (Math.abs(roomX) > hDX || !hasDoor) {\r\n            if (hasDoor && Math.abs(roomX) < hDX + doorEdgeSize) {\r\n                // so we know you are within the range of the door.\r\n                // so we want to push you BACK towards the center\r\n                if(roomX > 0){\r\n                    item.position.x += hDX - roomX;\r\n                }\r\n                else {\r\n                    item.position.x -= hDX + roomX;\r\n                }\r\n                item.velocity.x = 0;\r\n                return true;\r\n            }\r\n\r\n            item.position.y += bottomWall - roomY;\r\n            item.velocity.y = 0;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function ApplyFriction(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach(item => {\r\n        if (item.velocity) {\r\n            if (item.velocity.x) {\r\n                item.velocity.x *= .9;\r\n                if (Math.abs(item.velocity.x) < .1) { item.velocity.x = 0; }\r\n            }\r\n            if (item.velocity.y) {\r\n                item.velocity.y *= .9;\r\n                if (Math.abs(item.velocity.y) < .1) { item.velocity.y = 0; }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function InelasticCollision(a: Item, b: Item) {\r\n    // final velocity\r\n    const x = (a.mass * a.velocity.x + b.mass * b.velocity.x) / (a.mass + b.mass);\r\n    const y = (a.mass * a.velocity.y + b.mass * b.velocity.y) / (a.mass + b.mass);\r\n\r\n    // step back their velocities a bit??\r\n\r\n    const fudge = .2;\r\n    a.position.x -= a.velocity.x * fudge;\r\n    a.position.y -= a.velocity.y * fudge;\r\n    b.position.x -= b.velocity.x * fudge;\r\n    b.position.y -= b.velocity.y * fudge;\r\n\r\n    // and we want to PUSH them out so they are not colliding.\r\n    // How can we do that? Ideally we would like factor in the faces, but for laziness\r\n    // we could just push opposite the direction?\r\n    a.velocity.x = x;\r\n    a.velocity.y = y;\r\n    b.velocity.x = x;\r\n    b.velocity.y = y;\r\n}\r\n\r\nexport function CollideItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach((item, i) => {\r\n        if (i < items.length - 1) {\r\n            for (let j = i + 1; j < items.length; j++) {\r\n                if (RectangleCollision(item, items[j])) {\r\n                    //console.log(\"COLLISION!\", item.name, items[j].name);\r\n                    // TODO: update velocity and stuff??\r\n                    InelasticCollision(item, items[j]);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function MoveItems(players: Item[]) {\r\n    const items = [...players, ...GetItems()];\r\n    items.forEach((item, i) => {\r\n        if (item.velocity.x) {\r\n            item.position.x += item.velocity.x;\r\n        }\r\n        if (item.velocity.y) {\r\n            item.position.y += item.velocity.y;\r\n        }\r\n    });\r\n}","export const tileSize = 300;\r\n","import React from 'react';\r\nimport { EitherDirectionDistance, HammingDistance, MoveCoord } from './tiles/Coord';\r\nimport { Direction, AllDirections } from './tiles/Direction';\r\nimport { Tile } from './tiles/Tile';\r\nimport { centerY, centerX, RenderApp } from './App';\r\nimport { Floor } from \"./tiles/Floor\";\r\nimport { GetTileCoord } from './tiles/Collision';\r\nimport { tileSize } from './tiles/Size';\r\n\r\nexport const wallSize = 10;\r\nexport const doorSize = 75;\r\n\r\n// probably only update this on resize\r\nvar screenSize = Math.max(window.innerWidth, window.innerHeight);\r\nexport var tileViewDist = Math.ceil(screenSize / (2 * tileSize));\r\n\r\nwindow.addEventListener('resize', ()=>{\r\n  screenSize = Math.max(window.innerWidth, window.innerHeight);\r\n  tileViewDist = Math.ceil(screenSize / (2 * tileSize));\r\n  console.log(\"Updated view dist\", tileViewDist);\r\n});\r\n\r\nconsole.log(\"Initial view dist\", tileViewDist);\r\n\r\nexport const GridTile: React.FC<{ tile: Tile; floor: Floor; overlayMode: boolean}> = props => {\r\n  const { tile, floor, overlayMode } = props;\r\n\r\n  // check screen space if we should render it!\r\n  const tileCoord = { x: tile.x, y: tile.y };\r\n  const cameraCoord = GetTileCoord({ x: centerX, y: centerY });\r\n  if (EitherDirectionDistance(tileCoord, cameraCoord) > tileViewDist) {\r\n    return null;\r\n  }\r\n\r\n  return <div\r\n    style={{\r\n      zIndex: overlayMode ? 10 : 4,\r\n      position: \"absolute\",\r\n      height: tileSize,\r\n      width: tileSize,\r\n      top: tile.y! * tileSize + .5 * (window.innerHeight - tileSize) - centerY,\r\n      left: tile.x! * tileSize + .5 * (window.innerWidth - tileSize) - centerX,\r\n      display: \"flex\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      color: \"white\",\r\n      //border: '5px solid black',\r\n      backgroundColor:  overlayMode ? undefined : \"#663333\",\r\n    }}>\r\n    {tile.info.name}\r\n    {AllDirections().map(d => <GridWall\r\n      overlayMode={overlayMode}\r\n      tile={tile}\r\n      floor={floor}\r\n      direction={d}\r\n      hasDoor={tile.doors.has(d)}\r\n      opened={tile.hasNeighbor(floor, d)}\r\n    />)}\r\n  </div>;\r\n}\r\n\r\nfunction getWallPosition(direction: Direction, size: number) {\r\n  let top: string | number = 0;\r\n  let bottom: string | number = 0;\r\n  let left: string | number = 0;\r\n  let right: string | number = 0;\r\n\r\n  let width: number | undefined = size;\r\n  let height: number | undefined = size;\r\n\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      bottom = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"BOTTOM\":\r\n      top = \"auto\";\r\n      width = undefined;\r\n      break;\r\n    case \"RIGHT\":\r\n      left = \"auto\";\r\n      height = undefined;\r\n      break;\r\n    case \"LEFT\":\r\n      right = \"auto\";\r\n      height = undefined;\r\n      break;\r\n  }\r\n\r\n  return { top, bottom, left, right, width, height };\r\n}\r\n\r\nexport const GridWall: React.FC<{ overlayMode: boolean, tile: Tile; floor: Floor; direction: Direction; hasDoor: boolean; opened: boolean; }> = props => {\r\n  const { direction, opened, hasDoor, tile, floor, overlayMode } = props;\r\n  const row = direction === \"TOP\" || direction === \"BOTTOM\";\r\n  const filler = <div style={{ \r\n    flex: \"auto\",\r\n     backgroundColor: \"#322\",\r\n      height: row ? \"100%\" : undefined, width: row ? undefined : \"100%\" }}></div>;\r\n\r\n  return <div\r\n    style={{\r\n      ...getWallPosition(direction, overlayMode ? 3 : wallSize),\r\n      position: \"absolute\",\r\n      display: \"flex\",\r\n      flexDirection: row ? \"row\" : \"column\",\r\n      justifyContent: \"center\",\r\n      alignItems: \"center\",\r\n      overflow: \"hidden\",\r\n    }}>\r\n    {filler}\r\n    {hasDoor ?\r\n      <div\r\n        style={{ \r\n          cursor: opened ? undefined : \"pointer\",\r\n           height: doorSize, \r\n           width: doorSize,\r\n            backgroundColor: opened ? \"\" : \"grey\" }}\r\n        onClick={opened ? undefined : () => {\r\n          floor.fillCoord(MoveCoord(tile.coord, direction));\r\n          RenderApp();\r\n        }}\r\n      >\r\n      </div>\r\n      : null}\r\n    {filler}\r\n  </div>;\r\n};\r\n","export type Direction = \"TOP\" | \"LEFT\" | \"RIGHT\" | \"BOTTOM\";\r\n\r\nexport function AllDirections(): Direction[] {\r\n  return [\"TOP\", \"RIGHT\", \"BOTTOM\", \"LEFT\"];\r\n}\r\n\r\nexport function Opposite(direction: Direction): Direction {\r\n  switch (direction) {\r\n    case \"TOP\":\r\n      return \"BOTTOM\";\r\n    case \"BOTTOM\":\r\n      return \"TOP\";\r\n    case \"RIGHT\":\r\n      return \"LEFT\";\r\n    case \"LEFT\":\r\n      return \"RIGHT\";\r\n  }\r\n}\r\n\r\nexport function Rotate(direction: Direction, rotation: number) {\r\n  const allDirections = AllDirections();\r\n  const index = allDirections.indexOf(direction);\r\n  return allDirections[(index + rotation) % allDirections.length];\r\n}\r\n","import { Coord, MoveCoord } from './Coord';\r\nimport { Direction, Rotate } from './Direction';\r\nimport { Floor } from './Floor';\r\n\r\ninterface TileInfo {\r\n  name: string;\r\n\r\n  doors: Direction[];\r\n}\r\n\r\nexport class Tile {\r\n  // Rotations RIGHT in 90 increments. 0-3;\r\n  //public rotation = 0; // TODO\r\n  public x = 0;\r\n  public y = 0;\r\n  private initialDoors: Set<Direction>;\r\n  private rotation = 0;\r\n\r\n  constructor(public readonly info: TileInfo) {\r\n    const { doors } = info;\r\n    this.initialDoors = new Set<Direction>(doors);\r\n  }\r\n\r\n  get coord(): Coord {\r\n    return { x: this.x, y: this.y };\r\n  }\r\n\r\n  get doors(): Set<Direction> {\r\n    const rotatedDoors = new Set<Direction>();\r\n    this.initialDoors.forEach(door => { rotatedDoors.add(Rotate(door, this.rotation)); });\r\n    return rotatedDoors;\r\n  }\r\n\r\n  /** Return valid rotations for the tile to be placed in a spot with the given constraints. */\r\n  // TODO: Handle ROTATION PROBABLY!\r\n  canPlace(neededDoors: Set<Direction>, neededWalls: Set<Direction>): boolean {\r\n    // TODO: Wait what about WALLS where we SHOULDNT have doors!\r\n    // ensure all needed doors are there\r\n    let canPlace = true;\r\n    neededDoors.forEach(direction => {\r\n      if (!this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    // ensure all needed walls have no doors!\r\n    neededWalls.forEach(direction => {\r\n      if (this.doors.has(direction)) {\r\n        canPlace = false;\r\n      }\r\n    });\r\n\r\n    return canPlace;\r\n  }\r\n\r\n  copy(r?: number) {\r\n    const t = new Tile(this.info);\r\n    if (r) {\r\n      t.rotate(r);\r\n    }\r\n    else {\r\n      t.rotate(this.rotation);\r\n    }\r\n    return t;\r\n  }\r\n\r\n  rotate(r: number) {\r\n    this.rotation = r % 4;\r\n    return this;\r\n  }\r\n\r\n  hasNeighbor(floor: Floor, direction: Direction): boolean {\r\n    // let neightbor: boolean; // Later we might want to be able to \"CLOSE\" doors again? skip for now.\r\n    return floor.hasCoord(MoveCoord(this.coord, direction));\r\n  }\r\n}\r\n","import { Tile } from './Tile';\r\n\r\nexport const FourWay = new Tile({ name: \"Fourway\", doors: [\"TOP\", \"LEFT\", \"RIGHT\", \"BOTTOM\"] });\r\nconst TeeWay = new Tile({ name: \"TeeWay\", doors: [\"TOP\", \"LEFT\", \"RIGHT\"] });\r\nconst Straight = new Tile({ name: \"Straight\", doors: [\"TOP\", \"BOTTOM\"] });\r\nconst LTurn = new Tile({ name: \"LTurn\", doors: [\"TOP\", \"RIGHT\"] });\r\nconst RTurn = new Tile({ name: \"RTurn\", doors: [\"TOP\", \"LEFT\"] });\r\nconst DeadEnd = new Tile({ name: \"DeadEnd\", doors: [\"TOP\"] });\r\n\r\nfunction AllWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1), tile.copy(2), tile.copy(3)];\r\n}\r\n\r\nfunction TwoWay(tile: Tile): Tile[] {\r\n  return [tile, tile.copy(1)];\r\n}\r\n\r\nexport const TileLibrary = [\r\n  ...TwoWay(FourWay),\r\n  ...TwoWay(Straight),\r\n  ...AllWay(TeeWay),\r\n  ...AllWay(LTurn),\r\n  ...AllWay(RTurn),\r\n  ...AllWay(DeadEnd),\r\n];\r\n","import { Coord, MoveCoord } from './Coord';\r\nimport { Direction, AllDirections, Opposite } from './Direction';\r\nimport { Tile } from './Tile';\r\nimport { TileLibrary, FourWay } from './RegisterTiles';\r\n\r\nexport function IndexCoord(c: Coord) { return Index(c.x, c.y); }\r\nexport function Index(x: number, y: number) { return `${x}, ${y}`; }\r\n\r\nexport class Floor {\r\n  constructor(public readonly name: string) { }\r\n\r\n  private grid = new Map<string, Tile>();\r\n\r\n  getCoord(c: Coord): Tile | undefined { return this.getTile(c.x, c.y); }\r\n  getTile(x: number, y: number): Tile | undefined { return this.grid.get(Index(x, y)); }\r\n\r\n  hasCoord(c: Coord): boolean { return this.hasTile(c.x, c.y); }\r\n  hasTile(x: number, y: number): boolean { return this.grid.has(Index(x, y)); }\r\n\r\n  setCoord(tile: Tile, c: Coord) { this.setTile(tile, c.x, c.y); }\r\n  setTile(tile: Tile, x: number, y: number) {\r\n    if (this.hasTile(x, y)) {\r\n      alert(\"Already had a tile there!\");\r\n      throw \"already had a tile!\";\r\n    }\r\n\r\n    tile.x = x;\r\n    tile.y = y;\r\n    this.grid.set(Index(x, y), tile);\r\n  }\r\n\r\n  get tiles(): Tile[] {\r\n    return Array.from(this.grid, ([key, tile]) => tile);\r\n  }\r\n\r\n  // return all POSSIBLE playing places\r\n  getValidSpotsForTiles() {\r\n    // this is maybe not the best approach. Cool ,but not needed right now...\r\n  }\r\n\r\n  fillCoord(c: Coord) { this.fillTile(c.x, c.y); }\r\n  fillTile(x: number, y: number) {\r\n    // fill a gap with a VALID tile. Woops do we need rotation soon?\r\n    // 1. get all tiles bordering this.\r\n    const neighbors = AllDirections().map(d => this.getCoord(MoveCoord({ x, y }, d)));\r\n    const neededDoors = new Set<Direction>();\r\n    const neededWalls = new Set<Direction>();\r\n\r\n    AllDirections().forEach(direction => {\r\n      const neighbor = this.getCoord(MoveCoord({ x, y }, direction));\r\n      if (neighbor) {\r\n        if (neighbor.doors.has(Opposite(direction))) {\r\n          neededDoors.add(direction);\r\n        }\r\n        else {\r\n          neededWalls.add(direction);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Find possible tiles\r\n    // TODO: Factor in floor type and stuff.\r\n    const matchingTiles = TileLibrary.filter(tile => tile.canPlace(neededDoors, neededWalls));\r\n\r\n    // Pick a random tile from the possible ones.\r\n    if (!matchingTiles) { throw \"wow we should really fix that!\"; }\r\n\r\n    const newTile = matchingTiles[Math.floor(Math.random() * matchingTiles.length)].copy();\r\n    this.setTile(newTile, x, y);\r\n  }\r\n}\r\n\r\nexport const FirstFloor = new Floor(\"Main Floor\");\r\nFirstFloor.setTile(FourWay.copy(), 0, 0);\r\n","// anything beyond this we don't need to render.\r\n\r\nimport { centerX, centerY } from \"../App\";\r\nimport { doorSize, tileViewDist, wallSize } from \"../GridTile\";\r\nimport { GetTileCoord, GetRoomCoord, CollideWithWalls } from \"./Collision\";\r\nimport { Coord, MoveCoord } from \"./Coord\";\r\nimport { Direction } from \"./Direction\";\r\nimport { Floor } from \"./Floor\";\r\nimport { Item } from \"./Items\";\r\nimport { tileSize } from \"./Size\";\r\n\r\n// As long as we factor in their size as well...\r\nexport const sightDistance = 400;\r\n\r\nvar fog: HTMLCanvasElement;\r\nvar ctx: CanvasRenderingContext2D;\r\nwindow.addEventListener('resize', () => {\r\n    fog.width = window.innerWidth;\r\n    fog.height = window.innerHeight;\r\n    //UpdateFog();\r\n});\r\n\r\n// terrible stripped down version of the actual collide item with wall function\r\nexport function IsInWall(c: Coord, floor?: Floor) {\r\n    const hT = .5 * tileSize;\r\n    const hW = 1;\r\n    const hH = 1;\r\n    const hD = .5 * doorSize;\r\n\r\n    const hDX = hD - hW;\r\n    const hDY = hD - hH;\r\n\r\n    // which TILE is it in?\r\n\r\n    const tileCoord = GetTileCoord(c);\r\n    const { x: roomX, y: roomY } = GetRoomCoord({ position: c } as Item, tileCoord);\r\n\r\n    const leftWall = hW + wallSize - hT;\r\n    const rightWall = -1 * leftWall;\r\n    const topWall = hH + wallSize - hT;\r\n    const bottomWall = -1 * topWall;\r\n\r\n    const tile = floor?.getCoord(tileCoord);\r\n\r\n    //hasDoor={tile.doors.has(d)}\r\n    //opened={tile.hasNeighbor(floor, d)}\r\n\r\n    function HasRoom(coord: Coord, direction: Direction) {\r\n        const hasDoor = tile && tile.doors.has(direction);\r\n\r\n        if (!hasDoor) { return false; }\r\n\r\n        const newCoord = MoveCoord(coord, direction);\r\n        return floor?.hasCoord(newCoord);\r\n    }\r\n\r\n    // TODO: Stop weirdness at the EDGE of doors.\r\n\r\n    // If you are inside the wall boundary\r\n    if (roomX <= leftWall) {\r\n        // AND you are outside of the door area (or there is no door):\r\n        // Push you back to the edge of the wall.\r\n        if (Math.abs(roomY) > hDY || !HasRoom(tileCoord, \"LEFT\")) {\r\n            return true;\r\n        }\r\n    }\r\n    if (roomX >= rightWall) {\r\n        if (Math.abs(roomY) > hDY || !HasRoom(tileCoord, \"RIGHT\")) {\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY <= topWall) {\r\n        if (Math.abs(roomX) > hDX || !HasRoom(tileCoord, \"TOP\")) {\r\n            return true;\r\n        }\r\n    }\r\n    if (roomY >= bottomWall) {\r\n        if (Math.abs(roomX) > hDX || !HasRoom(tileCoord, \"BOTTOM\")) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // tile\r\n}\r\n\r\n\r\n/** Returns where this hits a wall! */\r\nconst rayStep = wallSize;\r\nvar rayLength = 10 + tileViewDist * tileSize / rayStep; //was like 75 or 100;\r\nconsole.log(\"ray length\", rayLength);\r\nwindow.addEventListener('resize', () => {\r\n    rayLength = 10 + tileViewDist * tileSize / rayStep;\r\n    console.log(\"ray length\", rayLength);\r\n});\r\n// 20 is ok, 60 is good, \r\nconst angleSize = Math.PI / 100;\r\n\r\n// dude you could probably just CALCULATE (DO the math bro! it's faster) the next time the ray would = .5 tilesize  % tilesize\r\nexport function shootRay(start: Coord, stepVector: Coord, floor: Floor): Coord {\r\n    // assume vector is the RIGHT length\r\n    let length = 0;\r\n    let ray = { x: start.x, y: start.y };\r\n    while (!CollideWithWalls({ position: ray, height: 1, width: 1, velocity: { x: 0, y: 0 } } as Item, floor)\r\n        && length < rayLength) {\r\n        ray.x += stepVector.x;\r\n        ray.y += stepVector.y;\r\n        length++;\r\n    }\r\n\r\n    return ray;\r\n}\r\n// PI/10 is clunky, PI/20 is pretty dang smooth.\r\nexport function shootRaysInCircle(start: Coord, floor: Floor) {\r\n    const points: Coord[] = [];\r\n    let angle = 0;\r\n    while (angle < Math.PI * 2) {\r\n        points.push(shootRay(start, {\r\n            x: Math.cos(angle) * rayStep,\r\n            y: Math.sin(angle) * rayStep,\r\n        }, floor));\r\n        angle += angleSize;\r\n    }\r\n    return points;\r\n}\r\n\r\nfunction toScreenSpot(c: Coord): Coord {\r\n    return {\r\n        x: c.x - centerX + (.5 * window.innerWidth),\r\n        y: c.y - centerY + (.5 * window.innerHeight),\r\n    }\r\n}\r\n\r\nexport function UpdateFog(player: Item, floor: Floor) {\r\n\r\n    if (!ctx) {\r\n        fog = document.getElementById(\"fog\") as HTMLCanvasElement;\r\n        if (!fog) { return; }\r\n        fog.width = window.innerWidth;\r\n        fog.height = window.innerHeight;\r\n\r\n        ctx = fog.getContext(\"2d\")!;\r\n        if (!ctx) { return; }\r\n    }\r\n\r\n    //fog.style.opacity = \".5\";\r\n    ctx.clearRect(0, 0, fog.width, fog.height);\r\n\r\n    const rayPoints = shootRaysInCircle(player.position, floor);\r\n\r\n    ctx.fillStyle = \"lightyellow\";\r\n    ctx.strokeStyle = \"1px lightyellow\";\r\n    ctx.beginPath();\r\n    const playerCoord = toScreenSpot(player.position);\r\n    ctx.moveTo(playerCoord.x, playerCoord.y);\r\n    rayPoints.forEach(point => {\r\n        const p = toScreenSpot(point);\r\n        ctx.lineTo(p.x, p.y);\r\n    });\r\n    const p = toScreenSpot(rayPoints[0]);\r\n    ctx.lineTo(p.x, p.y);\r\n    ctx.stroke();\r\n    ctx.fill();\r\n\r\n    // draw LINES to the wall edge. E.G.\r\n    // we need the player spot and the WALL corners.\r\n\r\n}\r\n\r\nfunction sourceInTest() {\r\n    // TEST ONLY\r\n\r\n    /*\r\n    This would be  the HTML to add in the app:\r\n     <canvas id=\"canvas_map\"\r\n              width={window.innerWidth}\r\n              height={window.innerHeight}\r\n              style={canvasStyle} />\r\n              <canvas id=\"canvas_sightlines\"\r\n                 width={window.innerWidth}\r\n                 height={window.innerHeight}\r\n                 style={canvasStyle} />\r\n                 <canvas id=\"canvas_result\"\r\n                    width={window.innerWidth}\r\n                    height={window.innerHeight}\r\n                    style={canvasStyle} />\r\n    */\r\n    const sightCv = document.getElementById(\"canvas_sightlines\") as HTMLCanvasElement;\r\n    const mapCv = document.getElementById(\"canvas_map\") as HTMLCanvasElement;\r\n    const resultCv = document.getElementById(\"canvas_result\") as HTMLCanvasElement;\r\n\r\n    if (!sightCv) { return; }\r\n\r\n    const sight_ctx = sightCv.getContext(\"2d\")!;\r\n    const map_ctx = mapCv.getContext(\"2d\")!;\r\n    const result_ctx = resultCv.getContext(\"2d\")!;\r\n\r\n    // draw a \"map tile\"\r\n    map_ctx.fillStyle = \"grey\";\r\n    map_ctx.fillRect(window.innerWidth / 2 - 200, window.innerHeight / 2 - 200, 400, 400);\r\n    map_ctx.fillStyle = \"#442222\";\r\n    map_ctx.fillRect(window.innerWidth / 2 - 150, window.innerHeight / 2 - 150, 300, 300);\r\n\r\n    // draw the \"sight line\"\r\n\r\n    sight_ctx.fillStyle = \"yellow\";\r\n    sight_ctx.strokeStyle = \"1px solid yellow\";\r\n    sight_ctx.beginPath();\r\n    sight_ctx.moveTo(window.innerWidth / 2, window.innerHeight / 2);\r\n    sight_ctx.lineTo(200, 200);\r\n    sight_ctx.fill();\r\n    sight_ctx.lineTo(200, 400);\r\n    sight_ctx.fill();\r\n    sight_ctx.lineTo(window.innerWidth / 2, window.innerHeight / 2);\r\n    sight_ctx.arc(window.innerWidth / 2, window.innerHeight / 2, 100, 0, Math.PI * 2)\r\n    sight_ctx.fill();\r\n    sight_ctx.stroke();\r\n    //sight_ctx.fillRect(window.innerWidth / 2-100, window.innerHeight / 2-100, 200,200);\r\n\r\n    // create the result\r\n    result_ctx.drawImage(sightCv, 0, 0);\r\n    result_ctx.globalCompositeOperation = \"source-in\";\r\n    result_ctx.drawImage(mapCv, 0, 0);\r\n\r\n    // hide the other canvases\r\n\r\n    sightCv.style.display = \"none\";\r\n    mapCv.style.display = \"none\";\r\n\r\n\r\n    // END TEST\r\n}","import React from 'react';\r\nimport { GridItem, Item } from \"./tiles/Items\";\r\n\r\nexport const player: Item = {\r\n  position: { x: 0, y: 0 },\r\n  height: 30,\r\n  width: 15,\r\n  color: \"red\",\r\n  name: \"You\",\r\n  velocity: { x: 0, y: 0 },\r\n  mass: 140,\r\n};\r\n\r\nexport const playerZindex = 51;\r\n\r\nexport function Player() {\r\n  return <GridItem item={player} zIndex={playerZindex} />\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport { GridTile } from './GridTile';\nimport { ApplyFriction, CollideItems, CollideWithWalls, MoveItems } from './tiles/Collision';\nimport { FirstFloor, Index } from './tiles/Floor';\nimport { sightDistance, UpdateFog } from './tiles/SightLines';\nimport { Player, player } from './Player';\nimport { GetItems, GridItem, Item } from './tiles/Items';\n\nexport let centerX = 0;\nexport let centerY = 0;\n\nexport var RenderApp = () => { };\n\nvar showMap = false;\nvar showFog = true; // turn off for now.. Sightlines would be cool, but circle looks dumb.\nconst canvasStyle:React.CSSProperties = {\n  position: \"absolute\",\n            zIndex: 5,\n            width: \"100%\",\n            height: \"100%\",\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n};\n\nfunction App() {\n  const [, setState] = React.useState(0);\n  const rerender = React.useCallback(() => {\n    setState(Math.random());\n  }, [setState]);\n\n  React.useEffect(() => { RenderApp = rerender; }, [rerender]);\n\n  return (\n    <div className=\"App\" style={{ overflow: \"hidden\" }}>\n      {showMap ?\n        <div style={{ zIndex: 100, bottom: 0, padding: 20, position: \"absolute\", left: 0, right: 0 }}>\n          <div style={{ color: \"white\" }}>Map</div>\n          <button onClick={() => { centerY -= 100; rerender(); }}>UP!</button>\n          <button onClick={() => { centerY += 100; rerender(); }}>DOWN!</button>\n          <button onClick={() => { centerX -= 100; rerender(); }}>LEFT!</button>\n          <button onClick={() => { centerX += 100; rerender(); }}>RIGHT!</button>\n          <button onClick={() => { centerX = 0; centerY = 0; rerender(); }}>CENTER!</button>\n        </div> : null}\n      <Player />\n\n      <div>\n\n        {showFog ? <canvas id=\"fog\"\n          width={window.innerWidth}\n          height={window.innerHeight}\n          style={{\n            ...canvasStyle,\n            opacity: .2,\n            //mixBlendMode: \"multiply\",\n            filter: \"blur(5px)\",\n          }} /> : null}\n\n        <div id=\"gamefloor\" style={{ mixBlendMode: \"normal\" }}>\n\n          {FirstFloor.tiles.map((tile) => <GridTile\n            overlayMode={showMap}\n            floor={FirstFloor}\n            tile={tile}\n            key={Index(tile.x, tile.y)}\n          />)}\n\n          {GetItems().map((item) => <GridItem item={item} />)}\n\n        </div>\n      </div>\n\n    </div>\n  );\n}\n\nlet leftPressed = false;\nlet upPressed = false;\nlet rightPressed = false;\nlet downPressed = false;\n\nlet mPressed = false;\n\ndocument.addEventListener('keydown', e => {\n  if (e.key === \"m\" || e.key === \"M\") {\n    if (!mPressed) { showMap = !showMap; }\n    mPressed = true;\n  }\n\n  if (e.key === \"a\" || e.key === \"A\" || e.key === \"ArrowLeft\") {\n    leftPressed = true;\n    rightPressed = false;\n  }\n  if (e.key === \"d\" || e.key === \"D\" || e.key === \"ArrowRight\") {\n    rightPressed = true;\n    leftPressed = false;\n  }\n  if (e.key === \"w\" || e.key === \"W\" || e.key === \"ArrowUp\") {\n    upPressed = true;\n    downPressed = false;\n  }\n  if (e.key === \"s\" || e.key === \"S\" || e.key === \"ArrowDown\") {\n    downPressed = true;\n    upPressed = false;\n  }\n});\n\ndocument.addEventListener('keyup', e => {\n  //console.log(e.key);\n  if (e.key === \"a\" || e.key === \"A\" || e.key === \"ArrowLeft\") {\n    leftPressed = false;\n  }\n  if (e.key === \"d\" || e.key === \"D\" || e.key === \"ArrowRight\") {\n    rightPressed = false;\n  }\n  if (e.key === \"w\" || e.key === \"W\" || e.key === \"ArrowUp\") {\n    upPressed = false;\n  }\n  if (e.key === \"s\" || e.key === \"S\" || e.key === \"ArrowDown\") {\n    downPressed = false;\n  }\n  if (e.key === \"m\" || e.key === \"M\") {\n    mPressed = false;\n  }\n});\n\nconst moveSpeed = 2;\nconst playerAccel = .3;\nconst mapSpeed = 7;\n\nfunction animate() {\n  if (showMap) {\n    if (leftPressed) {\n      centerX -= mapSpeed;\n    }\n    if (rightPressed) {\n      centerX += mapSpeed;\n    }\n    if (upPressed) {\n      centerY -= mapSpeed;\n    }\n    if (downPressed) {\n      centerY += mapSpeed;\n    }\n  }\n  else {\n    player.velocity = player.velocity || { x: 0, y: 0 };\n    if (leftPressed && player.velocity.x > -moveSpeed) {\n      //player.position.x -= moveSpeed;\n      player.velocity.x -= playerAccel;\n    }\n    if (rightPressed && player.velocity.x < moveSpeed) {\n      //player.position.x += moveSpeed;\n      player.velocity.x += playerAccel;\n    }\n    if (upPressed && player.velocity.y > -moveSpeed) {\n      //player.position.y -= moveSpeed;\n      player.velocity.y -= playerAccel;\n    }\n    if (downPressed && player.velocity.y < moveSpeed) {\n      //player.position.y += moveSpeed;\n      player.velocity.y += playerAccel;\n    }\n  }\n\n  // for now we are assuming the player is ALWAYS centered. \n  // This is probably bad and we may want to change it when we switch to a canvas based approach.\n  MoveItems([player]);\n  CollideWithWalls(player, FirstFloor, true);\n  //GetItems().forEach(item => CollideWithWalls(item, FirstFloor));\n  //CollideItems([player]);\n  ApplyFriction([player]);\n\n  // FOLLOW CAM\n  if (!showMap) {\n    centerX = player.position.x;\n    centerY = player.position.y;\n  }\n\n  //TODO: later. \n  showFog && UpdateFog(player, FirstFloor);\n  RenderApp();\n  requestAnimationFrame(() => animate());\n}\n\nanimate();\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker === null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}